#分布式相关理论 #分布式事务

#2PC #3PC #TTC #Saga事务 #本地事务表 #MQ事务消息 #最大努力通知 

# 1 两阶段提交（2PC）

2PC 是一种实现分布式事务的简单模型，这两个阶段是：

## 1.1 两个阶段

### 准备阶段

事务协调者向各个事务参与者发起询问请求，各个参与者协调者进行回复：

- YES：表示已准备好，允许提交全局事务

- NO：表示本参与者无法拿到全局事务所需的本地资源，因为它被其他本地事务锁住了或超时。

### 提交阶段

根据各个参与者的恢复，协调者进行不同的操作：

- 各个参与者回复的都是 YES，则协调者向所有参与者发起事务提交操作，然后所有参与者收到后各自执行本地事务提交操作并向协调者发送 ACK；

- 如果任何一个参与者回复 NO 或者超时，则协调者向所有参与者发起事务回滚操作，然后所有参与者收到后各自执行本地事务回滚操作并向协调者发送 ACK。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313111703.png)

## 1.2 2PC存在的问题

1. 性能问题：执行过程中，所有参与节点都是事务阻塞性的，当参与者占有公共资源时，其他第三方节点访问公共资源就不得不处于阻塞状态，为了数据的一致性而牺牲了可用性，对性能影响较大，不适合高并发高性能场景。

2. 可靠性问题：2PC非常依赖协调者，当协调者发生故障时，尤其是第二阶段，那么所有的参与者就会都处于锁定事务资源的状态中，而无法继续完成事务操作（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）

3. 数据一致性问题：在阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。==于是整个分布式系统便出现了数据不一致性的现象。==

# 2 三阶段提交（3PC）

3PC，三阶段提交协议，是二阶段提交协议的改进版本，三阶段提交有两个改动点：

- 在协调者和参与者中都引入超时机制。
- 在第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。

3PC会分为3个阶段，CanCommit 准备阶段、PreCommit 预提交阶段、DoCommit 提交阶段，处理流程如下：

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313112755.png?token=ARKCCAC26UDTYURZB7BFFRTEB2MHY)

## 2.1 三个阶段

### 阶段一

协调者向参与者发送 canCommit 请求，参与者如果可以提交就返回Yes响应，否则返回No响应，具体流程如下：

- 事务询问：协调者向所有参与者发出包含事务内容的 canCommit 请求，询问是否可以提交事务，并等待所有参与者答复。
- 响应反馈：参与者收到 canCommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。

### 阶段二

协调者根据参与者的反应情况来决定是否可以进行事务的 PreCommit 操作。根据响应情况，有以下两种可能：

**情况一：执行事务（假如所有参与者均反馈 YES，协调者预执行事务）**

- 发送预提交请求：协调者向参与者发送 PreCommit 请求，并进入准备阶段
- 事务预提交 ：参与者接收到 PreCommit 请求后，会执行本地事务操作，并将 undo 和 redo 信息记录到事务日志中（但不提交事务）
- 响应反馈 ：如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313114614.png)

**情况二：中断事务（有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断）**

- 发送中断请求 ：协调者向所有参与者发送 abort 请求。
- 中断事务 ：参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313135348.png)

### 阶段三

**情况一：提交事务**

1. 发送提交请求：协调接收到所有参与者发送的ACK响应，那么他将从预提交状态进入到提交状态，并向所有参与者发送 doCommit 请求
2. 本地事务提交：参与者接收到 doCommit 请求之后，执行正式的事务提交，并在完成事务提交之后释放所有事务资源
3. 响应反馈：事务提交完之后，向协调者发送 ACK 响应。
4. 完成事务：协调者接收到所有参与者的 ACK 响应之后，完成事务。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313135946.png)

**情况二：中断事务（任何一个参与者反馈 NO，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务）**

1. 发送中断请求：如果协调者处于工作状态，向所有参与者发出 abort 请求
2. 事务回滚：参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
3. 反馈结果：参与者完成事务回滚之后，向协调者反馈 ACK 消息
4. 中断事务：协调者接收到参与者反馈的 ACK 消息之后，执行事务的中断。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313135930.png)

进入doCommit阶段后，无论协调者出现问题，或者协调者与参与者之间的网络出现问题，都会导致参与者无法接收到协调者发出的 doCommit 请求或 abort 请求。此时，**参与者都会在等待超时之后，继续执行事务提交。** 这其实基于概率来决定的，当进入第三阶段时，说明第一阶段收到所有参与者的CanCommit响应都是Yes，意味着大家都同意修改了，并且第二阶段所有的参与者对协调者的PreCommit请求也都是同意的。所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。

## 2.2 3PC缺点

与2PC相比，3PC降低了阻塞范围，并且在等待超时后，协调者或参与者会中断事务，避免了协调者单点问题，阶段三中协调者出现问题时，参与者会继续提交事务。

数据不一致问题依然存在，当在参与者收到 preCommit 请求后等待 doCommit 指令时，此时如果协调者请求中断事务，而协调者因为网络问题无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。

# 3 TTC

## 3.1 什么是TCC

TCC（Try Confirm Cancel）是应用层的两阶段提交，所以对代码的侵入性强，其核心思想是：针对每个操作，都要实现对应的确认和补偿操作，也就是业务逻辑的每个分支都需要实现 try、confirm、cancel 三个操作，第一阶段由业务代码编排来调用Try接口进行资源预留，当所有参与者的 Try 接口都成功了，事务协调者提交事务，并调用参与者的 confirm 接口真正提交业务操作，否则调用每个参与者的 cancel 接口回滚事务，并且由于 confirm 或者 cancel 有可能会重试，因此对应的部分需要支持幂等。

## 3.2 TCC的执行流程

**第一阶段：Try**

业务系统做检测并预留资源 (加锁，锁住资源)，比如常见的下单，在 try 阶段，我们不是真正的减库存，而是把下单的库存给锁定住。

**第二阶段：根据第一阶段的结果决定是执行 Confirm 还是 Cancel**

Confirm：执行真正的业务（执行业务，释放锁）
Cancle：是对Try阶段预留资源的释放（出问题，释放锁）

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313194912.png)

## 3.3 TCC如何解决了2PC的问题呢？

既然 TCC 是一种服务层面上的 2PC，它是如何解决 2PC 无法应对宕机问题的缺陷的呢？答案是不断重试。由于 try 操作锁住了全局事务涉及的所有资源，保证了业务操作的所有前置条件得到满足，因此无论是 confirm 阶段失败还是 cancel 阶段失败都能通过不断重试直至 confirm 或 cancel 成功（所谓成功就是所有的服务都对 confirm 或者 cancel 返回了 ACK）。

这里还有个关键问题，在不断重试 confirm 和 cancel 的过程中（考虑到网络二将军问题的存在）有可能重复进行了 confirm 或 cancel，因此**还要再保证 confirm 和 cancel 操作具有幂等性，也就是整个全局事务中，每个参与者只进行一次 confirm 或者 cancel。**

实现 confirm 和 cancel 操作的幂等性，有很多解决方案，例如每个参与者可以维护一个去重表（可以利用数据库表实现也可以使用内存型 KV 组件实现），记录每个全局事务（以全局事务标记 XID 区分）是否进行过 confirm 或 cancel 操作，若已经进行过，则不再重复执行。

>TCC 由支付宝团队提出，被广泛应用于金融系统中。我们用银行账户余额购买基金时，会注意到银行账户中用于购买基金的那部分余额首先会被冻结，由此我们可以猜想，这个过程大概就是 TCC 的第一阶段。

## 3.4 TCC如何保证最终一致性

- TCC 事务机制以 Try 为中心的，Confirm 确认操作和 Cancel 取消操作都是围绕 Try 而展开。因此，Try 阶段中的操作，其保障性是最好的，即使失败，仍然有 Cancel 取消操作可以将其执行结果撤销。
- Try 阶段执行成功并开始执行 Confirm 阶段时，默认 Confirm 阶段是不会出错的，也就是说只要 Try 成功，Confirm 一定成功（TCC设计之初的定义）。
- Confirm 与 Cancel 如果失败，由TCC框架进行重试补偿。
- 存在极低概率在CC环节彻底失败，则需要定时任务或人工介入。

## 3.5 TCC的注意事项

**1. 允许空回滚**

空回滚出现的原因是 Try 超时或者丢包，导致 TCC 分布式事务二阶段的回滚，触发 Cancel 操作，此时事务参与者未收到Try，但是却收到了Cancel 请求，如下图所示：

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313200142.png)

所以 cancel 接口在实现时需要允许空回滚，也就是 Cancel 执行时如果发现没有对应的事务 xid 或主键时，需要返回回滚成功，让事务服务管理器认为已回滚。

**2. 防悬挂控制**

悬挂指的是二阶段的 Cancel 比 一阶段的Try 操作先执行，出现该问题的原因是 Try 由于网络拥堵而超时，导致事务管理器生成回滚，触发 Cancel 接口，但之后拥堵在网络的 Try 操作又被资源管理器收到了，但是 Cancel 比 Try 先到。但按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，所以此时应该拒绝执行空回滚之后到来的 Try 操作，否则会产生数据不一致。因此我们可以在 Cancel 空回滚返回成功之前，先记录该条事务 xid 或业务主键，标识这条记录已经回滚过，Try 接口执行前先检查这条事务xid或业务主键是否已经标记为回滚成功，如果是则不执行 Try 的业务操作。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313200317.png)

**3. 幂等控制**

由于网络原因或者重试操作都有可能导致 Try - Confirm - Cancel 3个操作的重复执行，所以使用 TCC 时需要注意这三个操作的幂等控制，通常我们可以使用事务 xid 或业务主键判重来控制。

## 3.6 TCC方案的优缺点

TCC 事务机制相比于上面介绍的 XA 事务机制，有以下优缺点：

[[#^dd1f05|什么是XA协议？]]

**优点：**

性能提升：具体业务来实现，控制资源锁的粒度变小，不会锁定整个资源。
数据最终一致性：基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。
可靠性：解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。

**缺点：**

TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。

## 3.7 TTC例子

拿用户下单购买礼物作为例子来模拟 TCC 实现分布式事务的过程： 假设用户 A 余额为 100 金币，拥有的礼物为 5 朵。A 花了 10 个金币，下订单，

购买 10 朵玫瑰。余额、订单、礼物都在不同数据库。

**TTC 的 Try 阶段：**

- 生成一条订单记录，订单状态为待确认
- 将用户 A 的账户金币中余额更新为 90，冻结金币为 10（预留业务资源）
- 将用户的礼物数量为 5，预增加数量为 10
- Try 成功之后，便进入 Confirm 阶段
- Try 过程发生任何异常，均进入 Cancel 阶段

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230529232012.png)

**TCC 的 Confirm 阶段：**

- 订单状态更新为已支付
- 更新用户余额为90，可冻结为0
- 用户礼物数量更新为15，预增加为0
- Confirm 过程发生任何异常，均进入 Cancel 阶段 Confirm 过程执行成功，则该事务结束

![](https://raw.githubusercontent.com/michik0/notes-image/master/20230529232101.png)

**TCC 的 Cancel 阶段：**

- 修改订单状态为已取消
- 更新用户余额回 100
- 更新用户礼物数量为 5

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230529232216.png)

- TCC 的优点是可以自定义数据库操作的粒度，降低了锁冲突，可以提升性能 
- TCC 的缺点是应用侵入性强，需要根据网络、系统故障等不同失败原因实现不同的回滚策略，实现难度大，一般借助 TCC 开源框架，ByteTCC，TCCtransaction，Himly。

# 4 Saga事务

## 4.1 什么是Saga

Saga事务源于1987年普林斯顿大学的Hecto和Kenneth发表的如何处理 **long lived transaction（长活事务）** 论文，Saga事务核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。

## 4.2 处理流程

每个Saga事务由一系列**幂等**的**有序子事务**(sub-transaction) **Ti** 组成。每个Ti 都有对应的**幂等补偿动作** **Ci**，补偿动作用于撤销Ti造成的结果。和TCC相比，Saga没有“预留”动作，它的Ti就是直接提交到库。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313203758.png)

**事务正常执行完成**

T1, T2, T3, …, Tn，例如：扣减库存(T1)，创建订单(T2)，支付(T3)，依次有序完成整个事务。

**事务回滚**

T1, T2, …, Tj, Cj,…, C2, C1，其中0 < j < n，例如：扣减库存(T1)，创建订单(T2)，支付(T3，支付失败)，支付回滚(C3)，订单回滚(C2)，恢复库存(C1)。

## 4.3 Saga恢复策略

**向前恢复**

对应于上面第一种执行顺序，**适用于必须要成功的场景**，**发生失败进行重试**，执行顺序是类似于这样的：T1, T2, …, Tj(失败), Tj(重试),…, Tn，其中j是发生错误的子事务(sub-transaction)。该情况下不需要Ci。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313204008.png)

**向后恢复**

对应于上面提到的第二种执行顺序，其中j是发生错误的子事务(sub-transaction)，这种做法的效果是撤销掉之前所有成功的子事务，使得整个Saga的执行结果撤销。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313203951.png)

## 4.4 Saga事务两种不同的实现方式

### 命令协调

==中央协调器负责集中处理事件的决策和业务逻辑排序。==

中央协调器（Orchestrator，简称OSO）以命令/回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313204152.png)

中央协调器必须事先知道执行整个订单事务所需的流程(例如通过读取配置)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。

基于中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。

### 事件编排

==没有中央协调器（没有单点风险）时，每个服务产生并观察其他服务的事件，并决定是否应采取行动。==

在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。

当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何Saga参与者听到都意味着事务结束。或者发布事件给主逻辑进行后续处理。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313204506.png)

### 命令协调 & 事件编排的优缺点

**命令协调的优缺点**

优点如下：
1. 服务之间关系简单，避免服务之间的循环依赖关系，因为Saga协调器会调用Saga参与者，但参与者不会调用协调器。
2. 程序开发简单，只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。
3. 易维护扩展，在添加新步骤时，事务复杂性保持线性，回滚更容易管理，更容易实施和测试。

缺点如下：
1. 中央协调器容易处理逻辑容易过于复杂，导致难以维护。
2. 存在协调器单点故障风险。

**事件编排的优缺点**

优点如下：
1. ==避免中央协调器单点故障风险。==
2. 当涉及的步骤较少服务开发简单，容易实现。

缺点如下：
1. 服务之间存在==循环依赖==的风险。
2. 当涉及的步骤较多，==服务间关系混乱==，难以追踪调测。

# 5 本地消息表

## 5.1 什么是本地消息表

本地消息表的核心思路就是将分布式事务拆分成本地事务进行处理，在该方案中主要有两种角色：事务主动方和事务被动方。

事务主动发起方需要额外新建事务消息表，并在本地事务中完成业务处理和记录事务消息，并轮询事务消息表的数据发送事务消息。

事务被动方基于消息中间件消费事务消息表中的事务。

## 5.2 本地消息表执行流程

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313211045.png)

1. 事务主动方在同一个本地事务中处理业务和写消息表操作。
2. 事务主动方通过消息中间件，通知事务被动方处理事务消息。消息中间件可以基于 Kafka、RocketMQ 消息队列，事务主动方主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。
3. 事务被动方通过消息中间件，通知事务主动方事务已处理的消息。
4. 事务主动方接收中间件的消息，更新消息表的状态为已处理。

**为了保证数据的一致性，当处理错误需要重试，事务发送方和事务接收方相关业务处理需要支持幂等需要以下容错处理：**

1. 当①处理出错，由于还在事务主动方的本地事务中，直接回滚即可
2. 当②、③处理出错，由于事务主动方本地保存了消息，只需要轮询消息重新通过消息中间件发送，通知事务被动方重新读取消息处理业务即可。
3. 如果是业务上处理失败，事务被动方可以发消息给事务主动方回滚事务
4. 如果事务被动方已经消费了消息，事务主动方需要回滚事务的话，需要发消息通知事务被动方进行回滚事务。

生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。

## 本地消息表的优缺点

**优点：**

- 从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。
- 方案轻量，容易实现。

**缺点：**

- 与具体的业务场景绑定，耦合性强，不可公用
- 消息数据与业务数据同库，占用业务系统资源
- 业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限

# 6 最大努力通知（非可靠消息，定期校对）

## 6.1 什么事最大努力通知？

最大努力通知也是一种分布式事务解决方案。下面是企业网银转账一个例子：

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230530135857.png)

- 企业网银系统调用前置接口，跳转到转账页
- 企业网银调用转账系统接口
- 转账系统完成转账处理，向企业网银系统发起转账结果通知，若通知失败，则转账系统按策略进行重复通知。
- 企业网银系统未接收到通知，会主动调用转账系统的接口查询转账结果。
- 转账系统会遇到退汇等情况，会定时回来对账。

最大努力通知方案的目标，就是**发起通知方通过一定的机制，最大努力将业务处理结果通知到接收方**。最大努力通知实现机制如下：

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230530140027.png)

#### 最大努力通知解决方案

要实现最大努力通知，可以采用 MQ 的 ACK 机制。

**方案**

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230530140137.png)

1. 发起方将通知发给MQ。
2. 接收通知方监听MQ消息。
3. 接收通知方收到消息后，处理完业务，回应ack。
4. 接收通知方若没有回应ACK，则MQ会间隔1min、5min、10min等重复通知。
5. 接受通知方可用消息校对接口，保证消息的一致性。

转账业务实现流程图：

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230530140226.png)

交互流程如下：

1. 用户请求转账系统进行转账。
2. 转账系统完成转账，将转账结果发给MQ。
3. 企业网银系统监听MQ，接收转账结果通知，如果接收不到消息，MQ会重复发送通知。接收到转账结果，更新转账状态。
4. 企业网银系统也可以主动查询转账系统的转账结果查询接口，更新转账状态。

# 7 个个方案使用场景总结

**2PC/3PC：**

依赖于数据库，能够很好的提供强一致性和强事务性，但延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。

**TCC：**

适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。

**本地消息表**：

适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。

**Saga 事务：**

由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。Saga 由于缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。所以，Saga 事务较适用于补偿动作容易处理的场景。

# 附录

## XA协议

^dd1f05

什么是XA 协议，XA是一种两阶段提交协议，很多数据库和事务监视器都支持，它通过协调访问多个关系数据库的单个事务来确保数据完整性。XA保证在所有参与的数据库中提交事务更新，或者从所有数据库中完全回滚，恢复到事务开始之前的状态。

为了参与XA事务，XA资源必须让事务管理器知道其自身。一旦登记了XA资源，事务管理器将确保XA资源参与事务，并在事务的生存期内对XA资源进行适当的方法调用。要完成XA事务，所有资源管理器都参与一个两阶段提交(2PC)。XA事务中的提交称为两阶段提交，因为在提交过程中有两次传递。

在第一轮中，事务管理器询问每个资源管理器是否在提交事务时遇到任何问题。如果任何资源管理器反对提交事务，则任何一方对XA事务中涉及的任何资源所做的所有工作都必须全部回滚。

事务管理器对每个已征募的XA资源调用rollback()方法。如果没有资源管理器反对提交，那么第二轮将涉及事务管理器对每个已征募的XA资源实际调用commit()。这个过程保证了可以跨多个资源的事务的ACID(原子性、一致性、隔离性和持久性)属性。

