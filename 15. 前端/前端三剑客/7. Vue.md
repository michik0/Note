>官网：https://cn.vuejs.org/
# 1 Vue 快速上手
## 1.1 Vue 是什么

概念：Vue是一个用于 **构建用户界面** 的 **渐进式** **框架**

### 1.1.1 构建用户页面

Vue 能够基于数据动态渲染页面

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906084228.png)

### 1.1.2 渐进式

Vue 有包括很多插件，但是核心包可以进行局部模块的改造

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906083913.png)

Vue 的两种使用方式：

1. Vue核心包开发，场景：**局部**模块改造
2. Vue核心包&Vue插件工程化开发，场景：**整站**开发

### 1.1.3 框架

框架是一套完整的项目解决方案，可以提升开发效率

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906084702.png)

## 1.2 创建实例

核心步骤：

1. 准备容器
2. 引包（官网）- 开发版本/生产版本
3. 创建Vue实例new Vue()
4. 指定配置项→渲染数据
	1. el 指定挂载点
	2. data 提供数据

```html
<div id="app">  
    <!-- 编写用于渲染的代码逻辑  -->  
    {{ msg }}  
</div>  
  
<!-- 引入的是开发版本包~包含完整的注释和警告 -->  
<script src="https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js"></script>  
  
<script>  
    // 一旦引入了 VueJS 核心包，在全局环境下，就有了 Vue 构造函数  
    const app = new Vue({  
        // 通过 el 配置选择起，指定 Vue 管理的是那个盒子  
        el: '#app',  
        // 通过 data 可以提供渲染的数据  
        data: {  
            msg: 'Hello Michiko'  
        }  
    })  
</script> 
```

## 1.3 插值表达式

插值表达式是一种 Vue 的模板语法

### 1.3.1 作用

利用表达式进行插值，渲染到页面中

### 1.3.2 语法：{{ 表达式 }}

```html
<h3>{{ tit1e }}</h3>
<p>{{ nickname.toUppercase() }}</p>
<p>{{ age >= 18 ? '成年' : '未成年' }}</p>
<p>{{ obj.name }}</p>
```

### 1.3.3 注意

1. 使用的数据必须在 data 中被定义

2. 支持的是表达式，而非语句，所以不支持 if，for ... 

```html
<p>{{ if }}</p>
```

3. 不能在标签属性中使用 `{{ }}` 插值

```html
<p title="{{ username }}">p标签</p>
```

## 1.4 Vue 核心特性：响应式

除了基本的模板渲染，Vue 背后还做了大量工作，比如说数据的响应式处理

数据的响应式处理→响应式：**数据变化，视图自动更新**

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906095133.png)

使用Vue开发，关注业务的核心逻辑，根据业务修改数据即可

data中的数据，最终会被添加到实例上，我们可以通过 `实例.属性名` 来获取数据，通过 `实例.属性名 = 值` 来修改属性

```js
const app = new Vue({  
    el: '#app',  
    data: {  
        msg: 'Hey!'  
    }  
})  
// 两秒后，属性被修改成 Hi!
setTimeout(() => {  
    app.msg = 'Hi!'  
}, 2000)
```

## 1.5 Vue 指令

Vue会根据不同的 **指令**，针对标签实现不同的 **功能**。

指令：带有 `v-前缀` 的特殊 `标签属性`

### 1.5.1 v-html

`v-html` 可以更新元素的 `innerHTML`。

```html
<div v-html="str"></div>
```

### 1.5.2 v-show 与 v-if

#### v-show

##### 作用

`v-show` 用来控制元素显示隐藏

##### 语法

```html
<!-- 表达式值true显示，false隐藏 -->
v-show="表达式"
```

`v-show` 通过切换 css 的 `display:none` 来控制显示隐藏

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906102017.png)

##### 使用场景

频繁切换显示隐藏的场景

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906102207.png)

#### v-if

##### 作用

`v-if` 用来控制元素显示隐藏（条件渲染）

##### 语法

```html
<!-- 表达式值true显示，false隐藏 -->
v-if="表达式"
```

##### 原理

基于条件判断，进行创建或移除元素节点

##### 场景

要么显示，要么隐藏，不频繁切换的场景

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906102232.png)

### 1.5.3 v-else 与 v-else-if

#### 作用

辅助 `v-if` 进行判断渲染，注意：**需要紧挨着 `v-if` 一起使用**

#### 语法

```html
v-if="表达式"
v-else-if="表达式"
v-else
```

```html
<p v-if="gender === 1">性别：♂ 男</p>  
<p v-else>性别：♀ 女</p>  
<hr>  
<p v-if="score > 90">成绩评定A：奖励电脑一台</p>  
<p v-else-if="score > 70 && score <= 90">成绩评定B：奖励周末郊游</p>  
<p v-else-if="score > 60 && score <= 70">成绩评定C：奖励零食礼包</p>  
<p v-else>成绩评定D：惩罚一周不能玩手机</p>
```

### 1.5.4 v-on

#### 作用

为元素注册事件

注册事件 = 添加监听 + 提供处理逻辑

#### 语法

##### 语法一

```html
v-on:事件名="内联语句"
```

```html
<button v-on:click="count--">-</button>  
<span>{{ count }}</span>  
<button v-on:click="count++">+</button>  
```

##### 语法二

```html
v-on:事件名="methods中的函数名"
```

```html
<div id="app">  
  <button v-on:click="changeShow">切换显示隐藏</button>  
  <h1 v-show="show" >黑马程序员</h1>  
</div>  
```

```js
const app = new Vue({  
	el: '#app',  
	data: {  
	  show: true  
	},  
	// 方法
	methods: {  
	  // 提供处理逻辑函数  
	  changeShow() {  
	    // this 指向当前实例
		this.show = !this.show  
	  }  
	}  
})  
```

##### 简写

`v-on:` 可以替换为 `@`，即 `v-on:click` 可以简写为 `@click`

#### 调用传参

当 v-on 提供的处理逻辑为函数时，可以进行调用传参，即：

```html
<button v-on:click="fn(参数1, 参数2)"></button>
```

```js
const app = new Vue({
	el: '#app',
	methods: {
		fn(a, b) {
			console.log(a, b)
		}
	}
})
``` 

### 1.5.5 v-bind

#### 作用

动态地设置 html 的**标签属性** → src，url，title 等

#### 语法

```html
v-bind:属性名="表达式"
```

```js
<img v-bind:src="imgUrl">
```

#### 简写

`v-bind` 可以进行简写，`v-bind:属性名` 可以简写为 `:属性名`，即 `v-bind:src` 等价于 `:src`

### 1.5.6 v-for

#### 作用

基于**数据**循环，**多次渲染**整个元素

`v-for` 可以遍历数组，对象，数字等

#### 语法

```html
<!--  index 可省略 -->
v-for="(item[, index]) in 数组"
```

```html
<ul>  
  <li v-for="(item, index) in list">{{ index + 1 }} - {{ item }}</li>  
</ul>
```

#### v-for 中的 key

##### 为什么需要 key？

1. 下面，我们使用了 `v-for` 渲染出4本，并且第一本的背景色为粉色

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906163106.png)

2. 现在删除第一本书，发现背景色还在

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906163226.png)

分析原因：是因为 `v-for` 的默认行为会尝试原地修改元素（就地复用），只是把文字给做了修改，但是样式却还在

解决办法：使用 `key`

##### 作用

`v-for` 中的 `key` 给列表项添加的**唯一标识**，便于 Vue 进行列表项的**正确排序复用**。

##### 语法

```html
:key属性="唯一标识"
```

##### 注意点

1. key的值只能是**字符串或数字类型**
2. key的值必须具有**唯一性**
3. 推荐使用 id 作为 key(唯一)，不推荐使用 index 作为 key（会变化，不对应）

### 1.5.7 v-model

#### 作用

`v-model` 可以给**表单元素**使用，

**双向数据绑定** → 可以快速**获取或设置**表单元素内容

- 数据变化 -> 表单自动更新
- 表单变化 -> 数据自动更新

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906164615.png)

#### 语法

```html
v-model="变量"
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906164902.png)

## 1.6 指令修饰符

通过 `.` 指明一些指令后缀，不同后缀封装了不同的处理操作，可以大幅简化代码

### 1.6.1 按键修饰符

#### `@keyup.enter`：监听键盘回车时间

```html
<input @keyup.enter="fn" v-model="username" type="text">
```

### 1.6.2 v-model 修饰符

#### `v-model.trim`：去除首尾空格

```html
姓名：<input v-model.trim="username" type="text"><br>  
```

#### `v-model.number`：转数字

```html
年纪：<input v-model.number="age" type="text"><br>
```

### 1.6.3 事件修饰符

#### `事件名.stop`：阻止冒泡

```html
<div @click="fatherFn" class="father">  
  <div @click.stop="sonFn" class="son">儿子</div>  
</div>
```

#### `事件名.prevent`：阻止默认行为

```html
<a @click.prevent href="http://www.baidu.com">阻止默认行为</a>
```

## 1.7 v-bind 样式控制的增强

为了方便开发者进行**样式控制**，Vue 扩展了 v-bind 的语法，可以针对 **class类名** 和 **style行内样式** 进行控制。

### 1.7.1 操作 class

#### 语法

```html
:class="对象/数组"
```

##### 对象

键就是类名，值是布尔值。如果值为true，有这个类，否则没有这个类

```html
<div class="box" :class="{ 类名1: 布尔值, 类名2: 布尔值 }"></div>
```

```html
<div class="box" :class="{ pink: true, big: true }">michiko</div>
```

##### 数组

数组中的所有类，都回添加到盒子上。本质上就是一个 class 列表

```html
<div class="box" :class="[ 类名1, 类名2, 类名3 ]"></div>
```

```html
<div class="box" :class="['pink', 'big']">michiko</div>
```

### 1.7.2 操作 style

#### 语法

```html
:style="样式对象"
```

```html
<div class="box" :style="{ CSS属性名1: CSS属性值, CSS属性名2: CSS属性值 }"></div>
```

```html
<div class="box" :style="{ width: '400px', backgroundColor: 'pink ' }"></div>
```

#### 使用场景

某个具体属性的动态设置，比如说进度条

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906193932.png)

## 1.8 v-model 应用于其他表单元素

常见的表单元素都可以用 `v-model` 绑定关联，快速获取或设置表单元素的值

`v-model` 会根据控件类型自动选取正确的方法来更新元素

>输入框

input:text -> value

>文本域

textarea -> value

>复选框

input:checkbox -> checked

>单选框

input:radio -> checked

>下拉菜单

select -> value

## 1.9 计算属性

### 1.9.1 概念

基于现有的数据，计算出来的新属性。依赖的数据变化，自动重新计算。

### 1.9.2 语法

- 声明在 `computed` 配置项中，一个计算属性对应一个函数
- 使用起来和普通属性一样使用 `{{ 计算属性名 }}`

```js
computed: {
	计算属性名 () {
		// 基于现有数据，编写求值逻辑
		return 结果
	}
}
```

### 1.9.3 应用

```html
总数：{{ totalGiftNum }} 个
```

```js
computed: {  
  totalGiftNum() {  
	// 求得总数
    return this.list.reduce((sum, curVal) => sum + curVal.num, 0)  
  }  
}
```

### 1.9.4 computed 计算属性 与 methods 方法

#### computed 计算属性

作用：封装了一段对于数据的处理，求得一个结果。

缓存特性：计算属性会对计算出来的**结果缓存**，再次使用**直接读取缓存**，**依赖项变化了，会自动重新计算，并再次缓存**

#### methods 方法

作用：给实例提供一个方法，调用以处理业务逻辑。

### 1.9.5 计算属性完整写法

计算属性**默认的简写**，只能读取访问，不能”修改"。

```js
computed: {
	计算属性名: {
		get() {
			// 基于现有数据，编写求值逻辑
			return 结果
		},
		set(修改的值) {
			// 基于现有数据，编写修改逻辑
		}
	}
}
```

```html
姓：<input v-model="firstName" type="text"><br>  
名：<input v-model="lastName" type="text"><br>  
<p>姓名：{{ fullName }}</p>  
<button @click="fullName = 'M多多'">修改姓名</button>
```

```js
computed: {  
  fullName: {  
    get() {  
      return this.firstName + this.lastName  
    },  
    set(newName) {  
      this.firstName = newName.substring(0, 1)  
      this.lastName = newName.substring(1)  
    }  
  }  
}
```

## 1.10 watch 监听器（监视器）

### 1.10.1 作用

`watch` 可以监视数据变化，执行一些业务逻辑或异步操作。

### 1.10.2 语法

```js
data: {
	words: '苹果',
	obj: {
		words: '苹果'
	}
},
watch: {
	// 该方法会在数据变化时，触发执行
	数据属性名 (newValue, oldValue) {
		// 业务逻辑 或 异步操作
	}
	'对象.属性名' (newValue, oldValue) {
		// 业务逻辑 或 异步操作
	}
}
```

### 1.10.3 应用

```js
const app = new Vue({  
  el: '#app',  
  data: {  
    words: '',  
    wordsAfterTranslate: '',  
    lang: 'italy'  
  },  
  watch: {  
    words (newVal, oldVal) {  
      this.translate(newVal, this.lang)  
    },  
    lang (newVal, oldVal) {  
      this.translate(this.words, newVal)  
    }  
  },  
  methods: {  
    translate(words, lang) {  
      axios({  
        url: 'https://applet-base-api-t.itheima.net/api/translate',  
        method: '',  
        params: { words, lang },  
      }).then(result => {  
        this.wordsAfterTranslate = result.data.data  
      })  
    }  
  }  
})
```

### 1.10.4 完整写法

当我们需要有多个对象监控时，我们通常会把这些对象丢到一个对象里面进行深度监视

watch 属性有额外配置：

- `deep`：是否开启深度监视
- `immediate`：页面加载后是否立即执行一次 handler 处理方法

```js
data: {
	obj: {
		words: '苹果',
		lang: 'english'
	}
},
watch: {
	// 该方法会在数据变化时，触发执行
	数据属性名: {
		// 深度监视
		deep: true,
		// 页面加载后是否立即执行一次 handler 处理方法
		immediate: true,
		// 监视属性发现变动后执行的操作
		handler (newVal) {
			// 业务逻辑 或 异步操作
		}
	}
}
```

```js
const app = new Vue({  
  el: '#app',  
  data: {  
    obj: {  
      words: '欢迎使用本翻译软件',  
      lang: 'italy'  
    },  
    wordsAfterTranslate: '',  
  },  
  watch: {  
    obj: {  
	  // 深度监视
      deep: true,  
      // 一进页面立刻执行 handler
      immediate: true,  
      handler (newVal) {  
        axios({  
          url: 'https://applet-base-api-t.itheima.net/api/translate',  
          method: '',  
          params: { words: newVal.words, lang: newVal.lang },  
        }).then(result => {  
          this.wordsAfterTranslate = result.data.data  
        })  
      }  
    }  
  }  
})
```

## 1.11 Vue 生命周期

生命周期：一个 Vue 实例从创建到销毁的整个过程。

生命周期四个阶段：

- 创建
- 挂载
- 更新
- 销毁

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230907225419.png)

### 1.11.1 Vue 生命周期函数（钩子函数）

Vue 生命周期过程中，会**自动运行一些函数**，被称为 **生命周期钩子** ，以便开发者可以在 **特定阶段** 运行**自己的代码**。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230907230216.png)

```js
// 创建阶段（准备数据）  
beforeCreate() {  
  console.log('beforeCreate 响应式数据准备好前')  
},  
created() {  
  // 可以处理业务逻辑，以及发起异步请求  
  console.log('created 响应式数据准备好后')  
},  
// 挂载阶段（渲染模板）  
beforeMount() {  
  console.log('beforeMount 模板渲染前')  
},  
mounted() {  
  // 可以操作 DOM 了  
  console.log('mounted 模板渲染后')  
},  
// 更新阶段（修改数据 -> 更新视图）  
beforeUpdate() {  
  console.log('beforeUpdate', document.querySelector('span').innerHTML)  
},  
updated() {  
  console.log('updated', document.querySelector('span').innerHTML)  
},  
// 卸载阶段  
beforeDestroy() {  
  // 清除掉一些Vue意外的资源占用，定时器，延时器  
  console.log('beforeDestroy')  
},  
destroyed() {  
  console.log('destroyed')  
}
```

# 2 工程化开发 & 脚手架 Vue CLI

开发Vue的两种方式:

1. 核心包传统开发模式：基于 html/css/js 文件，直接引入核心包，开发Vue。
2. 工程化开发模式：**基于构建工具（例如：webpack）的环境中开发Vue。**

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908105308.png)

>问题

- webpack 配置**不简单**
- **雷同**的基础配置
- **缺乏统一标准**

## 2.1 定义

`Vue CLI` 是 Vue 官方提供的一个全局命令工具，可以帮助我们快速创建一个开发Vue项目的标准化基础架子，**集成了webpack配置**

## 2.2 好处

1. 开箱即用，零配置
2. 内置 babel 等工具
3. 标准化

## 2.3 搭建步骤

1. 全局安装（一次）：`yarn global add @vue/cli` 或 `npmi @vue/cli -g`
2. 查看 Vue 版本：`vue --version`
3. 创建项目架子：`vue create project-name`
4. 启动项目（package.json目录下）：`yarn serve` 或 `npm run serve`

## 2.4 脚手架目录文件介绍 & 项目运行流程

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908113154.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908114352.png)

# 3 组件化开发

## 3.1 组件化

组件化：一个页面可以拆分成一个个组件，**每个组件有着自己独立的结构、样式、行为。**

便于维护，利于复用，提升效率。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908114701.png)

## 3.2 根组件

组件分类：普通组件，根组件

**根组件**：整个应用最上层的组件，包裹所有普通小组件。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908115904.png)

## 3.3 单文件组件的三个组成部分

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908134509.png)

- template：结构（Vue2中有且只能一个根元素）
- script：Js 逻辑
- style：样式（可支持 less 语法，需要装包）

>让组件支持 less

- `<style lang="less">` 开启 less 功能
- 装包：`yarn add less less-loader`

## 3.4 普通组件的注册使用

组件注册的两种方式：

1. 局部注册：只能在注册的组件内使用
2. 全局注册：所有组件内都能使用

### 3.4.1 局部注册

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908163851.png)

##### 1. 创建 Vue 文件

>组件名规范使用**大驼峰命名法**，如：`MyHeader.vue`

```vue
<template>  
  <div id="myHeader" class="my-header">  
    我是头部组件  
  </div>  
</template>  
  
<script>  
export default {  
  
}  
</script>  
  
<style lang="less">  
  .my-header {  
    height: 100px;  
    line-height: 100px;  
    text-align: center;  
    font-size: 30px;  
    background-color: #8064a2;  
    color: white;  
  }  
  
</style>
```

##### 2. 在使用的组件中进行注册其他组件

```vue
<script>  
import 组件名 from "vue文件路径";  

export default {  
  components: {  
	'组件名': '组件对象'  
  }  
}  
</script>
```

##### 3. 在使用的组件中使用其他组件

```html
<template>
	<组件名></组件名>
</template>
```

### 3.4.2 全局注册

##### 1. 创建 Vue 文件

>组件名规范使用**大驼峰命名法**，如：`MyBtn.vue`

```js
<template>  

</template>  
  
<script>  

</script>  
  
<style lang="less">  
  
</style>
```

##### 2. **main.js** 中进行全局注册

```js
import 组件名 from "组件路径";  

Vue.component('组件名', 组件名)  
```

##### 3. 使用

```html
<组件名></组件名>
```

## 3.5 组件的样式冲突

写在组件中的样式会**全局生效**，因此很容易造成多个组件之间的样式冲突问题。

为了防止样式冲突，我们可以给组件的 `<style>` 加上 `scoped` 属性，可以让**样式只作用于当前组件**

>scoped 原理

1. 当前组件内标签都被添加 `data-v-hash` 值的属性
2. css 选择器都被添加 `data-v-hash` 的属性选择器

最终效果：必须是当前组件的元素，才会有这个自定义属性，才会被这个样式作用到

## 3.6 data 函数

组件的 data 选项必须是一个函数，保证每个组件实例，维护独立的一份数据对象。

```js
export default {  
  data() {  
    return {  
      count: 100,  
    }  
  },  
}
```

三个一样的组件，其 `data` 不一样，每个**组件实例**，维护独立的一份数据对象。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909093620.png)

## 3.7 组件通信

组件通信，就是指组件与组件之间的数据传递。由于组件的数据是独立的，无法直接访问其他组件的数据。所以想用其他组件的数据就需要组件通信

### 3.7.1 组件关系

组件关系分类：

1. 父子关系
2. 非父子关系

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909093952.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909093944.png)

### 3.7.2 通信解决方案

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909094054.png)

### 3.7.3 父子通信流程图

1. 父组件通过 `props` 将数据传递给子组件
2. 子组件利用 `$emit` 通知父组件修改更新

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909094302.png)

#### 父 -> 子

1. 父组件通过 `:参数名` 将参数传递给子组件
2. 子组件通过定义 `props` 来进行参数的接收
3. 像平常属性一样使用 `{{}}` 进行参数的使用

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909095124.png)

#### 子 -> 父

子组件无法直接修改修改父组件中的数据，子组件只能通知父组件进行修改

1. 子组件通过 `this.$emit('事件名', '参数')`
2. 父组件中添加消息监听 `@事件名="处理函数"`
3. 父组件中事先处理函数

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909100423.png)


### 3.7.4 非父子通信 - event bus 时间总线

`event bus` 可以在非父子组件之间，进行简易消息传递。

复杂场景：**使用 Vuex**
#### 步骤

1. 创建一个都能访问到的事件总线（空Vue实例，`utils/EventBus.js`）

```js
import Vue from 'vue'
const Bus = new Vue()
export default Bus
```

2. A组件（接收方），监听 Bus 实例的事件

```js
created() {
	Bus.$on('sendMsg', (msg) => {
		this.msg = msg
	})
}
```

3. B组件（发送方），触发 Bus 实例的事件

```js
Bus.$emit('sendMsg', '这是一个消息')
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909164012.png)

### 3.7.5 非父子通信 - provide & inject

provide & inject 作用：**跨层级**共享数据，子孙后代也可以进行取值使用

#### 步骤

1. 父组件 provide 提供数据

```js
export default {
	provide() {
		return {
			// 普通类型【非响应式】
			color: this.color,
			// 复杂类型【响应式】
			userInfo: this.useInfo
		}
	}
}
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909172312.png)

2. 子/孙组件 inject 取值使用

```js
export default {
	inject: ['color', 'userInfo']
	created() {
		console.log(this.color, this.userInfo)
	}
}
```

## 3.8 什么是 Prop ？

### 3.8.1 定义

Prop 是组件上注册的一些 `自定义属性`

### 3.8.2 作用

Prop 可以向子组件传递数据

### 3.8.3 特点

可以传递 **任意数量** 的 prop
可以传递 **任意类型** 的 prop

>父组件

```js
data() {  
  return {  
    username: '小帅',  
    age: 28,  
    isSingle: true,  
    car: {  
      brand: '宝马',  
    },  
    hobby: ['篮球', '足球', '羽毛球'],  
  }  
}
```

```html
<UserInfo  
    :username="username"  
    :age="age"  
    :isSingle="isSingle"  
    :car="car"  
    :hobby="hobby"  
></UserInfo>
```

>子组件

```js
props: [  
    'username',  
    'age',  
    'isSingle',  
    'car',  
    'hobby'  
]
```

```html
<div class="userinfo">  
  <h3>我是个人信息组件</h3>  
  <div>姓名：{{ username }}</div>  
  <div>年龄：{{ age }}</div>  
  <div>是否单身：{{ isSingle ? '是' : '否' }}</div>  
  <div>座驾：{{ car.brand }}</div>  
  <div>兴趣爱好：{{ hobby.join('，') }}</div>  
</div>
```

### 3.8.4 props 校验

开发者可以为组件的 props 指定验证要求，不符合要求，控制台就会有错误提示，以便帮助开发者，快速发现错误

#### 校验类型

- 类型校验
- 非空校验
- 默认值
- 自定义校验

#### 类型校验

```js
props: {
	// 类型可为 Number String Boolean 等等
	校验的属性名: 类型
}
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909102528.png)

#### 非空校验 / 默认值 / 自定义校验

```js
props: {  
  w: {  
	// Number String Boolean 等等
    type: Number,  
    // 是否必填
    required: true,  
    // 默认值
    default: 默认值,  
    // 自定义校验逻辑
    validator(value) {  
      return 是否通过校验  
    }  
  }  
}
```

```js
props: {  
  w: {  
    type: Number,  
    // required: true,  
    default: 0,  
    validator(value) {  
      // 自定义校验逻辑  
      if (value >= 0 && value <= 100) {  
        return true  
      }  
      else {  
        console.error('prop 必须 0～100')  
        return false  
      }  
    }  
  }
}
```

### 3.8.5 prop 与 data

#### 共同点

prop 与 data 都可以给组件提供数据

#### 区别

- data 的数据属于各自组件，可以**随意修改**
- prop 的数据是外部的，**不能直接改**，遵循[[#^1faf98|单向数据流]]

>单向数据流

^1faf98

父组件的 props 更新，会单向向下流动，影响子组件

prop 如果想要修改，需要使用 `this.$emit()` 通知父组件进行修改

## 3.9 vue-model 原理

### 3.9.1 原理

`v-model` 本质上是一个语法糖。例如应用在**输入框**上，就是 `value 属性` 和 `input事件` 的合写。 

`v-model` 用于在不同的控件上，属性和事件可能会有些区别，比如 `v-model` 如果作用于复选框上，那么底层就是 `checked属性` 与 `change事件` 的合写
### 3.9.2 作用

`v-model` 提供数据的双向绑定

```html
<input v-model="msg" type="text>
```

等价于

```html
<!-- $event 用于在模板中，获取事件的形参 -->
<!-- :value 可以将 msg 属性值显示在 input 框中 -->
<!-- @input 可以获取 input 事件，并且将 input 值赋值给 msg -->
<input :value="msg" @input="msg = $event.target.value" type="text>
```

### 3.9.3 表单类组件封装 & v-model 简化代码

#### 表单类组件封装

1. 父传子：数据应该是父组件 `props` 传递过来的，`v-model` 拆解绑定数据

```html
<BaseSelect  
    :cityId="selectId"  
    @changeId="handleChangeId"  
></BaseSelect>
```

2. 子传父：监听输入，子传父传值给父组件修改

```html
<select :value="cityId" @change="handleChange">  
  <option value="101">北京</option>  
  <option value="102">上海</option>  
  <option value="103">武汉</option>  
  <option value="104">广州</option>  
  <option value="105">深圳</option>  
</select>
```

```js
props: {  
  cityId: String  
},  
methods: {  
  handleChange(e) {  
    this.$emit('changeId', e.target.value)  
  }  
}
```

#### v-model 简化代码

父组件使用 `v-model` 简化代码，实现子组件和父组件数据双向绑定

**注意**：例子里面是文本框，所以 `v-model` 等价于 `:value="xx" @change="xx"`，如果是多选框，则 `v-model` 等价于 `:checked="xx" @change="xx"` ，需要根据不同的控件来选择不同的属性和事件

1. 子组件中：`props` 通过 `value` 接收，事件触发 `input`

```html
<div>  
  <select :value="value" @change="handleChange">  
    <option value="101">北京</option>  
    <option value="102">上海</option>  
    <option value="103">武汉</option>  
    <option value="104">广州</option>  
    <option value="105">深圳</option>  
  </select>  
</div>
```

```js
props: {  
  value: String  
},  
methods: {  
  handleChange(e) {  
    this.$emit('input', e.target.value)  
  }  
}
```

2. 父组件中：`v-model` 给组件直接绑数据

```html
<div class="app">  
  <!-- 由于输入框环境下， v-model 等价于 :value="msg" @input="msg = $event.target.value"，所以直接写 v-model -->  <BaseSelect  
    v-model="selectId"  
  ></BaseSelect>  
</div>
```

## 3.10 .sync 修饰符

### 3.10.1 作用

`.sync` 可以实现**子组件与父组件数据的双向绑定**，简化代码

### 3.10.2 特点

`prop` 属性名，可以自定义，非固定值 `value` 或者固定值 `checked`

>关于为什么是固定值参考 [[#v-model 简化代码|v-model 简化代码]]

### 3.10.3 场景

封装弹框类的基础组件，使用 `props.visible` 属性，其中 true：显示，false：隐藏

### 3.10.4 语法

这里通过控制弹窗的显示与隐藏展示语法

#### 父组件

```html
<!-- visiable 为 prop 属性值 -->
<BaseDialog :visiable.sync="isShow"/>
```

等价于

```html
<BaseDialog 
	:visiable="isShow"
	@update:visiable="isShow = $event"
/>
```

#### 子组件

```js
props: {
	visiable: Boolean
}
```

```js
this.$emit('update:visiable', false)
```

## 3.11 ref 和 $refs

### 3.11.1 作用

利用 `ref` 和 `$refs` 可以用于获取**组件内的 DOM 元素**，或**组件实例**

**注意**：`document.querySelector('xxx')` 会检索出页面上第一个，而不是组件内

### 3.11.2 特点

`ref` 与 `$refs` 的查找范围为当前组件内（更精确稳定）

### 3.11.3 语法

#### 获取 DOM 元素

```html
<div ref="chartRef">我是渲染图的容器</div>
```

```js
mounted() {
	console.log(this.$refs["chartRef"])
}
```

#### 获取组件实例

```html
<BaseForm ref="baseForm"></BaseForm>
```

```js
this.$refs["baseForm"].组件方法()
```

## 3.12 Vue 异步更新机制 & $nextTick

### 3.12.1 问题出现

>思考：我们想要点 `编辑按钮` ，显示输入框，并且让输入框聚焦

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230910115703.png)

我们可能会写出以下代码：

```js
// 显示输入框
this.isShowEdit = true
// 获取焦点
this.$refs.inp.focus()
```

但是问题就出现了，控制台打印显示 `this.$refs.inp` 是 undefined，这是为什么？

原因：**Vue是异步更新 DOM（提升性能）**

### 问题解决：$nextTick

`$nextTick` 可以等DOM更新后，才会触发执行此方法里的函数体

```js
this.$nextTick(() => {
	this.$refs.inp.focus()
})
```

# 附录

## Tab栏切换高亮

```html
<!DOCTYPE html>  
<html lang="en">  
<head>  
  <meta charset="UTF-8">  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">  
  <title>Document</title>  
  <style>    * {  
      margin: 0;  
      padding: 0;  
    }  
    ul {  
      display: flex;  
      border-bottom: 2px solid #e01222;  
      padding: 0 10px;  
    }  
    li {  
      width: 100px;  
      height: 50px;  
      line-height: 50px;  
      list-style: none;  
      text-align: center;  
    }  
    li a {  
      display: block;  
      text-decoration: none;  
      font-weight: bold;  
      color: #333333;  
    }  
    li a.active {  
      background-color: #e01222;  
      color: #fff;  
    }  
  
  </style>  
</head>  
<body>  
  
  <div id="app">  
    <ul>  
      <li v-for="(item, index) in list" :key="item.id">  
        <a :class="{ active:  index === activeIndex}" href="#" @click="activeIndex = index">{{ item.name }}</a>  
      </li>  
    </ul>  
  </div>  
  <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>  
  <script>    const app = new Vue({  
      el: '#app',  
      data: {  
        // 记录高亮下标  
        activeIndex: 0,  
        list: [  
          { id: 1, name: '京东秒杀' },  
          { id: 2, name: '每日特价' },  
          { id: 3, name: '品类秒杀' }  
        ]  
      }  
    })  
  </script>  
</body>  
</html>
```