>官网：https://cn.vuejs.org/
# 1 Vue 快速上手
## 1.1 Vue 是什么

概念：Vue是一个用于 **构建用户界面** 的 **渐进式** **框架**

### 1.1.1 构建用户页面

Vue 能够基于数据动态渲染页面

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906084228.png)

### 1.1.2 渐进式

Vue 有包括很多插件，但是核心包可以进行局部模块的改造

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906083913.png)

Vue 的两种使用方式：

1. Vue核心包开发，场景：**局部**模块改造
2. Vue核心包&Vue插件工程化开发，场景：**整站**开发

### 1.1.3 框架

框架是一套完整的项目解决方案，可以提升开发效率

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906084702.png)

## 1.2 创建实例

核心步骤：

1. 准备容器
2. 引包（官网）- 开发版本/生产版本
3. 创建Vue实例new Vue()
4. 指定配置项→渲染数据
	1. el 指定挂载点
	2. data 提供数据

```html
<div id="app">  
    <!-- 编写用于渲染的代码逻辑  -->  
    {{ msg }}  
</div>  
  
<!-- 引入的是开发版本包~包含完整的注释和警告 -->  
<script src="https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js"></script>  
  
<script>  
    // 一旦引入了 VueJS 核心包，在全局环境下，就有了 Vue 构造函数  
    const app = new Vue({  
        // 通过 el 配置选择起，指定 Vue 管理的是那个盒子  
        el: '#app',  
        // 通过 data 可以提供渲染的数据  
        data: {  
            msg: 'Hello Michiko'  
        }  
    })  
</script> 
```

## 1.3 插值表达式

插值表达式是一种 Vue 的模板语法

### 1.3.1 作用

利用表达式进行插值，渲染到页面中

### 1.3.2 语法：{{ 表达式 }}

```html
<h3>{{ tit1e }}</h3>
<p>{{ nickname.toUppercase() }}</p>
<p>{{ age >= 18 ? '成年' : '未成年' }}</p>
<p>{{ obj.name }}</p>
```

### 1.3.3 注意

1. 使用的数据必须在 data 中被定义

2. 支持的是表达式，而非语句，所以不支持 if，for ... 

```html
<p>{{ if }}</p>
```

3. 不能在标签属性中使用 `{{ }}` 插值

```html
<p title="{{ username }}">p标签</p>
```

## 1.4 Vue 核心特性：响应式

除了基本的模板渲染，Vue 背后还做了大量工作，比如说数据的响应式处理

数据的响应式处理→响应式：**数据变化，视图自动更新**

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906095133.png)

使用Vue开发，关注业务的核心逻辑，根据业务修改数据即可

data中的数据，最终会被添加到实例上，我们可以通过 `实例.属性名` 来获取数据，通过 `实例.属性名 = 值` 来修改属性

```js
const app = new Vue({  
    el: '#app',  
    data: {  
        msg: 'Hey!'  
    }  
})  
// 两秒后，属性被修改成 Hi!
setTimeout(() => {  
    app.msg = 'Hi!'  
}, 2000)
```

# 2 Vue 指令

Vue会根据不同的 **指令**，针对标签实现不同的 **功能**。

指令：带有 `v-前缀` 的特殊 `标签属性`

## 2.1 v-html

`v-html` 可以更新元素的 `innerHTML`。

```html
<div v-html="str"></div>
```

## 2.2 v-show 与 v-if

### 2.2.1 v-show

#### 作用

`v-show` 用来控制元素显示隐藏

#### 语法

```html
<!-- 表达式值true显示，false隐藏 -->
v-show="表达式"
```

`v-show` 通过切换 css 的 `display:none` 来控制显示隐藏

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906102017.png)

#### 使用场景

频繁切换显示隐藏的场景

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906102207.png)

### 2.2.2 v-if

#### 作用

`v-if` 用来控制元素显示隐藏（条件渲染）

#### 语法

```html
<!-- 表达式值true显示，false隐藏 -->
v-if="表达式"
```

#### 原理

基于条件判断，进行创建或移除元素节点

#### 场景

要么显示，要么隐藏，不频繁切换的场景

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906102232.png)

## 2.3 v-else 与 v-else-if

### 2.3.1 作用

辅助 `v-if` 进行判断渲染，注意：**需要紧挨着 `v-if` 一起使用**

### 2.3.2 语法

```html
v-if="表达式"
v-else-if="表达式"
v-else
```

```html
<p v-if="gender === 1">性别：♂ 男</p>  
<p v-else>性别：♀ 女</p>  
<hr>  
<p v-if="score > 90">成绩评定A：奖励电脑一台</p>  
<p v-else-if="score > 70 && score <= 90">成绩评定B：奖励周末郊游</p>  
<p v-else-if="score > 60 && score <= 70">成绩评定C：奖励零食礼包</p>  
<p v-else>成绩评定D：惩罚一周不能玩手机</p>
```

## 2.4 v-on

### 2.4.1 作用

为元素注册事件

注册事件 = 添加监听 + 提供处理逻辑

### 2.4.2 语法

#### 语法一

```html
v-on:事件名="内联语句"
```

```html
<button v-on:click="count--">-</button>  
<span>{{ count }}</span>  
<button v-on:click="count++">+</button>  
```

#### 语法二

```html
v-on:事件名="methods中的函数名"
```

```html
<div id="app">  
  <button v-on:click="changeShow">切换显示隐藏</button>  
  <h1 v-show="show" >黑马程序员</h1>  
</div>  
```

```js
const app = new Vue({  
	el: '#app',  
	data: {  
	  show: true  
	},  
	// 方法
	methods: {  
	  // 提供处理逻辑函数  
	  changeShow() {  
	    // this 指向当前实例
		this.show = !this.show  
	  }  
	}  
})  
```

#### 简写

`v-on:` 可以替换为 `@`，即 `v-on:click` 可以简写为 `@click`

#### 调用传参

当 v-on 提供的处理逻辑为函数时，可以进行调用传参，即：

```html
<button v-on:click="fn(参数1, 参数2)"></button>
```

```js
const app = new Vue({
	el: '#app',
	methods: {
		fn(a, b) {
			console.log(a, b)
		}
	}
})
``` 

## 2.5 v-bind

### 2.5.1 作用

动态地设置 html 的**标签属性** → src，url，title 等

### 2.5.2 语法

```html
v-bind:属性名="表达式"
```

```js
<img v-bind:src="imgUrl">
```

### 2.5.3 简写

`v-bind` 可以进行简写，`v-bind:属性名` 可以简写为 `:属性名`，即 `v-bind:src` 等价于 `:src`

### 2.5.4 v-bind 样式控制的增强

为了方便开发者进行**样式控制**，Vue 扩展了 v-bind 的语法，可以针对 **class类名** 和 **style行内样式** 进行控制。

####  操作 class

```html
:class="对象/数组"
```

##### 对象

键就是类名，值是布尔值。如果值为true，有这个类，否则没有这个类

```html
<div class="box" :class="{ 类名1: 布尔值, 类名2: 布尔值 }"></div>
```

```html
<div class="box" :class="{ pink: true, big: true }">michiko</div>
```

##### 数组

数组中的所有类，都回添加到盒子上。本质上就是一个 class 列表

```html
<div class="box" :class="[ 类名1, 类名2, 类名3 ]"></div>
```

```html
<div class="box" :class="['pink', 'big']">michiko</div>
```

#### 操作 style

```html
:style="样式对象"
```

```html
<div class="box" :style="{ CSS属性名1: CSS属性值, CSS属性名2: CSS属性值 }"></div>
```

```html
<div class="box" :style="{ width: '400px', backgroundColor: 'pink ' }"></div>
```

#### 使用场景

某个具体属性的动态设置，比如说进度条

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906193932.png)


## 2.6 v-for

### 2.6.1 作用

基于**数据**循环，**多次渲染**整个元素

`v-for` 可以遍历数组，对象，数字等

### 2.6.2 语法

```html
<!--  index 可省略 -->
v-for="(item[, index]) in 数组"
```

```html
<ul>  
  <li v-for="(item, index) in list">{{ index + 1 }} - {{ item }}</li>  
</ul>
```

### 2.6.3 v-for 中的 key

#### 为什么需要 key？

1. 下面，我们使用了 `v-for` 渲染出4本，并且第一本的背景色为粉色

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906163106.png)

2. 现在删除第一本书，发现背景色还在

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906163226.png)

分析原因：是因为 `v-for` 的默认行为会尝试原地修改元素（就地复用），只是把文字给做了修改，但是样式却还在

解决办法：使用 `key`

#### 作用

`v-for` 中的 `key` 给列表项添加的**唯一标识**，便于 Vue 进行列表项的**正确排序复用**。

#### 语法

```html
:key属性="唯一标识"
```

#### 注意点

1. key的值只能是**字符串或数字类型**
2. key的值必须具有**唯一性**
3. 推荐使用 id 作为 key(唯一)，不推荐使用 index 作为 key（会变化，不对应）

## 2.7 v-model

### 2.7.1 作用

`v-model` 可以给**表单元素**使用，

**双向数据绑定** → 可以快速**获取或设置**表单元素内容

- 数据变化 -> 表单自动更新
- 表单变化 -> 数据自动更新

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906164615.png)

### 2.7.2 语法

```html
v-model="变量"
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906164902.png)

### 2.7.3 v-model 应用于其他表单元素

常见的表单元素都可以用 `v-model` 绑定关联，快速获取或设置表单元素的值

`v-model` 会根据控件类型自动选取正确的方法来更新元素

>输入框

input:text -> value

>文本域

textarea -> value

>复选框

input:checkbox -> checked

>单选框

input:radio -> checked

>下拉菜单

select -> value


## 2.8 指令修饰符

通过 `.` 指明一些指令后缀，不同后缀封装了不同的处理操作，可以大幅简化代码

### 2.8.1 按键修饰符

#### `@keyup.enter`：监听键盘回车时间

```html
<input @keyup.enter="fn" v-model="username" type="text">
```

### 2.8.2 v-model 修饰符

#### `v-model.trim`：去除首尾空格

```html
姓名：<input v-model.trim="username" type="text"><br>  
```

#### `v-model.number`：转数字

```html
年纪：<input v-model.number="age" type="text"><br>
```

### 2.8.3 事件修饰符

#### `事件名.stop`：阻止冒泡

```html
<div @click="fatherFn" class="father">  
  <div @click.stop="sonFn" class="son">儿子</div>  
</div>
```

#### `事件名.prevent`：阻止默认行为

```html
<a @click.prevent href="http://www.baidu.com">阻止默认行为</a>
```

# 3 计算属性

## 3.1 概念

基于现有的数据，计算出来的新属性。依赖的数据变化，自动重新计算。

## 3.2 语法

- 声明在 `computed` 配置项中，一个计算属性对应一个函数
- 使用起来和普通属性一样使用 `{{ 计算属性名 }}`

```js
computed: {
	计算属性名 () {
		// 基于现有数据，编写求值逻辑
		return 结果
	}
}
```

## 3.3 应用

```html
总数：{{ totalGiftNum }} 个
```

```js
computed: {  
  totalGiftNum() {  
	// 求得总数
    return this.list.reduce((sum, curVal) => sum + curVal.num, 0)  
  }  
}
```

## 3.4 computed 计算属性 与 methods 方法

>computed 计算属性

作用：封装了一段对于数据的处理，求得一个结果。

缓存特性：计算属性会对计算出来的**结果缓存**，再次使用**直接读取缓存**，**依赖项变化了，会自动重新计算，并再次缓存**

>methods 方法

作用：给实例提供一个方法，调用以处理业务逻辑。

## 3.5 计算属性完整写法

计算属性**默认的简写**，只能读取访问，不能”修改"。

```js
computed: {
	计算属性名: {
		get() {
			// 基于现有数据，编写求值逻辑
			return 结果
		},
		set(修改的值) {
			// 基于现有数据，编写修改逻辑
		}
	}
}
```

```html
姓：<input v-model="firstName" type="text"><br>  
名：<input v-model="lastName" type="text"><br>  
<p>姓名：{{ fullName }}</p>  
<button @click="fullName = 'M多多'">修改姓名</button>
```

```js
computed: {  
  fullName: {  
    get() {  
      return this.firstName + this.lastName  
    },  
    set(newName) {  
      this.firstName = newName.substring(0, 1)  
      this.lastName = newName.substring(1)  
    }  
  }  
}
```

# 4 watch 监听器（监视器）

## 4.1 作用

`watch` 可以监视数据变化，执行一些业务逻辑或异步操作。

## 4.2 语法

```js
data: {
	words: '苹果',
	obj: {
		words: '苹果'
	}
},
watch: {
	// 该方法会在数据变化时，触发执行
	数据属性名 (newValue, oldValue) {
		// 业务逻辑 或 异步操作
	}
	'对象.属性名' (newValue, oldValue) {
		// 业务逻辑 或 异步操作
	}
}
```

## 4.3 应用

```js
const app = new Vue({  
  el: '#app',  
  data: {  
    words: '',  
    wordsAfterTranslate: '',  
    lang: 'italy'  
  },  
  watch: {  
    words (newVal, oldVal) {  
      this.translate(newVal, this.lang)  
    },  
    lang (newVal, oldVal) {  
      this.translate(this.words, newVal)  
    }  
  },  
  methods: {  
    translate(words, lang) {  
      axios({  
        url: 'https://applet-base-api-t.itheima.net/api/translate',  
        method: '',  
        params: { words, lang },  
      }).then(result => {  
        this.wordsAfterTranslate = result.data.data  
      })  
    }  
  }  
})
```

## 4.4 完整写法

当我们需要有多个对象监控时，我们通常会把这些对象丢到一个对象里面进行深度监视

watch 属性有额外配置：

- `deep`：是否开启深度监视
- `immediate`：页面加载后是否立即执行一次 handler 处理方法

```js
data: {
	obj: {
		words: '苹果',
		lang: 'english'
	}
},
watch: {
	// 该方法会在数据变化时，触发执行
	数据属性名: {
		// 深度监视
		deep: true,
		// 页面加载后是否立即执行一次 handler 处理方法
		immediate: true,
		// 监视属性发现变动后执行的操作
		handler (newVal) {
			// 业务逻辑 或 异步操作
		}
	}
}
```

```js
const app = new Vue({  
  el: '#app',  
  data: {  
    obj: {  
      words: '欢迎使用本翻译软件',  
      lang: 'italy'  
    },  
    wordsAfterTranslate: '',  
  },  
  watch: {  
    obj: {  
	  // 深度监视
      deep: true,  
      // 一进页面立刻执行 handler
      immediate: true,  
      handler (newVal) {  
        axios({  
          url: 'https://applet-base-api-t.itheima.net/api/translate',  
          method: '',  
          params: { words: newVal.words, lang: newVal.lang },  
        }).then(result => {  
          this.wordsAfterTranslate = result.data.data  
        })  
      }  
    }  
  }  
})
```

# 5 Vue 生命周期

生命周期：一个 Vue 实例从创建到销毁的整个过程。

生命周期四个阶段：

- 创建
- 挂载
- 更新
- 销毁

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230907225419.png)

Vue 生命周期过程中，会**自动运行一些函数**，被称为 **生命周期钩子** ，以便开发者可以在 **特定阶段** 运行**自己的代码**。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230907230216.png)

```js
// 创建阶段（准备数据）  
beforeCreate() {  
  console.log('beforeCreate 响应式数据准备好前')  
},  
created() {  
  // 可以处理业务逻辑，以及发起异步请求  
  console.log('created 响应式数据准备好后')  
},  
// 挂载阶段（渲染模板）  
beforeMount() {  
  console.log('beforeMount 模板渲染前')  
},  
mounted() {  
  // 可以操作 DOM 了  
  console.log('mounted 模板渲染后')  
},  
// 更新阶段（修改数据 -> 更新视图）  
beforeUpdate() {  
  console.log('beforeUpdate', document.querySelector('span').innerHTML)  
},  
updated() {  
  console.log('updated', document.querySelector('span').innerHTML)  
},  
// 卸载阶段  
beforeDestroy() {  
  // 清除掉一些Vue意外的资源占用，定时器，延时器  
  console.log('beforeDestroy')  
},  
destroyed() {  
  console.log('destroyed')  
}
```

# 6 工程化开发 & 脚手架 Vue CLI

开发Vue的两种方式:

1. 核心包传统开发模式：基于 html/css/js 文件，直接引入核心包，开发Vue。
2. 工程化开发模式：**基于构建工具（例如：webpack）的环境中开发Vue。**

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908105308.png)

>问题

- webpack 配置**不简单**
- **雷同**的基础配置
- **缺乏统一标准**

## 6.1 定义

`Vue CLI` 是 Vue 官方提供的一个全局命令工具，可以帮助我们快速创建一个开发Vue项目的标准化基础架子，**集成了webpack配置**

## 6.2 好处

1. 开箱即用，零配置
2. 内置 babel 等工具
3. 标准化

## 6.3 搭建步骤

1. 全局安装（一次）：`yarn global add @vue/cli` 或 `npmi @vue/cli -g`
2. 查看 Vue 版本：`vue --version`
3. 创建项目架子：`vue create project-name`
4. 启动项目（package.json目录下）：`yarn serve` 或 `npm run serve`

## 6.4 脚手架目录文件介绍 & 项目运行流程

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908113154.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908114352.png)

# 7 组件化开发

## 7.1 组件化

组件化：一个页面可以拆分成一个个组件，**每个组件有着自己独立的结构、样式、行为。**

便于维护，利于复用，提升效率。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908114701.png)

## 7.2 根组件

组件分类：普通组件，根组件

**根组件**：整个应用最上层的组件，包裹所有普通小组件。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908115904.png)

## 7.3 单文件组件的三个组成部分

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908134509.png)

- template：结构（Vue2中有且只能一个根元素）
- script：Js 逻辑
- style：样式（可支持 less 语法，需要装包）

>让组件支持 less

- `<style lang="less">` 开启 less 功能
- 装包：`yarn add less less-loader`

## 7.4 普通组件的注册使用

组件注册的两种方式：

1. 局部注册：只能在注册的组件内使用
2. 全局注册：所有组件内都能使用

### 7.4.1 局部注册

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908163851.png)

##### 1. 创建 Vue 文件

>组件名规范使用**大驼峰命名法**，如：`MyHeader.vue`

```vue
<template>  
  <div id="myHeader" class="my-header">  
    我是头部组件  
  </div>  
</template>  
  
<script>  
export default {  
  
}  
</script>  
  
<style lang="less">  
  .my-header {  
    height: 100px;  
    line-height: 100px;  
    text-align: center;  
    font-size: 30px;  
    background-color: #8064a2;  
    color: white;  
  }  
  
</style>
```

##### 2. 在使用的组件中进行注册其他组件

```vue
<script>  
import 组件名 from "vue文件路径";  

export default {  
  components: {  
	'组件名': '组件对象'  
  }  
}  
</script>
```

##### 3. 在使用的组件中使用其他组件

```html
<template>
	<组件名></组件名>
</template>
```

### 7.4.2 全局注册

##### 1. 创建 Vue 文件

>组件名规范使用**大驼峰命名法**，如：`MyBtn.vue`

```js
<template>  

</template>  
  
<script>  

</script>  
  
<style lang="less">  
  
</style>
```

##### 2. **main.js** 中进行全局注册

```js
import 组件名 from "组件路径";  

Vue.component('组件名', 组件名)  
```

##### 3. 使用

```html
<组件名></组件名>
```

## 7.5 data 函数

组件的 data 选项必须是一个函数，保证每个组件实例，维护独立的一份数据对象。

```js
export default {  
  data() {  
    return {  
      count: 100,  
    }  
  },  
}
```

三个一样的组件，其 `data` 不一样，每个**组件实例**，维护独立的一份数据对象。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909093620.png)

# 8 组件的样式冲突

写在组件中的样式会**全局生效**，因此很容易造成多个组件之间的样式冲突问题。

为了防止样式冲突，我们可以给组件的 `<style>` 加上 `scoped` 属性，可以让**样式只作用于当前组件**

>scoped 原理

1. 当前组件内标签都被添加 `data-v-hash` 值的属性
2. css 选择器都被添加 `data-v-hash` 的属性选择器

最终效果：必须是当前组件的元素，才会有这个自定义属性，才会被这个样式作用到

# 9 组件通信

组件通信，就是指组件与组件之间的数据传递。由于组件的数据是独立的，无法直接访问其他组件的数据。所以想用其他组件的数据就需要组件通信

## 9.1 组件关系

组件关系分类：

1. 父子关系
2. 非父子关系

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909093952.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909093944.png)

## 9.2 通信解决方案

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909094054.png)

## 9.3 父子通信流程图

1. 父组件通过 `props` 将数据传递给子组件
2. 子组件利用 `$emit` 通知父组件修改更新

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909094302.png)

### 9.3.1 父 -> 子

1. 父组件通过 `:参数名` 将参数传递给子组件
2. 子组件通过定义 `props` 来进行参数的接收
3. 像平常属性一样使用 `{{}}` 进行参数的使用

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909095124.png)

### 9.3.2 子 -> 父

子组件无法直接修改修改父组件中的数据，子组件只能通知父组件进行修改

1. 子组件通过 `this.$emit('事件名', '参数')`
2. 父组件中添加消息监听 `@事件名="处理函数"`
3. 父组件中事先处理函数

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909100423.png)


## 9.4 非父子通信 - event bus 时间总线

`event bus` 可以在非父子组件之间，进行简易消息传递。

复杂场景：**使用 Vuex**

>步骤

1. 创建一个都能访问到的事件总线（空Vue实例，`utils/EventBus.js`）

```js
import Vue from 'vue'
const Bus = new Vue()
export default Bus
```

2. A组件（接收方），监听 Bus 实例的事件

```js
created() {
	Bus.$on('sendMsg', (msg) => {
		this.msg = msg
	})
}
```

3. B组件（发送方），触发 Bus 实例的事件

```js
Bus.$emit('sendMsg', '这是一个消息')
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909164012.png)

## 9.5 非父子通信 - provide & inject

provide & inject 作用：**跨层级**共享数据，子孙后代也可以进行取值使用

>步骤

1. 父组件 provide 提供数据

```js
export default {
	provide() {
		return {
			// 普通类型【非响应式】
			color: this.color,
			// 复杂类型【响应式】
			userInfo: this.useInfo
		}
	}
}
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909172312.png)

2. 子/孙组件 inject 取值使用

```js
export default {
	inject: ['color', 'userInfo']
	created() {
		console.log(this.color, this.userInfo)
	}
}
```

## 9.6 什么是 Prop ？

### 9.6.1 定义

Prop 是组件上注册的一些 `自定义属性`

### 9.6.2 作用

Prop 可以向子组件传递数据

### 9.6.3 特点

可以传递 **任意数量** 的 prop
可以传递 **任意类型** 的 prop

>父组件

```js
data() {  
  return {  
    username: '小帅',  
    age: 28,  
    isSingle: true,  
    car: {  
      brand: '宝马',  
    },  
    hobby: ['篮球', '足球', '羽毛球'],  
  }  
}
```

```html
<UserInfo  
    :username="username"  
    :age="age"  
    :isSingle="isSingle"  
    :car="car"  
    :hobby="hobby"  
></UserInfo>
```

>子组件

```js
props: [  
    'username',  
    'age',  
    'isSingle',  
    'car',  
    'hobby'  
]
```

```html
<div class="userinfo">  
  <h3>我是个人信息组件</h3>  
  <div>姓名：{{ username }}</div>  
  <div>年龄：{{ age }}</div>  
  <div>是否单身：{{ isSingle ? '是' : '否' }}</div>  
  <div>座驾：{{ car.brand }}</div>  
  <div>兴趣爱好：{{ hobby.join('，') }}</div>  
</div>
```

### 9.6.4 props 校验

开发者可以为组件的 props 指定验证要求，不符合要求，控制台就会有错误提示，以便帮助开发者，快速发现错误

#### 校验类型

- 类型校验
- 非空校验
- 默认值
- 自定义校验

#### 类型校验

```js
props: {
	// 类型可为 Number String Boolean 等等
	校验的属性名: 类型
}
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909102528.png)

#### 非空校验 / 默认值 / 自定义校验

```js
props: {  
  w: {  
	// Number String Boolean 等等
    type: Number,  
    // 是否必填
    required: true,  
    // 默认值
    default: 默认值,  
    // 自定义校验逻辑
    validator(value) {  
      return 是否通过校验  
    }  
  }  
}
```

```js
props: {  
  w: {  
    type: Number,  
    // required: true,  
    default: 0,  
    validator(value) {  
      // 自定义校验逻辑  
      if (value >= 0 && value <= 100) {  
        return true  
      }  
      else {  
        console.error('prop 必须 0～100')  
        return false  
      }  
    }  
  }
}
```

### 9.6.5 prop 与 data

#### 共同点

prop 与 data 都可以给组件提供数据

#### 区别

- data 的数据属于各自组件，可以**随意修改**
- prop 的数据是外部的，**不能直接改**，遵循[[#^1faf98|单向数据流]]

>单向数据流

^1faf98

父组件的 props 更新，会单向向下流动，影响子组件

prop 如果想要修改，需要使用 `this.$emit()` 通知父组件进行修改

# 10 进阶语法

## 10.1 vue-model 原理

### 10.1.1 原理

`v-model` 本质上是一个语法糖。例如应用在**输入框**上，就是 `value 属性` 和 `input事件` 的合写。 

`v-model` 用于在不同的控件上，属性和事件可能会有些区别，比如 `v-model` 如果作用于复选框上，那么底层就是 `checked属性` 与 `change事件` 的合写
### 10.1.2 作用

`v-model` 提供数据的双向绑定

```html
<input v-model="msg" type="text>
```

等价于

```html
<!-- $event 用于在模板中，获取事件的形参 -->
<!-- :value 可以将 msg 属性值显示在 input 框中 -->
<!-- @input 可以获取 input 事件，并且将 input 值赋值给 msg -->
<input :value="msg" @input="msg = $event.target.value" type="text>
```

### 10.1.3 表单类组件封装 & v-model 简化代码

#### 表单类组件封装

1. 父传子：数据应该是父组件 `props` 传递过来的，`v-model` 拆解绑定数据

```html
<BaseSelect  
    :cityId="selectId"  
    @changeId="handleChangeId"  
></BaseSelect>
```

2. 子传父：监听输入，子传父传值给父组件修改

```html
<select :value="cityId" @change="handleChange">  
  <option value="101">北京</option>  
  <option value="102">上海</option>  
  <option value="103">武汉</option>  
  <option value="104">广州</option>  
  <option value="105">深圳</option>  
</select>
```

```js
props: {  
  cityId: String  
},  
methods: {  
  handleChange(e) {  
    this.$emit('changeId', e.target.value)  
  }  
}
```

#### v-model 简化代码

父组件使用 `v-model` 简化代码，实现子组件和父组件数据双向绑定

**注意**：例子里面是单选框，所以 `v-model` 等价于 `:value="xx" @change="xx"`，如果是多选框，则 `v-model` 等价于 `:checked="xx" @change="xx"` ，需要根据不同的控件来选择不同的属性和事件

1. 子组件中：`props` 通过 `value` 接收，事件触发 `input`

```html
<div>  
  <select :value="value" @change="handleChange">  
    <option value="101">北京</option>  
    <option value="102">上海</option>  
    <option value="103">武汉</option>  
    <option value="104">广州</option>  
    <option value="105">深圳</option>  
  </select>  
</div>
```

```js
props: {  
  value: String  
},  
methods: {  
  handleChange(e) {  
    this.$emit('input', e.target.value)  
  }  
}
```

2. 父组件中：`v-model` 给组件直接绑数据

```html
<div class="app">  
  <!-- 由于输入框环境下， v-model 等价于 :value="msg" @input="msg = $event.target.value"，所以直接写 v-model -->  <BaseSelect  
    v-model="selectId"  
  ></BaseSelect>  
</div>
```

## 10.2 .sync 修饰符

### 10.2.1 作用

`.sync` 可以实现**子组件与父组件数据的双向绑定**，简化代码

### 10.2.2 特点

`prop` 属性名，可以自定义，非固定值 `value` 或者固定值 `checked`

>关于为什么是固定值参考 [[#v-model 简化代码|v-model 简化代码]]

### 10.2.3 场景

封装弹框类的基础组件，使用 `props.visible` 属性，其中 true：显示，false：隐藏

### 10.2.4 语法

这里通过控制弹窗的显示与隐藏展示语法

#### 父组件

```html
<!-- visiable 为 prop 属性值 -->
<BaseDialog :visiable.sync="isShow"/>
```

等价于

```html
<BaseDialog 
	:visiable="isShow"
	@update:visiable="isShow = $event"
/>
```

#### 子组件

```js
props: {
	visiable: Boolean
}
```

```js
this.$emit('update:visiable', false)
```

## 10.3 ref 和 $refs

### 10.3.1 作用

利用 `ref` 和 `$refs` 可以用于获取**组件内的 DOM 元素**，或**组件实例**

**注意**：`document.querySelector('xxx')` 会检索出页面上第一个，而不是组件内

### 10.3.2 特点

`ref` 与 `$refs` 的查找范围为当前组件内（更精确稳定）

### 10.3.3 语法

#### 获取 DOM 元素

```html
<div ref="chartRef">我是渲染图的容器</div>
```

```js
mounted() {
	console.log(this.$refs["chartRef"])
}
```

#### 获取组件实例

```html
<BaseForm ref="baseForm"></BaseForm>
```

```js
this.$refs["baseForm"].组件方法()
```

## 10.4 Vue 异步更新机制 & $nextTick

### 10.4.1 问题出现

>思考：我们想要点 `编辑按钮` ，显示输入框，并且让输入框聚焦

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230910115703.png)

我们可能会写出以下代码：

```js
// 显示输入框
this.isShowEdit = true
// 获取焦点
this.$refs.inp.focus()
```

但是问题就出现了，控制台打印显示 `this.$refs.inp` 是 undefined，这是为什么？

原因：**Vue是异步更新 DOM（提升性能）**

### 10.4.2 问题解决：$nextTick

`$nextTick` 可以等DOM更新后，才会触发执行此方法里的函数体

```js
this.$nextTick(() => {
	this.$refs.inp.focus()
})
```

# 11 自定义指令

自定义指令：自己定义的指令，可以**封装一些 DOM 操作**，扩展额外功能

## 11.1 基本语法（全局 & 局部注册）

### 11.1.1 注册自定义指令

#### 全局注册

```js
Vue.directive('指令名', {
	// inserted 表示当前这个元素被插入到页面当中后，执行一系列操作
	inserted(el) {
		// 对 el 标签的操作，扩展额外功能
		el.focus()          // 这里是对元素进行聚焦操作
	}
})
```

#### 局部注册

```js
directives: {
	指令名: {
		inserted (el) {
			// 对 el 标签的操作，扩展额外功能
		}
	}
}
```

### 11.1.2 使用自定义指令

```html
<input v-指令名 type="text">
```

## 11.2 指令的值

>需求：实现一个 color 指令，传入不同的颜色，给标签设置不同的字体颜色

### 11.2.1 语法

```html
<div v-color="color">我是内容</div>
```

通过 `binding.value` 可以拿到指令值，指令值**修改**会触发 `update` 函数。

```js
directives: {
	指令名: {
		inserted (el, binding) {
			// 对 el 标签的操作，扩展额外功能
			// binding 为传递的值
			el.style.color = binding.value
		},
		// 当指令值修改后，会触发 update 函数
		update (el, binding) {
			// 对 el 标签的操作，扩展额外功能
			// binding 为传递的值  
			el.style.color = binding.value
		}
	}
}
```

## 11.3 v-focus 指令封装

我们希望文本框自动对焦，可以使用自定义指令，以便多次使用

```js
Vue.directive('focus', {  
  inserted(el) {  
    el.focus()  
  }})
```

```html
<input v-focus type="class">
```

## 11.4 v-loading 指令封装

>场景：实际开发过程中，发送请求需要时间，在请求的数据未回来时，页面会处于空白状态，影响用户体验

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230911224653.png)

### 11.3.1 本质

1. loading 本质就是一个蒙层，盖在了盒子上
2. 数据请求中，开启 loading 状态，添加蒙层
3. 数据请求完毕，关闭 loading 状态，移除蒙层

### 11.3.2 实现

1. 准备一个 loading 类，通过伪元素定位，设置宽高，实现蒙层
2. 开启关闭 loading 状态（添加移除蒙层），本质只需要添加移除类即可
3. 结合自定义指令的语法进行封装复用

```html
<!-- 添加蒙层效果 -->
<div class="box" v-loading="isLoading">
	<ul>  
	  <li v-for="item in list" :key="item.id" class="news">  
	    <div class="left">  
	      <div class="title">{{ item.title }}</div>  
	      <div class="info">  
	        <span>{{ item.source }}</span>  
	        <span>{{ item.time }}</span>  
	      </div>  
	    </div>  
	  
	    <div class="right">  
	      <img :src="item.img" alt="">  
	    </div>  
	  </li>  
	</ul>
</div>
```

```css
/* 伪类 - 蒙层效果 */.loading:before {  
  content: '';  
  position: absolute;  
  left: 0;  
  top: 0;  
  width: 100%;  
  height: 100%;  
  background: #fff url('./loading.gif') no-repeat center;  
}
```

```js
directives: {  
  loading: {  
	  <!-- 数据返回后，取消蒙层 --> 
    inserted(el, binding) {  
      binding.value ? el.classList.add('loading') : el.classList.remove('loading')  
    }, 
    <!-- 数据返回后，取消蒙层 --> 
    update(el, binding) {  
      binding.value ? el.classList.add('loading') : el.classList.remove('loading')  
    }  
  }  
}
```

# 12 插槽

作用：让组件内部的一些**结构**支持**自定义**

场景：要在页面中显示一个对话框，封装成一个组件

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912102502.png)

## 12.1 默认插槽

1. 组件内需要定制的结构部分，改用 `<slot></slot>` 占位
2. 使用组件时，被调用的组件标签内部，传入结构替换 `<slot></slot>` 内容

### 12.1.1 语法

#### 子组件

```html
<div>
	<!-- 使用 slot 占位 -->
	<slot></slot>
</div>
```

#### 父组件

```html
<SonComponent>
	这里填写的内容会被插入到 slot 中
</SonComponent>
```

### 12.1.2 例子

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912111054.png)

## 12.2 后备内容

通过插槽完成了内容的定制，传什么显示什么，但是**如果不传，则是空白**，影响用户体验

>语法

在 `<slot>` 标签内，放置内容，作为默认显示内容

```html
<slot>我是插槽后备内容（默认值）</slot>
```

## 12.3 具名插槽

一个组件内有 **多处结构**  需要外部传入标签，进行定制

### 12.3.1 语法

1. 多个 `slot` 使用 `name` 属性区分名字
2. `template` 配合 `v-slot:名字` 来分发对应标签

#### 子组件

```html
<slot name="head"></slot>
```

#### 父组件

**简写**：`v-slot:插槽名` 可以简写为 `#插槽名`

```html
<template v-slot:head>
	大标题
</template>
```

### 12.3.2 应用

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912112913.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912113401.png)

## 12.4 作用域插槽

>**注意**：作用域插槽不属于插槽分类，是插槽的传参语法

定义 `slot` 插槽的同时，是可以**传递参数**的。给**插槽**上可以**绑定数据**，将来**使用组件时可以用**。

### 12.4.1 场景：封装表格组件

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912113423.png)

1. 父传子，动态渲染表格内容
2. 利用默认插槽，定制操作列
3. 删除或查看都需要用到 **当前项的id**，属于 **组件内部的数据**
4. 通过 **作用域插槽传值** 绑定，进而使用

### 12.4.2 语法

1. 给 `<slot></slot>` 标签，以添加属性的方式传值
2. 所有添加的属性，都会被收集到一个对象中
3. 在 `<template></template>` 中，通过 `#插槽名="obj"` 接收，默认插槽名为 `default`

#### 子组件

```html
<slot :属性值="值"></slot>
```

#### 父组件

```html
<!-- #default：表示默认插槽 -->  
<!-- obj：接受的来自于参数名，可以自定义 -->  
<template #default="插槽传递过来的属性值">  
	<!-- 访问属性 -->
	{{属性值.xxx}}
</template>
```

### 12.4.3 应用

![](https://raw.githubusercontent.com/michik0/notes-image/master/20230912134303.png)

# 13 路由入门

## 13.1 单页应用程序 SPA - Single Page Application

单页面应用（SPA）：所有功能在**一个html页面**上实现

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912155149.png)

>适用场景

- 单页面应用：系统类网站 / 内部网站 / 文档类网站 / 移动端站点
- 多页面应用：公司官网 / 电商类网站

## 13.2 路由概念

Vue中路由是路径和组件的映射关系

⚠️upload failed, check dev console

## 13.3 VueRouter 的基本使用

>官网：<https://v3.router.vuejs.org/zh/>

### 13.3.1 作用

`VueRouter` 可以在**修改地址栏路径**时，**切换显示**匹配的组件

### 13.3.2 使用

#### 1. 下载

下载 VueRouter 模块到当前工程，版本3.6.5（Vue2 对应 VueRouter 3.x，Vue3 对应 VueRouter 4.x）

```bash
npm i vue-router@3.6.5
```

#### 2. 引入

```js
import VueRouter from 'vue-router'
```

#### 3. 安装注册

```js
Vue.use(VueRouter)
```

#### 4. 创建路由对象

```js
const router = new VueRouter()
```

#### 5. 注入

将路由对象注入到 `new Vue` 实例中，建立关联

```js
new Vue({
	render: h => h(App),
	// 注入 VueRouter
	router
}).$mount('#app')
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912165444.png)

#### 6. 创建需要的组件（views目录），配置路由规则

```js
const router = new VueRouter({  
  routes: [  
    { path: '/find', component: Find },  
    { path: '/my', component: My },  
    { path: '/friend', component: Friend }  
  ]  
})
```

#### 7. 配置导航，配置路由出口（路径匹配的组件显示的位置）

```html
<div class="footer_wrap">  
	<a href="#/find">发现音乐</a>  
	<a href="#/my">我的音乐</a>  
	<a href="#/friend">朋友</a>  
</div>  
<div class="top">  
	<!-- 匹配的组件所展示的位置 -->
	<router-view></router-view>  
</div>
```

## 13.4 组件目录存放问题

>路由相关的组件，为什么放在 `views` 目录呢？

### 13.4.1 组件分类

`.vue` 文件分2类：

- 页面组件
- 复用组件

他们的本质，都是 vue 文件

### 13.4.2 为什么需要分开放

分类开来，更易维护

**规范：**

- `src/views` 文件夹：**页面组件（页面展示）**，配合路由用
- `src/components` 文件夹：**复用组件（展示数据）**，常用于复用

# 14 路由进阶

## 14.1 路由模块的封装与抽离

随着项目越来越大，我们需要在 `main.js` 里面定义很多的路由，这样会非常不整洁，我们需要将路由模块抽离出来。

>步骤

1. 创建 `src/router/index.js`

```js
import VueRouter from "vue-router";  
import Find from "@/views/Find.vue";  
import Friend from "@/views/Friend.vue";  
import My from "@/views/My.vue";  
import Vue from "vue";  
  
// 使用 VueRouter 插件  
Vue.use(VueRouter)  
  
// 定义 routerconst router = new VueRouter({  
    routes: [  
        { path: '/find', component: Find },  
        { path: '/my', component: My },  
        { path: '/friend', component: Friend }  
    ]  
})  
  
// 导出 router
export default router
```

2. `main.js` 导入 router

```js
new Vue({  
  render: h => h(App),  
  router  
}).$mount('#app')
```

## 14.2 声明式导航

### 14.2.1 声明式导航

>需求：想要实现导航高亮的效果

`vue-router` 提供了一个全局组件 `router-link`（取代 `<a>` 标签）

#### 特点

- **能跳转**：配置 `to` 属性指定路径，本质还是 `<a>` 标签
- **能高亮**：默认就会提供**高亮类名**，可以直接设置高亮样式

#### 语法

```html
<router-link to="/find">发现音乐</router-link>
```

#### 实现高亮

`router-link` 会自动给当前导航添加了两个高亮类名：`router-link-active` 和 `router-link-exact-active`，因此我们可以通过CSS来控制高亮

```css
a.router-link-active {
	background-color: purple
}
```

### 14.2.2 精确匹配 & 模糊匹配

我们发现 `router-link` 自动给当前导航添加了两个高亮类名

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912201018.png)

#### router-link-active：模糊匹配（更加灵活）

`to="/my"` 可以匹配 `/my`、`/my/a`、`/my/b` ...

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912201841.png)

由于模糊匹配，高亮CSS依然可以匹配到

#### router-link-exact-active：精确匹配

`to="/my"` 仅可以匹配 `/my`

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912202004.png)

由于精确匹配，发现高亮CSS未生效

### 14.2.3 自定义高亮类名

`router-link` 默认的两个高亮类名太长了，我们可以自定义高亮类名

```js
const router = new VueRouter({
	routes: [...],
	linkActiveClass: "模糊匹配类名1",
	linkExactActiveClass: "精确匹配类名2"
})
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912203309.png)

### 14.2.4 声明式导航传参

在跳转路由时，可以进行值的传递

#### 查询参数传参

##### 源头页面组件传递参数

```html
to="/path?参数名=参数值"
```

##### 目标页面组件获取参数

```js
{{ $route.query.参数名 }}
```

```js
this.$route.query.参数名
```

#### 动态路由传参

##### 配置动态路由

```js
const router = new VueRouter({  
  routes: [  
    { path: '/home', component: Home },  
    { path: '/search/:参数名', component: Search }  
  ]  
})
```

**注意**：`:参数名` 的方式必须需要传递参数，否则会匹配不到组件，如果希望不传递参数也能匹配，可以加个可选符 `?`，比如 `/search/:id?`

##### 源头页面组件传递参数

```html
to="/path/参数值"
```

##### 目标页面组件获取参数

```js
{{ $route.params.参数名 }}
```

```js
this.$route.params.参数名
```

#### 两种传参方式的区别

##### 查询参数传参

比较适合传多个参数

1. 跳转：`to="/path?参数1=值1&参数2=值2"`
2. 获取：`$route.query.参数名`

##### 动态路由传参

1. 配置动态路由：`path:"/path/参数名"`
2. 跳转：`to="/path/参数值"`
3. 获取：`$route.params.参数名`

## 14.3 路由重定向

### 14.3.1 路由重定向

#### 定义

网页打开，url 默认是 `/` 路径，未匹配到组件时，会出现空白

重定向：匹配到指定的 `path` 后，强制跳转至指定的目标路径

#### 语法

```js
const router = new VueRouter({  
  routes: [  
    { path: '/', redirect: '/home' },
    ...
  ]  
})
```

### 14.3.2 路由404

#### 作用

当路径找不到匹配时，我们希望给个提示页面

#### 位置

需要配置在**路由的最后**

#### 语法

```js
const router = new VueRouter({  
  routes: [  
    ...
    { path: '*', components: NotFind }
  ]  
})
```

### 14.3.3 路由模式

路由的路径看起来不自然，有 `#`

- `hash` 路由（默认），例如 `http://localhost:8080/#/home`
- `history` 路由，例如 `http://localhost:8080/home`

```js
const router = new VueRouter({
	routes,
	mode: 'history'
})
```

## 14.4 编程式导航

### 14.4.1 编程式导航

我们可以通过JS代码的方式来进行跳转

#### 1 path 路径跳转

```js
this.$router.push('路由路径')
```

```js
this.$router.push({
	path: '路由路径'
})
```

#### 2 path 路径返回

```js
this.$router.back()
```

#### 3 name 命名路由跳转（适合 path 路径长的场景）

##### 3.1 定义路由 name

```js
const router = new VueRouter({  
  routes: [  
	...
	// 定义路由名  
	{ name: 'search', path: '/search/:words?', component: Search },  
  ]  
})
```

##### 3.2 根据 name 跳转

```js
this.$router.push({
	name: '路由名'
})
```

### 14.4.2 编程式导航传参

#### 1 path 路径跳转传参

##### 1.1 查询参数传参

###### 1.1.1 源头组件传递参数

```js
this.$router.push('路由路径?参数1=值1&参数2=值2')
```

```js
this.$router.push({
	path: '路由路径',
	query: {
		参数1: '值1',
		参数2: '值2'
	}
})
```

###### 1.1.2 目标组件获取值

```js
{{ $route.query.参数名 }}
```

##### 1.2 动态路由传参

###### 1.2.1 配置动态路由

```js
const router = new VueRouter({  
  routes: [  
    { path: '/home', component: Home },  
    { path: '/search/:参数名', component: Search }  
  ]  
})
```

###### 1.2.2 源头组件传递参数

```js
this.$router.push('路由路径/参数值')
```

```js
this.$router.push({
	path: '路由路径/参数值'
})
```

###### 1.2.3 目标组件获取值

```js
{{ $route.params.参数名 }}
```

#### 2 name 命名路由跳转传参

##### 2.1 查询参数传参

```js
this.$router.push() {
	name: '路由名字',
	query: {
		参数1: '值1'
	}
}
```

```js
{{ $route.query.参数名 }}
```

##### 2.2 动态路由传参

```js
this.$router.push() {
	name: '路由名字',
	params: {
		// 这边需要与路由配置中的路径一致
		参数1: '值1'
	}
}
```

```js
{{ $route.params.参数名 }}
```

## 14.5  组件缓存 keep-alive

### 14.5.1 为什么需要组件缓存？

当我们从组件A跳转到组件B，又从组件B返回到组件A时，**由于路由跳转后，A组件被销毁了**，而后返回到组件A时，组件A需要重新构建，耗费事件，影响用户体验

### 14.5.2 定义

`keep-alive` 是 Vue 的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。

`keep-alive` 是一个抽象组件：它自身不会渲染成一个 DOM 元素，也不会出现在父组件链中。

### 14.5.3 优点

在组件切换过程中把切换出去的组件保留在内存中，防止重复渲染DOM，减少加载时间及性能消耗，提高用户体验性。

### 14.5.4 用法

```html
<div>
	<!-- 所匹配的一级路由都会被缓存，这里是Layout和Detail都会被缓存 -->
	<!-- 如果只需要 包含/排除 部分，参考 15.5 三个属性 -->
	<keep-alive>
		<router-view></router-view>
	</keep-alive>
</div>
```

### 14.5.5 keep-alive 三个属性

| 属性    | 说明                                   |
| ------- | -------------------------------------- |
| include | **组件名**数组，只有匹配的组件会被缓存     |
| exclude | **组件名**数组，任何匹配的组件都不会被缓存 |
| max     | 最多可以缓存多少组件实例                                       |

```html
<keep-alive :include="['LayoutPage']">  
  <router-view></router-view>  
</keep-alive>
```

### 14.5.6 注意

如果组件被缓存了，那第二次进入缓存的页面，将**不会触发 `created` 和 `mounted` 这两个钩子函数了**，理所当然，**由于被缓存了，`destroyed` 钩子函数也不会触发**。

Vue 提供了新的两个钩子函数：`actived` 和 `deactived`

```js
activated() {  
  console.log('组件被激活了（进入页面）')  
},  
deactivated() {  
  console.log('组件失活（离开页面）')  
}
```


## 14.6 二级路由

当我们需要在路由中嵌套路由时，可以采用二级路由，比如：有如下一级路由

>`Layout.vue`

```html
<div class="h5-wrapper">  
  <div class="content">  
    <!-- 二级路由出口，匹配到的二级路由就会在这展示 -->  
    <router-view></router-view>  
  </div>  
  <nav class="tabbar">  
    <router-link to="/article">面经</router-link>  
    <router-link to="/collect">收藏</router-link>  
    <router-link to="/like">喜欢</router-link>  
    <router-link to="/user">我的</router-link>  
  </nav>  
</div>
```

我们希望在 `<router-view>` 中重新嵌套一个路由，用于展示，我们可以采用二级路由

```js
routes: [  
	// 一级路由
	{  
		path: '/',  
		component: Layout,
		// 二级路由，内容将会展示在 Layout.vue 中的 <router-view> 中
		children: [  
			{  
				path: '/article',  
				component: Article  
			},  
			{  
				path: '/collect',  
				component: Collect  
			},  
			{  
				path: '/like',  
				component: Like  
			},  
			{  
				path: '/user',  
				component: User  
			}  
		]  
	},  
	// 一级路由
	{ 
		path: '/detail/:id?', 
		component: ArticleDetail 
	}  
]
```

# 15 自定义创建项目

在创建项目的时候，如果我们每次都要自己去搭建架子，那么太费事了，我们可以通过 `vue create` 自定义一个架子

## 15.1 步骤

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913135750.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913135845.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913140524.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913140423.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913140516.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913140544.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913140819.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913140623.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913140606.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913140707.png)

## 15.2 生成结果

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913141110.png)

## 16 ESLint 代码规范

>官网：<https://standardjs.com/readme-zhcn>

以下列出一部分：

- 字符串使用单引号：'abc'
- 无分号：const name = 'zs'
- 关键字后加空格：if (name = 'ls') { ... }
- 函数名后加空格：function name (arg) { ... }
- 坚持使用全等 `===`

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913142940.png)

# 17 Vuex

## 17.1 定义

`Vuex` 是一个 Vue 的状态管理工具，可以帮我们**管理 `Vue` 通用的数据**（多组件共享的数据）

## 17.2 场景

- 某个状态在很多个组件来使用（个人信息）
- 多个组件共同维护一份数据（购物车）

## 17.3 为什么需要 Vuex

1. 共同维护一份数据，**数据集中化管理**
2. **响应式变化**
3. 操作简洁（`Vuex` 提供了辅助函数来供我们操作数据）

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913144224.png)

## 17.4 使用 Vuex

### 17.4.1 初始化空仓库

#### 1. 安装 Vuex

**注意**：`Vue 2.x` 对应 `Vuex 3.x`

```bash
npm i vuex@3
```

#### 2. 新建 Vuex 模块文件

新建 `store/index.js` 放置 `Vuex`

#### 3. 创建仓库

```js
Vue.use(Vuex)  
// 创建仓库  
const store = new Vuex.Store()  
  
export default store
```

#### 4. `main.js` 导入挂载

在 `main.js` 中导入挂载到 `Vue` 实例上

```js
new Vue({  
  render: h => h(App),  
  store  
}).$mount('#app')
```

### 17.4.2 核心概念：state（提供数据）

State 提供唯一的公共数据源，所有共享的数据都要统一放到 `Store` 中的 `State` 中存储。

在 `State` 对象中可以添加我们要共享的数据。

```js
Vue.use(Vuex)  
// 创建仓库  
const store = new Vuex.Store({
		// state 状态，即数据，类似于 Vue 组件中的 data
		// 区别：
		// 1. data是组件自己的据
		// 2. state所件享据
		state: {
			count: 100
		}
	}
)

export default store
```

### 17.4.3 获取数据

#### `<template>` 中获取数据

```html
{{ $store.state.xxx }}
```

#### `<script>` 中获取数据

```js
this.$store.state.xxx
```

#### js 文件中获取数据

```js
import store from 'xxx'

store.state.xxx
```

### 17.4.4 辅助函数：mapState（优化 state）

`mapState` 是辅助函数，帮助我们把 `store` 中的数据**自动**映射到**组件的计算属性**中

#### 导入 mapState

```js
import { mapState } from 'vuex'
```

#### 数组方式引入 state

```js
mapState(['count', 'title', ...])
```

#### 将 mapState 中的属性展开放到 computed 中

```js
computed: {  
  ...mapState(mapState(['count', 'title']))  
}
```

等价于：

```js
computed: {
	count: this.$store.state.count,
	title: this.$store.state.title
}
```

#### 使用 computed 属性

```html
{{ count }}
```

### 17.4.5 核心概念：mutations（修改数据）

>**注意**：Vuex 同样遵循单向数据流，**组件中不能直接修改仓库的数据**

#### 组件中不允许直接修改仓库数据

例如，`this.$store.state.count++` 是不被允许的，但是出于性能的考虑，Vue 不会进行报错

若希望开启严格的单项数据流，则可以**开启严格模式（上线的时候需要关闭，因为消耗性能）**：

```js
const store = Vue.Store({
	// 严格模式
	strict: true
})
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913170818.png)

#### 语法

state 数据的修改只能通过 `mutations`

##### 1. 定义 mutations 对象，对象中存放修改 state 的方法

```js
const store = new Vuex.Store({  
  // 开启严格模式，上线后需要关闭，因为消耗性能  
  strict: true,  
  state: {  
    title: '大标题',  
    count: 100  
  },  
  mutations: {  
    // 修改count数据的方法  
    // 第一个参数：state    
    // 第二个参数：自定义的业务传递参数
    // 注意：提交参数只能一个，如果有多个参数，包装成一个对象传递
    addCount (state, n) {  
      state.count += n
    }  
  }  
})
```

##### 2. 组件中提交调用 mutations

```js
const num = 5
this.$store.commit('addCount', num)
```

### 17.4.6 辅助函数：mapMutations（优化 mutations）

在通过 `mutations` 修改时，需要在组件内部定义一个方法，方法里面调用 `this.$store.commit('xxx')` 过于繁琐

因此，可以通过 `mapMutations` 进行简化

`mapMutations` 和 `mapState` 很像，它是把位于 `mutations` 中的方法提取了出来，映射到组件 `methods` 中

```js
import { mapMutations } from 'vuex'  
  
export default {  
  name: 'Son2Com',  
  methods: {  
    ...mapMutations(['subCount'])  
  }  
}  
```

```html
// 可以直接调用，参数会被传递到 mutations 的指定方法的参数中
<div @click="subCount(1)"></div>
```

### 17.4.7 核心概念：actions（处理异步操作）

#### 定义

`actions` 用来处理异步操作，比如：在1秒钟后，修改 `state.count` 为 666

**注意**：

1. 不能直接使用 `mutations`，因为 **`mutations` 中的代码必须是同步的**，以下代码是**不允许的**：

```js
mutations: {  
  editCount (state, num) {  
    setTimeout(() => {  
      state.count = num  
    }, 1000)  
  }  
}
```

2. `actions` 中不能直接操作 `state`，`state` 只能由 `mutations` 进行修改
#### 语法

##### 1. 提供 actions 方法

```js
const store = new Vuex.Store({  
	// ....
	mutations: {  
		editCount (state, num) {  
		  state.count = num  
		}  
	},  
	actions: {  
		// count：上下文  
		// num：额外参数  
		changeCountAsync (context, num) {  
			setTimeout(() => {  
				context.commit('editCount', num)  
			}, 1000)  
		}  
	}  
})
```

##### 2. 调用 actions 方法

```js
<script>  
export default {  
	name: 'Son1Com',  
	methods: {  
		handleChange () {  
		// 调用 actions      
		this.$store.dispatch('changeCountAsync', 666)  
	}  
}  
</script>
```

### 17.4.8 辅助函数：mapActions（优化 actions）

`mapActions` 和 `mapMutations` 类似，`mapActions` 是把位于 **`actions` 中的方法**提取了出来，映射到**组件 `methods`** 中

```js
import { mapActions } from 'vuex'

export default {  
  name: 'Son2Com',  
  methods: {  
    ...mapActions(['changeCountAsync'])  
  }  
}  
```

```html
// 直接调用
<div @click="changeCountAsync(888)"></div>
```

### 17.4.9 核心概念：getters（派生 state）

除了 `state` 之外，有时我们还需要从 `state` 中**派生出一些状态**，这些状态是依赖 s`state` 的，此时会用到 `getters`

#### 场景

`state` 中定义了 list，为 1-10 的数组，组件中，需要显示所有大于5的数据

```js
state: {
	list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
}
```

#### 语法

##### 1. 定义 getters

```js
getters: {  
	// 第一个参数为 state
	filterList (state) {  
		return state.list.filter(item => item > 5)  
	}  
}
```

##### 2. 获取 getters 数据

```js
<label>{{ $store.getters.filterList }}</label>
```

### 17.4.10 辅助函数：mapGetters（优化 getters）

`mapGetters` 和 `mapState` 类似，`mapGetters` 是把 `getters` 中的数据**自动**映射到**组件的 `computed` 属性**中

```js
computed: {  
  ...mapGetters(['filterList'])  
}
```

```html
<label>{{ filterList }}</label>
```

## 17.5 进阶语法：模块 module

### 17.5.1 为什么需要模块

由于 Vuex 使用**单一状态树**，应用的所有状态会**集中到一个比较大的对象**。当应用变得非常复杂时，store  对象就有可能变得相当臃肿。当项目变得越来越大的时候，Vuex 会变得越来越难以维护

```js
const store = new Vuex.Store({  
	state: {
		...
	},
	mutations: {
		...
	},
	actions: {
		...
	},
	getters: {
		...
	}
})
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230914110430.png)

### 17.5.2 拆分步骤

#### 1. 创建各自模块的js文件

##### `src/store/modules/user.js`

```js
// user 模块  
const state = {  
  userInfo: {  
    name: 'michiko',  
    age: 18  
  },  
  score: 100  
}  
const mutations = {}  
const actions = {}  
const getters = {}  
  
export default {  
  state,  
  mutations,  
  actions,  
  getters  
}
```

##### `src/store/modules/setting.js`

```js
// setting 模块  
const state = {  
  theme: 'light',  
  desc: 'setting模块'  
}  
const mutations = {}  
const actions = {}  
const getters = {}  
  
export default {  
  state,  
  mutations,  
  actions,  
  getters  
}
```

#### 2. `src/store/index.js` 引入子模块

```js
import user from '@/store/modules/user'  
import setting from '@/store/modules/setting'

const store = new Vuex.Store({  
	// ...
	modules: {  
		user,  
		setting  
	}  
	// ...
})
```

### 17.5.3 访问子模块 state

尽管已经分模块了，但其实子模块的 state，还是会挂到根级别的 state 中，属性名就是模块名

#### 语法一：直接通过模块名访问 

```js
$store.state.模块名.xxx
```

#### 语法二：通过 mapState 映射

`mapState(['xxx'])` 默认是根级别的映射，如果需要子模块的映射**需要在子模块JS开启命名空间**

##### 1. 开启命名空间

```js
export default {
	namespaced: true,
	state: {
		...
	},
	mutations: {
		...
	},
	actions: {
		...
	},
	getters: {
		...
	}
}
```

##### 2. mapState 映射

```js
computed: {  
  ...mapState('模块名', ['属性名1', '属性名2', ...])
}
```

##### 3. 获取数据

```html
<span>{{ 属性名 }}</span>
```



### 17.5.4 访问子模块 getters

访问子模块 getters 和 访问子模块 state 类似

#### 语法一：直接通过模块名访问 

```js
$store.getters['模块名/xxx']
```

#### 语法二：通过 mapGetters 映射

`mapGetters(['xxx'])` 默认是根级别的映射，如果需要子模块的映射**需要在子模块JS开启命名空间**

##### 1. 开启命名空间

```js
export default {
	namespaced: true,
	state: {
		...
	},
	mutations: {
		...
	},
	actions: {
		...
	},
	getters: {
		...
	}
}
```

##### 2. mapGetters 映射

```js
computed: {  
  ...mapGetters('模块名', ['属性名1', '属性名2', ...])
}
```

##### 3. 获取数据

```html
<span>{{ 属性名 }}</span>
```

### 17.5.5 调用子模块 mutations

默认模块中的 `mutations` 会被挂载到全局，需要开启命名空间，才会挂载到子模块。

#### 语法一：直接通过模块名调用

```js
$store.commit('模块名/xxx', 额外参数)
```

#### 语法二：通过 mapMutations 映射

`mapMutations(['xxx'])` 默认是根级别的映射，如果需要子模块的映射**需要在子模块JS开启命名空间**

##### 1. 开启命名空间

```js
export default {
	namespaced: true,
	state: {
		...
	},
	mutations: {
		...
	},
	actions: {
		...
	},
	getters: {
		...
	}
}
```

##### 2. mapMutations 映射

```js
method: {  
  ...mapMutations('模块名', ['方法名1', '方法名2', ...])
}
```

##### 3. 调用方法

```html
<span @click="方法名"></span>
```

### 17.5.6 调用子模块 actions

默认模块中的 `actions` 会被挂载到全局，需要开启命名空间，才会挂载到子模块。

#### 语法一：直接通过模块名调用

```js
$store.dispatch('模块名/xxx', 额外参数)
```

#### 语法二：通过 mapActions 映射

`mapActions(['xxx'])` 默认是根级别的映射，如果需要子模块的映射**需要在子模块JS开启命名空间**

##### 1. 开启命名空间

```js
export default {
	namespaced: true,
	state: {
		...
	},
	mutations: {
		...
	},
	actions: {
		...
	},
	getters: {
		...
	}
}
```

##### 2. mapActions 映射

```js
method: {  
  ...mapActions('模块名', ['方法名1', '方法名2', ...])
}
```

##### 3. 调用方法

```html
<span @click="方法名"></span>
```

# 附录

## 1 Tab栏切换高亮

```html
<!DOCTYPE html>  
<html lang="en">  
<head>  
  <meta charset="UTF-8">  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">  
  <title>Document</title>  
  <style>    * {  
      margin: 0;  
      padding: 0;  
    }  
    ul {  
      display: flex;  
      border-bottom: 2px solid #e01222;  
      padding: 0 10px;  
    }  
    li {  
      width: 100px;  
      height: 50px;  
      line-height: 50px;  
      list-style: none;  
      text-align: center;  
    }  
    li a {  
      display: block;  
      text-decoration: none;  
      font-weight: bold;  
      color: #333333;  
    }  
    li a.active {  
      background-color: #e01222;  
      color: #fff;  
    }  
  
  </style>  
</head>  
<body>  
  
  <div id="app">  
    <ul>  
      <li v-for="(item, index) in list" :key="item.id">  
        <a :class="{ active:  index === activeIndex}" href="#" @click="activeIndex = index">{{ item.name }}</a>  
      </li>  
    </ul>  
  </div>  
  <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>  
  <script>    const app = new Vue({  
      el: '#app',  
      data: {  
        // 记录高亮下标  
        activeIndex: 0,  
        list: [  
          { id: 1, name: '京东秒杀' },  
          { id: 2, name: '每日特价' },  
          { id: 3, name: '品类秒杀' }  
        ]  
      }  
    })  
  </script>  
</body>  
</html>
```

## 2 Json-server

### 2.1 定义

>在 30 秒内获得零编码的完整假 REST API

Json-server 是一个`零代码快速搭建本地 RESTful API 的工具`。它使用 `JSON 文件作为数据源`，并提供了一组简单的路由和端点，可以模拟后端服务器的行为。

### 2.2 使用步骤

#### 1. 安装

```bash
npm install -g json-server
```

#### 2. 创建 JSON 文件

```json
{
  "posts": [
    { "id": 1, "title": "json-server", "author": "typicode" }
  ],
  "comments": [
    { "id": 1, "body": "some comment", "postId": 1 }
  ],
  "profile": { "name": "typicode" }
}
```

#### 3. 启动 JSON 服务器

```bash
json-server --watch db.json
```

#### 4. 访问 API 地址，获取得到相应的 JSON

现在如果访问 <http://localhost:3000/posts/1>，会得到：

```json
{ "id": 1, "title": "json-server", "author": "typicode" }
```

| 请求方式 | 地址   | 说明 |
| -------- | ------ | ---- |
| GET      | /posts | 获取所有信息     |
| GET      | /posts/1 | 获取id为1的数据     |
| POST      | /posts | 插入数据     |
| PUT      | /posts/1 | 修改id为1的数据     |
| PATCH      | /posts/1 | **修改id为1的部分数据，body传什么字段就修改什么字段**     |
| DELETE      | /posts/1 | 删除id为1的数据     |
