# 1 什么是 Node.js

## 1.1 定义

Node.js 是一个跨平台 JavaScript 运行环境，使开发者可以搭建服务器端的 JavaScript 应用程序。

>Node.js 为何能执行 JavaScript？

浏览器能执行 JavaScript 代码，依靠的是内核中的V8引擎（C++程序），而 Node.js 是基于 Chrome V8 引擎进行封装（运行环境）

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230902144259.png)

**注意**：Node.js 环境没有 DOM 和 BOM 等

## 1.2 作用

编写数据接口，提供网页资源浏览功能等等

# 2 Node.js 安装

安装略

>查看 Node.js 版本

```bash
node -v
```

# 3 使用 Node.js

```bash
node test.js
```

# 4 fs 模块-读写文件

>模块：类似插件，封装了**方法 / 属性**

fs模块：封装了与本机文件系统进行交互的，方法/属性

## 4.1 语法

### 4.1.1 **加载** fs 模块对象

```js
// fs 是模块标志符：模块的名字
const fs = require('fs')
```

### 4.1.2 **写入**文件内容

```js
// 如果写入成功, err 没有值
// 若写入失败，err  未错误信息
fs.writeFile('文件路径', '写入内容', err => {
	// 写入后的回调函数
})
```

### 4.1.3 **读取**文件内容

```js
// err：错误信息
// data：文件内容的 Buffer 数据流
fs.readFile('文件路径', (err, data) => {
	// 读取后的回调函数
})
```

### 4.1.4 完整示例

```js
const fs = require('fs')  
// 写入文件  
fs.writeFile('./test.txt', 'Hello, Node.js', err => {  
    if (err) console.log(err)  
    else console.log('写入成功')  
})  
// 读取文件  
fs.readFile('./test.txt', (err, data) => {  
    if (err) console.log(err)  
    else console.log(data.toString())  
})
```

# 5 path 模块-路径处理

Node.js 代码中，相对路径是根据**终端所在路径**来查找的，可能无法找到你想要的文件

## 5.1 问题

```js
const fs = require('fs')  
fs.readFile('./test.txt', (err, data) => {  
    if (err) console.log(err)  
    else console.log(data.toString())  
})
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230902154226.png)

## 5.2 解决

在 Node.js 代码中，使用**绝对路径**

- `__dirname`：获取当前模块目录-绝对路径

- `path.join()`：使用**特定于平台**的分隔符，作为定界符，将所有给定的路径片段连接在一起

```js
path.join('03', 'dist/js', 'index.js')
// windows：'03\dist\js\index.js'
// mac：'03/dist/js/index.js'
```

## 5.3 语法

### 5.3.1 加载 path 模块

```js
const path = require('path')
```

### 5.3.2 拼接路径

```js
path.join('路径1', '路径2'[, ..., '路径n'])
```

```js
const fs = require('fs')  
const path = require('path')  
fs.readFile(path.join(__dirname, '../6. Node.js/test.txt'), (err, data) => {  
    if (err) console.log(err)  
    else console.log(data.toString())  
})
```

### 5.3.3 完整示例

```js
const fs = require('fs')  
const path = require('path')  
fs.readFile(path.join(__dirname, '../6. Node.js/test.txt'), (err, data) => {  
    if (err) console.log(err)  
    else console.log(data.toString())  
})
```

# 6 http 模块-创建 Web 服务

## 6.1 步骤

1. 加载 http 模块，创建 Web 服务对象
2. 监听 request 请求事件，设置响应头和响应体
3. 配置端口号并启动 Web 服务

## 6.2 例子

```js
// 1. 加载 http 模块  
const http = require('http');  
const serve = http.createServer()  
// 2. 监听 request 请求事件，设置响应头和响应体  
serve.on('request', (req, res) => {  
    // 设置响应头-内容类型-普通文本以及中文编码格式  
    res.setHeader('Content-Type', 'text/plain;charset=utf-8')  
    // 设置响应体内容，结束每次请求与响应  
    res.end('欢迎访问Http模块创建的Web服务')  
})  
// 3. 配置端口号并启动 Web 服务  
serve.listen(3001, () => {  
    console.log('Web服务启动成功')  
})
```

# 7 Node.js 模块化

## 7.1 什么是模块化

CommonJS 模块是为 Node.js 打包 JavaScript 代码的原始方式。Node.js 还支持浏览器和其他 JavaScript 运行时使用的 ECMAScript 模块标准。**在 Node.js 中，每个文件都被视为一个单独的模块。**

项目是由很多个模块文件组成的，模块化提高代码复用性，按需加载，独立作用域

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230902165905.png)

## 7.2 CommonJS 标准

### 7.2.1 导出语法

```js
module.exports = {
	k1: v1,
	k2: v2
	...
}
```

```js
const baseUrl = 'http://test.com'  
const getArraySum = function (arr) {  
    return arr.reduce((sum, item) => sum += item, 0)  
}  
  
module.exports = {  
    url: baseUrl,  
    arraySum: getArraySum  
}
```
### 7.2.2 导入语法

```js
// 当需要导入内置模块（例如：fs，path，http）时，可以直接写模块名
// 当需要导入自定义模块：写模块文件路径（例如：./utils.js）
require('模块名与路径')
```

```js
const utils = require('./utils.js')  
console.log(utils.arraySum([1, 2, 3]));
```

## 7.3 ECMAScript 标准

注意：**Node.js默认支持CommonJS标准语法，如果需要使用 ECMAScript 标准语法，在运行模块所在文件夹新建 package.json 文件，并设置 `{"type":"module"}`**

### 7.3.1 默认导出/导入

#### 导出语法

```js
export default {}
```

```js
const baseUrl = 'http://test.com'  
const getArraySum = function (arr) {  
    return arr.reduce((sum, item) => sum += item, 0)  
}  
  
export default {  
    url: baseUrl,  
    arraySum: getArraySum  
}
```

#### 导入语法

```js
import 变量名 from '模块名或路径'
```

```js
import utils from './utils.js'  
console.log(utils.arraySum([1, 2, 3]));
```

### 7.3.2 命名导出/导入

#### 导出语法

`export 修饰定义语句`

```js
export const baseUrl = 'http://test.com'  
export const getArraySum = function (arr) {  
    return arr.reduce((sum, item) => sum += item, 0)  
}
```

#### 导入语法

`import {同名变量} from '模块名或路径'`

```js
import {getArraySum} from './utils.js'  
console.log(getArraySum([1, 2, 3]));
```

```js
import {getArraySum} from './utils.js'  
console.log(getArraySum([1, 2, 3]));
```

## 7.4 如何选择 CommonJS标准 和 ECMAScript标准

- **按需加载**，使用命名导出和导入
- **全部加载**，使用默认导出和导入

# 8 包

将模块，代码，其他资料聚合成一个文件夹，这个文件夹成为包

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230902182829.png)

## 8.1 包分类

- 项目包：主要用于编写项目和业务逻辑
- 软件包：**封装工具和方法**进行使用

**要求**：根目录中，必须有 `package.json` 文件（记录包的清单信息）
**注意**：导入软件包时，引入的默认是 `index.js` 模块文件 / main 属性指定的模块文件

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230902183104.png)

## 8.2 自定义软件包

>文件目录

- `server.js`：导入并软件包模块
- `utils`：软件包
	- `lib`：软件包所包含的模块
		- `arr.js`：数组模块
		- `str.js`：字符串模块
	- `package.json`：指定包的清单信息

```
├── server.js
└── utils
    ├── index.js
    ├── lib
    │   ├── arr.js
    │   └── str.js
    └── package.json
```

>`arr.js`

```js
const getArraySum = arr => arr.reduce((sum, arr) => sum += item, 0)  
  
module.exports = {  
    getArraySum  
}
```

>`str.js`

```js
const checkUserName = username => username.length >= 8  
const checkPassword = password => password.length >= 6  
module.exports = {  
    checkUser: checkUserName,  
    checkPassword: checkPassword  
}
```

>`index.js`

```js
/**  
 * 本文件是 .utils 工具包的唯一出口  
 * 作用：把所有工具模块方法集中起来，统一向外暴露  
 */  
const getArraySum = require('./lib/arr.js')  
const { checkUser, checkPassword } = require('./lib/str.js')  
  
module.exports = {  
    getArraySum,  
    checkUser,  
    checkPassword  
}
```

>`package.json`

```json
{  
  "name": "utils",  
  "version": "1.0.0",  
  "dependencies": "一个数组和字符串常用工具方法的包",  
  "main": "index.js",  
  "author": "michiko",  
  "license": "MIT"  
}
```

>`server.js`

```js
/**  
 * 目标：导入 utils 软件包，使用里面封装的工具函数  
 */  
const obj = require('./utils')  
console.log(obj)
```

# 9 npm - 软件包管理器

`npm` 是 Node.js 标准的软件包管理器。

在2017年1月时，npm仓库中就已有超过350000个软件包，这使其成为世界上最大的单一语言代码仓库，并且可以确定几乎有可用于一切的软件包。

它起初是作为下载和管理 Node.js 包依赖的方式，但其现在也已成为前端 JavaScript 中使用的工具。

## 9.1 使用 npm

>1. 初始化清单文件

得到package.json文件：`npm init -y`

（如果已经有 package.json，则可以略过）

>2. 下载软件包

`npm i 软件包名称`

软件包下载后将会放在 `node_modules` 目录下

>3. 使用软件包

## 9.2 案例-使用 dayjs 软件包

```bash
# 生成 package.json 文件
npm init -y
// 下载 dayjs 软件包
npm i dayjs
```

运行完后，目录结构如下：

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230902215645.png)


- `package.json` 中将会有一个 `dependencies` 对象，其值为 `"dayjs": "^1.11.9"`
- `node_modules` ：用于存放软件包
- `package-lock.json`：用于存放软件包版本信息

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230902220422.png)

## 9.3 npm - 安装所有依赖

当我们拿到一个新的项目时，项目中通常不会包含有 `node_modules`，没有 `node_modules` 就无法启动项目，所以我们需要将项目中的所依赖的所有软件包都下载下来

```bash
npm i
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230902220321.png)

## 9.4 npm - 全局软件包 nodemon

### 9.4.1 本地软件包与全局软件包

软件包区别：

- 本地软件包：**当前项目**内使用，封装**属性和方法**，存在于node_modules
- 全局软件包：**本机**所有项目使用，封装**命令和工具**，存在于系统设置的位置

### 9.4.2 nodemon 介绍

nodemon 作用：替代node命令，检测代码更改，自动重启程序

### 9.4.3 安装与使用 nodemon

#### 安装

```bash
npm i nodemon -g（-g 代表安装到全局环境中）
```

#### 运行

```bash
nodemon 待执行的目标 js 文件
```

## 9.5 npm 常用命令

| 功能                | 命令              |
| ------------------- | ----------------- |
| 执行 js 命令        | node xxx          |
| 初始化 package.json | npm init -y       |
| 下载本地软件包      | npm i 软件包名    |
| 下载全局软件包      | npm i 软件包名 -g |
| 删除软件包          | npm uni 软件包名  |
| 运行命令          | npm run 命令                  |

# 10 Webpack

>官网：<https://www.webpackjs.com/concepts/>

本质上，webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用
程序时，它会在内部从一个或多个入口点构建一个依赖图（dependency graph），然后将你项目中所
需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。

- 静态模块：指的是编写代码过程中的 html，css，js 图片等固定内容的文件
- 打包：把静态模块内容，压缩，整合，转译等（前端工程化）
	- 把less/sass转成css代码
	- 把ES6+降级成ES5
	- 支持多种模块标准语法

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230903101649.png)

## 10.1 Webpack 使用

>需求：封装 utils 包，校验手机号长度和验证码长度，在 src/index.js 中使用并打包观察

步骤：

1. 新建并初始化项目，编写业务源代码

```bash
# --save-dev 表示这个包在 dev 环境下使用
npm i webpack -cli --save-dev
```

2. 下载 `webpack webpack-cli` 到当前项目中（版本独立），并配置局部自定义命令

```bash
# build 为自定义命令，可以随便写
# webpack 表示我们在运行自定义命令后，终端实际要执行的命令
"scripts": {
	"build": "webpack"
}
```

3. 运行**打包**命令，自动产生dist分发文件夹（压缩和优化后，用于最终运行的代码）

```bash
npm run build
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230903102135.png)

![](https://raw.githubusercontent.com/michik0/notes-image/master/20230903104412.png)

## 10.2 修改 Webpack 打包入口和输出

### 10.2.1 入口（entry）

**入口起点(entry point)** 指示 webpack 应该使用哪个模块，来作为构建其内部依赖图（dependency graph）的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。

默认值是 `./src/index.js`，但你可以通过在 `webpack configuration` 中配置 `entry` 属性，来指定一个（或多个）不同的入口起点。例如：

```js
module.exports = {
  entry: './path/to/my/entry/file.js',
};
```

### 10.2.2 输出（output）

**output** 属性告诉 webpack 在哪里输出它所创建的 _bundle_，以及如何命名这些文件。主要输出文件的默认值是 `./dist/main.js`，其他生成文件默认放置在 `./dist` 文件夹中。

你可以通过在配置中指定一个 `output` 字段，来配置这些处理过程：

```js
const path = require('path');

module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'my-first-webpack.bundle.js',
  },
};
```

在上面的示例中，我们通过 `output.filename` 和 `output.path` 属性，来告诉 webpack bundle 的名称，以及我们想要 bundle 生成到哪里。

### 10.2.3 配置 Webpack 打包入口和出口

1. 项目根目录，新建 `webpack.config.js`

2. 导出配置对象，配置入口，输出文件的路径

3. 重新打包观察

注意：**只有和入口产生直接 / 间接的引入关系，才会被打包**

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230904181851.png)

## 10.3 Webpack 自动生成 html

**由于 Webpack 默认只识别 js 代码**，所以我们可以依靠插件用来生成HTML

插件 [html-webpack-plugin](https://www.webpackjs.com/plugins/html-webpack-plugin/#root) 能够在Webpack打包时生成html文件

### 10.3.1 步骤

1. 下载 `html-webpack-plugin` 本地软件包

```bash
npm install html-webpack-plugin --save-dev
```

2. 配置 `webpack.config.js`，让 Webpack 拥有插件功能

```js
const HtmlWebpackPlugin = require('html-webpack-plugin');
const path = require('path');

module.exports = {
  entry: 'index.js',
  output: {
    path: path.resolve(__dirname, './dist'),
    filename: 'index_bundle.js',
  },
  plugins: [  
    new HtmlWebpackPlugin({  
        template: path.resolve(__dirname, 'public/login.html'),    // 模板文件  
        filename: path.resolve(__dirname, 'dist/login/index.html')  // 输出文件  
    })  
]
};
```

3. 观察

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230904180856.png)

## 10.4 打包 CSS 代码

**由于 Webpack 默认只识别 js 代码，所以我们需要利用插件来解析 CSS**

- [css-loader](https://www.webpackjs.com/loaders/css-loader/#root) 用来解析 CSS 代码
- [style-loader](https://www.webpackjs.com/loaders/style-loader/#root)用来将 Style 代码插入 DOM 中

### 10.4.1 步骤

1. 准备 css 文件代码引入到 入口文件（比如，src/login/index.js） 中（压缩转译处理等)

```js
import './index.css'
```

2. 下载 `css-loader` 和 `style-loader` 本地软件包

```bash
npm i css-loader style-loader --save-dev
```

3. 配置 `webpack.config.js` 让 `Webpack` 拥有该加载器功能

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: ["style-loader", "css-loader"],
      },
    ],
  },
};
```

4. 打包观察结果

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230904203816.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230904203910.png)

## 10.5 优化 - 提取 CSS 代码

单独打包CSS文件的优点：

- 文件可以被浏览器缓存
- 减少jS文件体积

插件 [mini-css-extract-plugin](https://www.webpackjs.com/plugins/mini-css-extract-plugin/#root) 可以用来提取css代码

### 10.5.1 步骤

1. 下载 `mini-css-extract-plugin` 本地软件包

```bash
npm install  mini-css-extract-plugin --save-dev
```

2. 配置 `webpack.config.js` 让 `Webpack` 拥有该插件功能

```js
const MiniCssExtractPlugin = require("mini-css-extract-plugin");

module.exports = {
  plugins: [new MiniCssExtractPlugin()],
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: [MiniCssExtractPlugin.loader, "css-loader"],
      },
    ],
  },
};
```

3. 打包后观察效果

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230904210453.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230904210611.png)

## 10.6 优化 - CSS 压缩

在 [[#10.5 优化 - 提取 CSS 代码]] 中，表面上看 CSS 压缩，但是我们自己写的 CSS 还没被压缩过，如图：

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230904211037.png)

为了解决 CSS 代码提取后没有压缩的问题，我们可以使用 [css-minimizer-webpack-plugin](https://www.webpackjs.com/plugins/css-minimizer-webpack-plugin/#root) 插件

### 10.6.1 步骤

1. 下载 `css-minimizer-webpack-plugin` 本地软件包

```bash
npm install css-minimizer-webpack-plugin --save-dev
```

2. 配置 `webpack.config.js` 让 `webpack` 拥有该功能

```js
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const CssMinimizerPlugin = require("css-minimizer-webpack-plugin");

module.exports = {
  module: {
    rules: [
      {
        test: /.s?css$/,
        use: [MiniCssExtractPlugin.loader, "css-loader", "sass-loader"],
      },
    ],
  },
  optimization: {
    minimizer: [
      // 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer
      //（即 `terser-webpack-plugin`），如果没有 ... 则之前的 JS 压缩代码会失效
      `...`,
      new CssMinimizerPlugin(),
    ],
  },
  plugins: [new MiniCssExtractPlugin()],
};
```

3. 打包重新观察

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230905105525.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230905105641.png)

## 10.7 打包 less 代码

`less-loader` 插件可以把 less 代码编译为 css 代码

### 10.7.1 步骤

1. 安装 `less` 与 `less-loader`

```bash
npm install less less-loader --save-dev
```

1. 入口文件引入 less

```js
import './index.less'
```

2. 将 `less-loader` 配置到 `webpack.config.js` 让 `webpack` 拥有该功能

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.less$/i,
        use: [
          // compiles Less to CSS
          // 注意，如果采用了 MiniCssExtractPlugin.loader，需要把 'style-loader' 替换为 MiniCssExtractPlugin.loader，因为他们两个无法一起使用
          'style-loader',
          'css-loader',
          'less-loader',
        ],
      },
    ],
  },
};
```

## 10.8 打包图片

由于 Webpack5 内置资源模块（字体，图片等）打包，所以无需额外 loader

### 10.8.1 步骤

1. 配置 `webpack.config.js` 让 `Webpack` 拥有打包图片功能

```js
module.exports = {
  module: {
   rules: [
      {
        // 打包哪些文件
        test: /\.(png|jpg|gif)$/i,
        // 资源模块打包类型
        // asset表示：根据资源大小由 Webpack 自动进行判断打包方式
	    //    - 如果资源大小大于8KB，那么发送一个单独的文件并导出URL地址，参考<https://raw.githubusercontent.com/michik0/notes-image/master/20230905113143.png>
	    //    - 如果资源大小小于8KB：导出一个data URI(base64字符串)，参考<https://raw.githubusercontent.com/michik0/notes-image/master/20230905113349.png>
	    type: 'asset',
        generator: {
	        // 导出位置
	        // 占位符 [hash] 对模块内容做算法计算，得到映射的数字字母组合的字符串
			// 占位符 [ext] 使用当前模块原本的占位符，例如：，png/jpg等字符串
			// 占位符 [quey] 保留引入文件时代码中查询参数（只有URL下生效）
	        filename: 'assets/[hash][ext][query]'
        }
      },
   ]
  },
}
```

2. 入口文件引入本地图片

>如果是网络图片，那么可以直接通过 `<img src="xxx">` 打包到 HTML 中

```js
import imgObj from './assets/logo.png'  
const theImg = document.createElement('img')  
theImg.src = imgObj  
document.querySelector('.login-wrap').appendChild(theImg)
```

2. 打包观察

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230905115419.png)



