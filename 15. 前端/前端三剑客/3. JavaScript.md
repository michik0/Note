# 1 JavaScript 介绍

## 1.1 JavaScript 是什么

### 1.1.1 定义

是一种运行在客户端（浏览器）的编程语言，实现人机交互效果。

### 1.1.2 作用

- 网页特效：监听用户的一些行为让网页作出对应的反馈
- 表单验证：针对表单数据的合法性进行判断
- 数据交互：获取后台的数据，渲染到前端
- 服务端编程：`node.js`

### 1.1.3 组成

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230730223916.png)

>ECMAScript：

规定了JS基础语法核心知识。比如：变量、分支语句、循环语句、对象等等

>Web APIs：

DOM：操作文档，比如对页面元素进行移动、大小、添加删除等操作
BOM：操作浏览器，比如页面弹窗，检测窗口宽度、存储数据到浏览器等等

## 1.2 JavaScript 书写位置

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230730224730.png)

### 1.2.1 内部 JavaScript

直接写在 html 文件里，用 script 标签包住

#### 规范

script标签写在 `</body>` 上面

#### 拓展

`alert('你好，js')` 页面弹出警告对话框

#### 注意事项

我们将 `<script>` 放在HTML文件的底部附近的原因是浏览器会按照代码在文件中的**顺序加载**HTML。

如果先加载的JavaScript期望修改其下方的HTML，那么它可能由于HTML尚未被加载而失效。

因此，将JavaScript代码放在HTML页面的底部附近通常是最好的策略。

### 1.2.2 外部 JavaScript

代码写在以.js结尾的文件里

#### 语法

通过script标签，引入到html页面中。

```css
<body>
  <script src="js/my.js"></script>
</body>
```

#### 注意事项

1. **script标签中间无需写代码，否则会被忽略!**
2. 外部JavaScript会使代码更加有序，更易于复用，且没有了脚本的混合，HTML也会更加易读，因此这是个好的习惯。

### 1.2.3 内联 JavaScript

代码写在标签内部

#### 语法

```html
<body>
	<button onclick="alert('hi')">按钮</button>
</body>
```

#### 注意

此处作为了解即可，但是后面vue框架会用这种模式

## 1.3 JavaScript 怎么写

### 1.3.1 注释

#### 单行注释

- 符号：//
- 作用：//右边这一行的代码会被忽略

#### 块注释

- 符号：`/**/`
- 作用：在 `/*` 和 `*/` 之间的所有内容都会被忽略

### 1.3.2 结束符

- **作用**：使用英文的；代表语句结束
- **实际情况**：实际开发中，可写可不写，浏览器可以自动推断语句的结束位置
- **现状**：在实际开发中，越来越多的人主张，书写 JavaScript 代码时省略结束符
- **约定**：为了风格统一，结束符要么每句都写，要么每句都不写

## 1.4 JavaScript 输入输出语法

### 1.4.1 输出语法

#### document.write

`document.write`：向body内输出内容，如果输出的内容写的是标签，也会被解析成网页元素

```js
document.write('输出内容')
```

#### alert

`alert`：页面弹出警告对话框

```js
alert('弹窗内容')
```

#### console.log

`console.log`：控制台输出语法

```js
console.log('控制台打印')
```

### 1.4.2 输入语法

`prompt`：显示一个对话框，对话框中包含一条文字信息，用来提示用户输入文字

```js
prompt('请输入您的姓名')
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230731205109.png)

## 1.5 代码执行顺序

- 按HTML文档流顺序执行JavaScript代码
- `alert()` 和 `prompt()` 它们会跳过页面渲染先被执行

# 2 变量

## 2.1 变量是什么

- 白话：变量就是一个装东西的盒子。

- 通俗：变量是计算机中用来存储数据的“容器”，它可以让计算机变得有记忆。

>变量不是数据本身，它们仅仅是一个用于存储数值的容器。

## 2.2 变量的基本使用

### 2.2.1 声明变量

要想使用变量，首先需要创建变量（也称为声明变量或者定义变量）

```js
let 变量名
```

声明变量有两部分构成：声明关键字、变量名（标识）

let 即关键字，所谓关键字是系统提供的专门用来声明（定义）变量的词语

### 2.2.2 声明多个变量

多个变量中间用逗号隔开

```js
let 变量名1, 变量名2
```

### 2.2.3 变量赋值

```js
变量名 = 值
```

定义了一个变量后，你就能够初始化它（赋值）。在变量名之后跟上一个 "="，然后是数值。

### 2.2.4 声明并赋值

```js
let 变量名1 = 值1, 变量名2 = 值2
```

看上去代码长度更短，但并不推荐这样。为了更好的可读性，请一行只声明一个变量。

## 2.3 变量的本质

**内存**：计算机中存储数据的地方，相当于一个空间

变量本质：是程序在内存中申请的一块用来存放数据的小空间

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230731212600.png)

## 2.4 变量命名规则与规范

### 2.4.1 规则

- 不能用关键字，关键字：有特殊含义的字符，JavaScript 内置的一些英语词汇，let、var、if、for 等
- 只能用下划线、字母、数字、$组成，且数字不能开头
- 字母严格**区分大小写**，如 Age 和 age 是不同的变量

### 2.4.2 规范

- 起名要有意义
- 遵守小驼峰命名法，第一个单词首字母小写，后面每个单词首字母大写，例如：userName

## 2.5 拓展：let 和 var 的区别

在较旧的 JavaScript，使用关键字var来声明变量，而不是let。

var现在开发中一般不再使用它，只是我们可能再老版程序中看到它。 let为了解决var的一些问题。

var声明：

- 可以先使用在声明（不合理）
- var声明过的变量可以重复声明（不合理）
- 比如变量提升、全局变量、没有块级作用域等等

## 2.6 数组

数组(Array) ：一种将一组数据存储在单个变量名下的优雅方式

### 2.6.1 声明语法

```js
// 方式一
let 数组名 = [数据1, 数据2, ..., 数据n]
// 方式二
let 数组名 = new Array(数据1, 数据2, ..., 数据n)
```

- 数组是按顺序保存，所以每个数据都有自己的编号
- 计算机中的编号从0开始
- 在数组中，数据的编号也叫索引或下标

### 2.6.2 取值语法

```js
数组名[下标]
```

通过下标取数据，取出来是什么类型的，就根据这种类型特点来访问

### 2.6.3 术语

- **元素**：数组中保存的每个数据都叫数组元素
- **下标**：数组中数据的编号
- **长度**：数组中数据的个数，通过数组的length属性获得

### 2.6.4 新增元素

#### push()

push 方法将一个或多个元素添加到**数组的末尾**，并**返回该数组的新长度**

```js
arr.push(元素1, 元素2, ... 元素n])
```

#### unshift()

unshift 方法将一个或多个元素添加到**数组的开头**，并**返回该数组的新长度**

### 2.6.5 删除元素

#### pop()

pop 方法从数组中删除**最后一个元素**，并返回该元素的值

```js
arr.pop()
```

#### shift()

shift 方法从数组中删除**第一个元素**，并返回该元素的值

```js
arr.shift()
```

#### splice()

splice 方法从数组中删除**指定个数**的元素，返回删除元素的值，如果多个将返回数组

```js
// 若省略个数，则删除到数组末尾
arr.splice(起始位置[，需要删除的元素个数])
```

### 2.6.6 数组排序

#### 升序

```js
let arr = [5, 4, 3, 2, 1]
// 返回 [1, 2, 3, 4, 5]
arr.sort()
```

#### 降序

```css
let arr = [1, 2, 3, 4, 5]
// 返回 [5, 4, 3, 2, 1]
arr.sort(function (a, b) {
      return b - a
})
```

### 2.6.7 迭代数组：map()

map 可以遍历数组处理数据，并且**返回新的数组**

```js
const arr = ['red', 'blue', 'green']
const newArr = arr.map(function(ele, index) {
  // 数组元素
  console.log(ele)
  // 数组索引号
  console.log(index)
  return ele + '颜色'
})
// ['red颜色', 'blue颜色', 'green颜色']
console.log(newArr)
```

### 2.6.8 数组所有元素转换为一个字符串：join()

joi()方法用于把数组中的所有元素转换一个字符串

```js
const arr = ['red颜色', 'blue颜色', 'green颜色']
// 'red颜色,blue颜色,green颜色'
console.log(arr.join(','))
```

### 2.6.9 数组遍历：foreach()

forEach()方法用于调用数组的每个元素，并将元素传递给回调函数，**只遍历，返回数组**

```js
数组.forEach(function(当前元素, 当前元素索引)) {
	// 函数体
}
```

>注意

1. forEach()主要是遍历数组
2. 参数当前数组元素是必须要写的，索引号可选。

### 2.6.10 数组筛选：filter()

```js
const arr = [1, 2, 3]  
const newArr = arr.filter((value) => {  
  return value >= 2  
});  
// [2, 3]
console.log(newArr)
```

# 3 常量

## 3.1 概念

使用 const 声明的变量称为"常量"

## 3.2使用场景

当某个变量**永远不会改变**的时候，就可以使用 const 来声明，而不是let

## 3.3 命名规范

和变量一致

## 3.4 常量使用

```js
const G = 9.8
```

## 3.5 注意

常量不允许重新赋值，声明的时候必须赋值（初始化）

>拓展

准确来说，应该是 const 修饰的遍历不允许有地址的变化，例如，以下的语法是正确的：

```js
// arr变量所指向的地址不变，变化的只是堆中的数组元素，因此可以用 const 修饰
const arr = []
arr.push('test')
```

```js
// obj变量所指向的地址不变，变化的只是堆中的对象元素，因此可以用 const 修饰
let obj = {}
obj.uname = 'michiko'
```

>为什么 const 声明的对象可以修改里面的属性？

- 因为对象是引用类型，里面存储的是地址，只要地址不变，就不会报错
- **建议数组和对象使用 const 来声明**

>const 和 let 如何选择？

- 如果基本数据类型的值或者引用类型的地址发生变化的时候，需要用 let
- 比如一个变量进行加减运算，比如 for 循环中的 i++

# 4 数据类型

JS数据类型整体分为两大类：

- 基本数据类型（值类型）

简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型，例如：string，number，boolean，undefined，null

- 引用数据类型

复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型
通过new关键字创建的对象（系统对象、自定义对象），例如：Object、Array、Date等

>堆栈空间分配区别：

1. 栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；**简单数据类型存放到栈里面**
2. 堆（操作系统）：存储复杂类型（对象），一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。**引用数据类型存放到堆里面**

## 4.1 基本数据类型

### 4.1.1 number 数字型

JavaScript 中的正数、负数、小数等统一称为数字类型。

JS 是弱数据类型，变量到底属于哪种类型，只有赋值之后，我们才能确认

```js
// 整数
let age = 18
// 小数
let price = 88.99
```

>NaN

NaN 代表一个计算错误，它是一个不正确的或者一个未定义的数学操作所得到的结果

以下结果会造成 NaN：

```js
console.log('老师' - 2)
```

NaN是粘性的，任何对NaN的操作都会返回NaN

```js
console.log(NaN + 2)
```

### 4.1.2 字符串类型

通过 单引号、双引号 或 反引号 包裹的数据都叫字符串

单引号和双引号没有本质上的区别，推荐使用单引号。

```js
let name = '小明'
let gender = "男"
let goods = `小米`
let str = ''
```

>注意事项

- 无论单引号或是双引号必须成对使用
- 单引号 / 双引号可以互相嵌套，但是不以自已嵌套自已
- 必要时可以使用转义符 `\` ，输出单引号或双引号

#### 字符串拼接

+运算符可以实现字符串的拼接。

```js
console.log('我的名字是:' + 'michiko')
console.log('我的年龄：' + '18')
```

#### 模版字符串

**以前：** 拼接字符串和变量，要拼接变量比较麻烦，需要用 `+` 号进行相连

**现在：** 只需要占位符即可

```js
document.write(`我今年${age}岁了`)
```

### 4.1.3 boolean 布尔类型

表示肯定或否定时在计算机中对应的是布尔类型数据。它有两个固定的值 true 和 false ，表示肯定的数据用 true（真），表示否定的数据用false（假）。

```js
boolean success = true
```

注意：**"、O、undefined、nul、false、NaN转换为布尔值后都是false，其余则为true**

### 4.1.4 undefined 未定义类型

未定义是比较特殊的类型，只有一个值 undefined。

>什么情况出现未定义类型？

只声明变量，不赋值的情况下，变量的默认值为undefined，一般很少直接为某个变量赋值为undefined。

```js
// 此时 num 未进行赋值，所以此时 num 为 undefined
let num
```

### 4.1.5 null 空类型

JavaScript 中的 null 仅仅是一个代表 "无"、"空" 或 "值未知" 的特殊值

```js
let num = null
```

>null 和 undefined 区别

- undefined 表示没有赋值
- null 表示赋值了，但是内容为空，官方解释：把 null 作为尚未创建的对象

## 4.2 检测数据类型

typeof 运算符可以返回被检测的数据类型。它支持两种语法形式：

```js
// 语法一
typeof x

// 语法二
typeof(x)
```

## 4.3 类型转换

### 4.3.1 为什么需要类型转换

JavaScript是弱数据类型，赋值了才能知道属于什么类型。**使用表单、prompt获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算**

```js
console.log('10000' + '2000') // 输出结果：100002000
```

### 4.3.2 隐式转换

某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。

#### 规则

`+` 号两边只要有一个是字符串，都会把另外一个转成字符串

**除了 + 以外的算术运算符**，比如 `- */` 等都会把数据转成数字类型

#### 小技巧

- **+号作为正号解析可以转换成数字型**

```js
// 输出 number
console.log(typeof +'123')
```

- **任何数据和字符串相加结果都是字符串**

### 4.3.3 显式转换

#### 转换为数字

编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。

##### Number(数据)

- 转成数字类型
- 如果字符串内容里有非数字，转换失败时结果为NaN，即不是一个数字
- NaN也是number类型的数据，代表非数字

```js
Number('123')
```

##### +(数据)

可以将数据直接转换为number类型

```js
+('123')
```

##### parseInt(数据)

保留整数

```js
parseInt('12')
```

##### parseFloat(数据)

保留小数

```js
parseFloat('12.94')
```

##### 转换为 Boolean

```json
Boolean(内容)
```

注意：**"、0 undefined、null、false、NaN转换为布尔值后都是false，其余则为true**

# 5 运算符

## 5.1 赋值运算符

赋值运算符能够对变量进行赋值

- `=`：将等号右边的值赋予给左边

```css
a = 1
```

- `+=`：将变量做加法后，重新复制给变量

```js
let a = 1;
// a变为2
a += 1
```

- `-=`：将变量做减法后，重新赋值给变量

```js
let a = 1;
// a变为0
a -= 0
```

- `*=`：将变量做乘法后，重新赋值给变量

```js
let a = 1;
// a变为2
a *= 2
```

- `/=`：将变量求商后，重新赋值给变量

```js
let a = 5;
// a变为2
a /= 2
```

- `%=`：将变量求余后，重新赋值给变量

```js
let a = 5;
// a变为1
a %= 2
```

## 5.2 一元运算符

根据所需表达式的个数，分为一元运算符、二元运算符、三元运算符，例如 `1+2` 为二元运算符

一元运算符：正负号

### 5.2.1 一元运算符

- `++`：变量的值+1
- `--`：变量的值-1

### 5.2.2 语法

```js
i++
i--
```

```js
++i
--i
```

**i++ 和 ++i 什么区别？**

- `i++` 先做运算，后进行自增
- `++i`：先做自增，后做运算。

```js
let i = 1
// 输出1，先打印log，后i++
console.log(i++)
// 输出3，先++i，后打印log
console.log(++i)
```

## 5.3 比较运算符

- `>`：左边是否大于右边
- `<`：左边是否小于右边
- `>=`：左边是否大于或等于右边
- `<=`：左边是否小于或等于右边
- `==`：左右两边值是否相等
- **`===`：左右两边是否类型和值都相等**
- `!==`：左右两边是否不全等

>字符串比较

字符串比较，是比较的字符对应的ASCII码，从左往右依次比较，如果第一位一样再比较第二位，以此类推

>注意

- **不同类型之间比较会发生隐式转换，最终把数据隐式转换转成number类型再比较。**
- **开发中判断是否相等，强烈推荐使用`===`**
- **NaN不等于任何值，包括它本身，涉及到NaN，结果都为false**
- **尽量不要比较小数，小数有精度问题**

## 5.4 逻辑运算符

逻辑运算符用来解决多重条件判断

| 符号 | 名称   | 特点                       |                              |
| ---- | ------ | -------------------------- | ---------------------------- |
| `&&` | 逻辑与 | 两边都为true，结果才为true |                              |
| `\|`                          | 逻辑或                       | 两边有一个为true，结果就为true|
| `!`  | 逻辑非 | 取反                       | true变为false，false变为true |

## 5.5 逻辑运算符里的短路

短路只存在于&&和‖中，当满足一定条件会让右边代码不执行

| 符号 | 短路条件          |
| ---- | ----------------- |
| &&   | 左边为false时短路 |
| \|\| | 左边为true时短路 |

注意：**'', 0, undefined, null, false, NaN 均为 false，其余为 true**

注意：**无论&&还是‖，运算结果都是最后被执行的表达式值，一般用在变量赋值**

```js
let age = 18
console.log(false && age++)
// age为18
console.log(age)
```

```js
let age = 18
console.log(true || age++)
// age为18
console.log(age)
```

>拓展

```js
// 输出22
console.log(11 && 22)
// 输出11
console.log(11 || 22)
```

>应用

```js
function (x, y) {
	// 当x为undefined时，x=0
	x = x || 0
	// 当y为undefined时，y=0
	y = y || 0
}
```

## 5.6 运算符优先级

| 优先级 | 运算符     | 顺序                      |
| ------ | ---------- | ------------------------- |
| 1      | 小括号     | ()                        |
| 2      | 一元运算符 | `++` `--` `!`             |
| 3      | 算数运算符 | 先 `*` `/` `%` 后 `+` `-` |
| 4      | 关系运算符 | `>` `>=` `<` `<=`         |
| 5      | 相等运算符 | `==`  `!=`  `===`  `!==`  |
| 6      | 逻辑运算符 | 先 `&&` 后 `\|\|`         |
| 7      | 赋值运算符 | `=`                       |
| 8      | 逗号运算符 | `,`                       |

# 6 语句

## 6.1 表达式和语句

>表达式

表达式是可以被求值的代码， JavaScript引擎会将其计算出一个结果。

```js
x = 7
3+4
num++
```

>语句

语句是一段可以执行的代码，比如 `prompt()`，`alert()`

>语句和表达式的区别

- 表达式：因为表达式可被求值，所以它可以写在赋值语句的右侧，例如 `num=3+4`
- 语句不一定有值，所以有些语句不一定能用于赋值，比如 `alert()`，但是也有语句能够赋值，比如 `prompt()`

## 6.2 分支语句

分支语句可以让我们有选择性的执行想要的代码

### 6.2.1 if 语句

if 语句有三种使用：单分支、双分支、多分支

#### 单分支

```js
if (条件) {
	// 满足条件的代码
}
```

- 括号内的条件为true时，进入大括号里执行代码
- 小括号内的结果若不是布尔类型时，会发生隐式转换转为布尔类型
- **`''`、`null`，`0` 为 false，其余都为 true**

#### 双分支

```js
if (条件) {
	// 满足条件的代码
} else {
	// 不满足条件的代码
}
```

#### 多分支

适合于有多个结果的时候，比如学习成绩可以分为：优良中差

```js
if (条件1) {
	// 代码1
} else if (代码2) {
	// 代码2
} else if (代码3) {
	// 代码3
} else {
	// 代码 n
}
```

- 先判断条件1，若满足条件1就执行代码1，其他不执行
- 若不满足则向下判断条件2，满足条件2执行代码2，其他不执行
- 若依然不满足继续往下判断，依次类推
- 若以上条件都不满足，执行else里的代码n

### 6.2.2 三元运算符

比 if 双分支更简单的写法，可以使用三元表达式

#### 语法

```js
条件 ? 满足条件执行的代码 : 不满足条件执行的代码
```

#### 使用场景

三元运算符通常用于取值

```js
max = num1 > num2 ? num1 : num2
```

### 6.2.3 switch 语句

#### 语法

```js
switch (数据) {
	case 值1: 
		代码1
		break
	case 值2: 
		代码2
		break
	default:
		代码n
		break
}
```

找到跟小括号里数据全等的case值，并执行里面对应的代码若没有全等`===`，的则执行default里的代码

#### 注意

- switch case语句一般用于等值判断，不适合于区间判断
- switch case一般需要配合break关键字使用，没有break会造成case穿透

### 6.2.4 if 和 switch 的区别

#### 共同点

都能实现多分支选择，大部分情况下可以互换

#### 区别

- switch...case 语句通常处理为比较**确定值**的情况，而if...else...语句更加灵活，通常用于**范围判断**
- switch 语句进行判断后直接执行到程序的语句，效率更高，而if...slse语句有几种判断条件，就得判断多少次
- switch 必须是 `===` 全等，一定注意数据类型，并且如果未 break 会有穿透效果

- **当分支比较少时：if...else 语句执行效率高。**
- **当分支比较多时：switch 语句执行效率高，而且结构更清晰。**

## 6.3 循环语句

### 6.3.1 断点调试

>浏览器开启断点调试

F12 -> 源代码 -> 代码文件

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230802231535.png)

### 6.3.2 while 循环

while循环能在满足条件期间，重复执行某些代码。比如我们输出5次Hello World。

#### 语法

```js
while (循环条件) {
	// 重复执行的代码
}
```

while大括号里代码执行完毕后不会跳出，而是继续回到小括号里判断条件是否满足，若满足又执行大括号里的代码，然后再回到小括号判断条件，直到括号内条件不满足，即跳出。

#### 循环三要素

1. 变量起始值
2. 终止条件（没有终止条件，循环会一直执行，造成死循环）
3. 变量变化量（自增或者自减）

```js
let i = 1
while (i <= 3) {
	console.log('hello!')
	i++
}
```

### 6.3.3 退出循环

- break：退出循环
- continue：结束本次循环，继续下一次循环

```js
while (条件1) {
	if (条件2) continue
	if (条件3) break
}
```

### 6.3.4 for 语句

#### 语法

```js
for (变量起始值; 终止条件; 变量变化量) {
	// 循环体
}
```

# 7 函数

## 7.1 为什么需要函数

>函数

function，是被设计为**执行特定任务**的代码块

>说明

函数可以把具有相同或相似逻辑的代码"包裹"起来，通过函数调用执行这些被"包裹"的代码逻辑，这么做的优势是有利于
**精简代码方便复用**。

## 7.2 函数使用

>声明

```js
function 函数名() {
	请求体
}
```

>函数名命名规范

- 和变量命名基本一致
- 尽量小驼峰式命名法
- 前缀应该为动词

| 动词 | 含义                   |
| ---- | ---------------------- |
| can  | 判断是否可执行某个动作 |
| has  | 判断是否含义某个值     |
| is   | 判断是否为某个值       |
| get  | 获取某个值             |
| set  | 设置某个值             |
| load | 加载某些数据 |

>使用

```js
函数名()
```

**注意**：声明(定义)的函数必须调用才会真正被执行，使用()调用函数**

## 7.3 函数传参

```js
function 函数名(参数1[, 参数2, 参数3 ... , 参数n]) {
	函数体
}
```

### 7.3.1 形参和实参

```js
// num1、num2：形参
function getSum(num1, num2) {
	document.write(num+num2)
}

// 1、100：实参
getSum(1, 100)
```

形参：声明函数时写在函数名右边小括号里的叫形参(形式上的参数)
实参：调用函数时写在函数名右边小括号里的叫实参(实际上的参数)

形参可以理解为是在这个函数内声明的变量(比如 num1=10)实参可以理解为是给这个变量赋值

### 7.3.2 参数默认值

>思考

Q：形参可以看做变量，但是如果一个变量不给值，默认是什么？

A：undefine，如果做用户不输入实参，undefine + undefine = NaN

>改造一：利用短路与和短路或

```js
function getSum(num1, num2) {
	num1 = num1 || 0
	num2 = num2 || 0
	document.write(num+num2)
}

// 1、100：实参
getSum(1, 100)
```

>改造二

我们可以改进下，用户不输入实参，可以给形参默认值，可以默认为0，这样程序更严谨，可以如下操作：

```js
function getSum(num1 = 0, num2 = 0) {
	document.write(num+num2)
}

// 1、100：实参
getSum(1, 100)
```

**注意**：这个默认值只会在缺少实参参数传递时才会被执行，所以有参数会优先执行传递过来的实参，否则默认为undefined

## 7.4 函数返回值

当调用某个函数，这个函数会返回一个结果。

当函数需要返回数据出去时，用 `return` 关键字

```js
function fn() {
	return 返回值
}
```

- 在函数体中使用return关键字能将内部的执行结果交给函数外部使用
- **return后面代码不会再被执行，会立即结束当前函数**
- **return函数可以没有return，这种情况函数默认返回值为undefined**

## 7.5 函数细节补充

- 两个相同的函数后面的会覆盖前面的函数
- 在Javascript中实参的个数和形参的个数可以不一致
  - 形参过多：会自动填上undefined(了解即可)
  - 实参过多：多余的实参会被忽略(面数内部有一个arguments，里面装着所有的实参)
- 函数一旦碰到return就不会在往下执行了函数的结束用return

## 7.6 作用域

通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的**作用域**。

作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230811151753.png)

>特殊情况

如果函数内部，变量没有声明，直接赋值，也当全局变量来看，但是**强烈不推荐**

```js
function test() {
	num = 10
}
test()
// 输出10
console.log(num)
```

>变量访问原则

- 只要是代码，就至少有一个作用城
- 写在函数内部的局部作用城
- 如果面数中还有函数，那么在这个作用域中就又可以诞生一个作用域
- 访问原则：**就近原则（在能够访问到的情况下先局部，局部没有在找全局）**

## 7.7 匿名函数

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230811154008.png)

### 7.7.1 匿名函数

匿名函数：没有名字的函数，无法直接使用。

匿名函数包括：

- 函数表达式
- 立即执行函数

### 7.7.2 函数表达式

将匿名函数赋值给一个变量，并且通过变量名称进行调用我们将这个称为函数表达式

>声明

```js
let fn = function([参数1, 参数2, ..., 参数n]) {
	// 函数体
}
```

>调用

```js
fn([参数1, 参数2, ... , 参数n])
```

>使用场景

后期Web API会使用

```js
let btn = document.querySelector('button')
btn.onclick = function () {
	alert('我是匿名函数')
}
```

```js
let btn = document.querySelector('button')
btn.addEventListener(function () {
	alert('我是匿名函数')
})
```

### 7.7.3 立即执行函数

立即执行函数：避免局部变量之间的污染

>语法一

```js
(function [函数名]() {
	console.log('hi!')
})()
```

>语法二

```js
(function [函数名]() {
	console.log('hi!2')
}())
```

**注意**：多个立即执行函数在一起则一定要以分号(;)结尾

# 8 对象

## 8.1 什么是对象

对象是JavaScript里的一种数据类型，可以理解为是一种无序的数据集合，注意数组是有序的数据集合

## 8.2 对象声明

```js
let 对象名 = {
	属性名: 属性值,
	方法名: 函数
}
```

### 8.2.1 对象中的属性

- 数据描述性的信息称为属性，如人的姓名、身高、年龄、性别等，一般是名词性的。
- 属性都是成对出现的，包括属性名和值，它们之间使用 `:` 分隔
- 多个属性之间使用 `,` 分隔
- 属性就是依附在对象上的变量
- 属性名可以使用 `'` 或 `"`，一般情况下省略，除非名称遇到特殊符号如空格、中横线等

```js
let obj = {
	uname: 'michiko',
	age: 18,
	gender: male
}
```

### 8.2.2 对象中的方法

数据行为性的信息称为方法，如跑步、唱歌等，一般是动词性的，其本质是函数。

1. 方法是由方法名和函数两部分构成，它们之间使用 `:` 分隔
2. 多个属性之间使用英文 `,` 分隔
3. 方法是依附在对象中的函数
4. 方法名可以使用 `"` 或 `'` ，一般情况下省略，除非名称遇到特殊符号如空格、中横线等
5. 声明对象，并添加了若干方法后，可以使用 `.`
6. 调用对象中函数
7. 也可以添加形参和实参

```js
let obj = {
	sayHi: function(to) {
		document.write(`hi!${to}`)
	}
}
```

## 8.3 对象使用

### 8.3.1 查询对象

声明对象，并添加了若干属性后，可以使用 `.` 获得对象里面的属性值。

```js
对象.属性
```

```js
对象['属性']
```

### 8.3.2 属性赋值 / 增加属性

```js
对象.属性=值
```

### 8.3.3 删除属性（了解）

```js
delete 对象.属性
```

## 8.4 遍历对象

```js
let obj = {
  uname: 'michiko',
  age: 18,
  gender: 'male'
}
for (let k in obj) {
  console.log(k)
  console.log(obj[k])
}
```

- 一般不用这种方式遍历数组、主要是用来遍历对象
- for in语法中的k是一个变量，在循环的过程中依次代表对象的属性名
- 由于k是变量，所以必须使用 `[]` 语法解析

**注意：** k是获得对象的属性名，对象名 `[k]` 是获得属性值

## 8.5 对象简写形式

当对象中的属性名和值名一样时候，可以采用简写形式，比如：

```js
const name = 'michiko'
const age = 18

const obj = {
	// 相当于 name: name
	name,
	// 相当于 age: age
	age
}

```

## 8.5 内置对象

### 8.5.1 内置对象是什么？

JavaScript内部提供的对象，包含各种属性和方法给开发者调用

### 8.5.2 内置对象-Math

Math对象是JavaScript提供的一个"数学"对象

- random()：生成0-1之间的随机数（包括0不包括1）
- ceil()：向上取整
- floor()：向下取整
- max()：找最大数
- min()：找最小数
- pow()：幂运算
- abs()：绝对值

### 8.5.3 内置对象-生成任意范围随机数

random()：生成0-1之间的随机数（包括0不包括1）

>生成0-10的随机数

```js
Math.floor(Math.random() * (10 + 1))
```

>生成5-10的随机数

```js
Math.floor(Math.random() * (5 + 1)) + 5
```

>生成N-M之间的随机数

```js
Math.floor(Math.random() * (M - N + 1)) + N
```

# 9 Web API 基本认识

## 9.1 作用和分类

- 作用：就是使用JS去操作 html 和浏览器
- 分类：DOM（文档对象模型）、BOM（浏览器对象模型）

## 9.2 DOM

### 定义

DOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML 文档交互的API，DOM 是浏览器提供的一套专门用来操作网页内容的功能

### 作用

开发网页内容特效和实现用户交互

## 9.3 DOM树

将HTML文档以树状结构直观的表现出来，我们称之为文档树或DOM树，描述网页内容关系的名词，**文档树直观的体现了标签与标签之间的关系**

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230812150518.png)

## 9.4 DOM对象

>定义

DOM对象：浏览器根据 html 标签生成的 JS 对象

- 所有的标签属性都可以在这个对象上面找到
- 修改这个对象的属性会自动映射到标签身上

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230812151456.png)

>核心思想

把网页内容当做**对象**来处理

>document 对象

document 是 DOM 里提供的一个**对象**

document 提供的属性和方法都是**用来访问和操作网页内容的**，例如： `document.write()`

网页所有内容都在document里面

## 9.5 获取DOM对象

查找元素DOM元素就是利用JS选择页面中标签元素

### 9.5.1 根据 CSS 选择器来获取 DOM 元素

#### 1. 选择匹配的第一个元素

>语法

```js
document.querySelector('css选择器')
```

>参数

包含一个或多个有效的CSS选择器**字符串**

>返回值

CSS选择器匹配的**第一个元素**，是一个 HTMLElement 对象。

如果没有匹配到，则返回 null

#### 2. 选择匹配多个元素

>语法

```js
document.querySelectorAll('css选择器')
```

>参数

包含一个或多个有效的CSS选择器**字符串**

>返回值

CSS选择器匹配的NodeList对象集合

我们得到的是一个 **伪数组**：

- 有长度有索引号的数组
- 没有 pop()，push() 等数组方法

想要得到里面的每一个对象，则需要遍历（for）的方式获得。

### 9.5.2 其他获取 DOM 元素方法（了解）

>根据id获取一个元素

```js
document.getElementById('nav')
```

>根据标签获取一类元素获取页面所有div

```js
document.getElementsByTagName('div')
```

>根据类名获取元素获取页面所有类名为w的元素

```js
document.getElementsByClassName('w')
```

## 9.6 操作元素内容

DOM对象都是根据标签生成的，所以操作标签，本质上就是操作DOM对象。如果想要修改标签元素的里面的内容，则可以使用如下几种方式：

### 9.6.1 innerText 属性

innerText 将文本内容添加/更新到任意标签位置，**显示纯文本，不解析标签**

```js
const box = document.querySelector('.box')
box.innerText = '我是一个盒子'
```

### 9.6.2 innerHTML 属性

将文本内容添加/更新到任意标签位置，**会解析标签，多标签建议使用模板字符**

```js
const box = document.querySelector('.box')
box.innerText = '<strong>我是一个盒子</strong>'
```

## 9.7 操作元素属性

### 9.7.1 操作元素常用属性

可以通过JS设置/修改标签元素属性，比如通过src更换图片

>语法

```js
对象.属性 = 值
```

```js
// 1. 获取元素
const pic = document.querySelector('img')
// 2. 操作元素
pic.src = './images/b02.jpg'
pic.title = 'Switch'
```

### 9.7.2 操作元素样式属性

可以通过JS设置/修改标签元素的样式属性。比如：

- 通过轮播图小圆点自动更换颜色样式
- 点击按钮可以滚动图片
- 移动的图片的位置left等等

#### 通过 style 属性操作 css

>语法

```js
对象.style.样式属性 = 值
```

>注意

如果出现属性中带有 `-`，需要改为小驼峰，比如 `box.style.backgroundColor = 'red'`

#### 操作类名(className)操作css

如果修改的样式比较多，直接通过style属性修改比较繁琐，我们可以通过借助于css类名的形式。

>语法

```js
元素.className = 'active'
```

>注意

- 由于class是关键字，所以使用className去代替
- **className是使用新值换旧值，如果需要添加一个类，需要保留之前的类名**

#### 通过 classList 操作类控制 css

为了解决className容易覆盖以前的类名，我们可以通过classList方式追加和删除类名

```js
// 追加一个类
元素.classList.add('类名')
// 删除一个类
元素.classList.remove('类名')
// 切换一个类（如果存在该类，那么就删除该class，如果没有，那么就新增该样式）
元素.classList.toggle('类名')
```

### 9.7.3 操作表单元素属性

表单很多情况，也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单类型转换为文本框

正常的有属性有取值的，跟其他的标签属性没有任何区别

>获取

DOM对象.属性名

```js
input.value
```

>设置

DOM对象.属性名 = 新值

```js
表单.value = '用户名'
表单.type = 'password'
```

### 9.7.4 自定义属性

- 在html5中推出了专门的 `data-` 自定义属性
- 在标签上一律以 `data-` 开头
- 在DOM对象上一律以 `dataset` 对象方式获取

>声明

```js
<div data-id="1">1</div>
```

>获取

```js
const firstDiv = document.querySelector('div')
console.log(firstDiv.dataset.id)
```

# 10 定时器-间歇函数

网页中经常会需要一种功能：每隔一段时间需要自动执行一段代码，不需要我们手动去触发

定时器函数可以开启和关闭定时器

## 10.1 开启定时器

>语法

```js
setInterval(函数, 间隔时间)
```

```js
setInterval(function () {
  console.log('一秒执行一次')
}, 1000)
```

每隔一段时间，调用这个函数，间隔时间单位是毫秒

>返回值

定时器返回的是定时器ID

## 10.2 关闭定时器

```js
clearInterval(定时器ID)
```

# 11 事件监听（绑定）

## 11.1 事件监听

>什么是事件？

事件是在编程时系统内发生的动作或者发生的事情，比如用户在网页上单击一个按钮

>什么是事件监听？

就是让程序检测是否有事件产生，一旦有事件触发，就立即调用一个函数做出响应，也称为绑定事件或者注册事件，比如鼠标经过显示下拉菜单，比如点击可以播放轮播图等等

>语法

```js
元素对象.addEventListener('事件类型', 执行函数)
```

>事件监听三要素

- 事件源：哪个 dom 元素被事件触发了，要获取 dom 元素
- 事件类型：用什么方式触发，比如鼠标单击 click、鼠标经过 mouseover 等
- 事件调用的函数：要做什么事

## 11.2 拓展-事件监听版本

>版本一

```js
事件源.on事件=function(){}
```

```js
btn.onclick=function() {
	alert('hi!')
}
```

>版本二（推荐）

```js
元素对象.addEventListener('事件类型', 执行函数)
```

>区别

on方式会被覆盖，addEventListener方式可绑定多次，拥有事件更多特性，推荐使用

# 12 事件类型

## 12.1 鼠标事件

鼠标触发

### 12.1.1 鼠标点击：click

```js
div.addEventListener('click', function () {
  console.log('鼠标点击')
})
```

### 12.1.2 鼠标经过：mouseenter

```js
div.addEventListener('mouseenter', function () {
  console.log('鼠标经过')
})
```

### 12.1.3 鼠标离开：mouseleave

```js
div.addEventListener('mouseleave', function () {
  console.log('鼠标离开')
})
```

### 12.1.4 鼠标经过：mouseover

当一个定点设备（通常指鼠标）在一个元素本身或者其子元素上移动时， `ouseover` 事件在该元素上触发。 在类似 `addEventListener()` 这样的方法中使用事件名称，或者设置事件处理器属性。

>mouseover 和 mouseenter 的区别

尽管与 `mouseover` 类似，但是 `mouseenter` 的不同之处在于当鼠标指针从它后代的物理空间移动到它自己的物理空间时，它不会冒泡，也不会发送给它的任何后代。单个 `mouseover` 事件被发送到 DOM 树最深的元素中，然后它会按层次结构冒泡，直到它被处理程序取消或者到达根元素。 由于层次结构很深，发送到 `mouseover` 事件可能相当多，并导致严重的性能问题。

### 12.1.5 鼠标内移动：mosemove

`mousemove` 事件在定点设备（通常指鼠标）的光标在元素内移动时，会在该元素上触发。

## 12.2 焦点事件

表单获取光标

### 12.2.1 获得焦点：focus

```js
input.addEventListener('focus', function () {
	console.log('焦点触发')
})
```

### 12.2.2 失去焦点：blur

```js
input.addEventListener('blur', function () {
	console.log('失去焦点')
})
```

### 12.2.3 值发生变化：change

当值发生变化时，才进行触发，与 `blur` 的区别： `blur` 是失去焦点一次就触发一次，而 `change` 是值变化一次才触发一次，值如果不变化将不触发

```js
input.addEventListener('change', function () {
	console.log('失去焦点')
})
```

## 12.3 键盘事件

键盘触发

### 12.3.1 键盘按下触发：keydown

```js
input.addEventListener('keydown', function () {
	console.log('键盘按下')
})
```

### 12.3.2 键盘抬起触发：keyup

```js
input.addEventListener('keyup', function () {
	console.log('键盘弹起')
})
```

## 12.4 文本事件

表单输入触发

```js
input.addEventListener('input', function () {
	console.log('文本事件')
})
```

## 12.5 页面加载事件

### 加载事件1：load

加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件

>为什么需要学？

- 有些时候需要等页面资源全部处理完了做一些事情
- 老代码喜欢把 script 写在 head 中，这时候直接找 dom 元素找不到

```js
// 页面加载事件
window.addEventListener('load', function(){
	// 执行的操作
	
})
```

```js
window.addEventListener('load', function () {
  document.querySelector('button').addEventListener('click', function () {
	console.log('按钮被点击')
  })
})
```

**注意**：不光可以监听整个页面资源加载完毕，也可以针对某个资源绑定load事件，比如 `img.addEventListener('load', function(){})`

### 加载事件2：DOMContentLoaded

当初始的HTML文档被完全加载和解析完成之后，DOMContentLoaded事件被触发，而无需等待样式表、图像等完全加载

```js
document.addEventListener('DOMContentLoaded', function(){
	// 执行的操作
})
```

## 12.6 页面滚动事件

滚动条在滚动时持续触发事件，**监听某个元素的内部滚动直接给某个元素加即可**

### 12.6.1 语法

```js
//页面滚动事專件
window.addEventListener('scroll', function (){ 
	// 执行的操作
})
```

### 12.6.2 获取位置

scrollLeft 和 scrollTop（属性）

- 获取被滑动的大小
- 获取元素内容往左、往上滚出去看不到的距离
- 这两个值是可读写的

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230816205654.png)

### 12.6.3 滚动到指定的坐标

>方式一

```js
// document.documentElement 是html获取元素的方式 
document.documentElement.scrollTop = 0
```

>方式二

`scrollTo()` 方法可把内容滚动到指定的坐标

```js
// 让元素滚动到y轴1000像素的位置，页面为 document.documentElement
元素.scrollTo(x, y)
```

### 12.6.3 实际应用

开发中，我们经常检测页面滚动的距离，比如页面滚动100像素，就可以显示一个元素，或者固定一个元素

```js
//页面滚动事件
window.addEventListener('scroll', function () { 
	// document.documentElement 是html获取元素的方式 
	const n = document.documentElement.scrollTop
	console.log(n)
})
```

## 12.7 页面尺寸事件

### 12.7.1 窗口尺寸改变的时候触发事件：size

```js
window.addEventListener('resize', function(){
	// 执行的代码
})
```

### 12.7.2 检测屏幕宽度

获取元素的可见部分宽高（不包含边框，margin，滚动条等）

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230816213548.png)

```js
window.addEventListener('resize', function(){
	let w = document.documentElement.clientWidth
	console.log(w)
})
```

### 12.7.3 元素尺寸与位置

#### 使用场景

- 前面案例滚动多少距离，都是我们自己算的，最好是页面滚动到某个元素，就可以做某些事。
- 简单说，就是通过js的方式，**得到元素在页面中的位置**
- 这样我们可以做，页面滚动到这个位置，就可以做某些操作，省去计算了

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230816214636.png)

#### 获取宽高：offsetWidth，offsetHeight

- 获取元素的自身宽高、包含元素自身设置的宽高，padding，border
- 返回值为数值，方便计算

```js
document.querySelector('.div').offsetWidth)

document.querySelector('.div').offsetHeight)
```

#### 获取位置：offsetLeft，offsetTop

获取元素距离自己**定位父级元素**的左、上距离

```js
document.querySelector('.div').offsetLeft)

document.querySelector('.div').offsetTop)
```

**注意**：offsetLeft，offsetTop是只读属性

#### 获取位置：getBoundingClientRect

getBoundingClientRect 返回元素的大小以及其相对于**视口**的位置，**随着页面的滑动，getBoundingClientRect 的返回值会变得不一样**

```js
element.getBoundingClientRect()
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230817204137.png)

## 12.8 视频事件

### 12.8.1 时间视频/音频播放位置发生改变时触发：ontimeupdate

`ontimeupdate` 事件在视频/音频当前的播放位置发生改变时触发，即每播放极短的时间（小于1秒）就会触发

```js
const video = document.querySelector('video');  
video.ontimeupdate = function () {  
  console.log('播放中...')  
}
```

>优化

由于触发频率太高，考虑使用[[#34 节流|节流]]

```js
const video = document.querySelector('video');  
video.ontimeupdate = _.throttle(() => {  
  console.log('播放中')  
}, 1000)
```

### 12.8.2 当前帧的数据加载完成且还没有足够的数据播放视频/音频下一帧时触发：onloadeddata

`onloadeddata` 事件在当前帧的数据加载完成且还没有足够的数据播放视频/音频时下一帧时触发

```js
video.onloadeddata = () => {  
  video.currentTime = +localStorage.getItem('time')  
}
```

# 13 事件对象

## 13.1 什么是事件对象

事件对象也是个对象，这个对象里有事件触发时的相关信，例如：鼠标点击事件中，事件对象就存了鼠标点在哪个位置等信息

## 13.2 使用场景

- 判断用户按下哪个键，比如按下回车键可以发布新闻，
- 判断鼠标点击了哪个元素，从而做相应的操作

## 13.3 获取事件对象

在事件绑定的回调函数的第一个参数就是事件对象，一般命名为 `event`、`ev`、`e`

```js
// e为事件对象
元素.addEventListener('click', function(e){

})
```

## 13.4 事件对象常用属性

- type：获取当前的时间类型
- clientX/clientY：获取光标相对于浏览器可见窗口左上角的位置
- offsetX/offsetY：获取光标相对于当前DOM元素左上角的位置
- key：用户按下的键盘键的值，现在不提倡使用keyCode（搭配键盘事件使用）

# 14 环境对象

环境对象指的是函数内部特殊的变量this，它代表着当前函数运行时所处的环境，环境对象能让代码变更加简洁

- 函数的调用方式不同，this指代的对象也不同
- 直接调用函数，其实相当于是 `window.函数`，所以 this 指代 window

**判断 this 指向的粗略规则**：谁调用，this 就是谁

```js
function fn() {
  console.log(this)
}
fn()
```

# 15 回调函数

如果将函数A做为参数传递给函数B时，我们称函数A为回调函数

>常用使用场景

- 定时器

```js
function fn() {
	console.log('我是回调函数')
}
// fn传递给了setInterval, fn就是回调函数
setInterval(fn, 1000)
```

- 事件监听

```js
box.addEventListener('click', function(){
	console.log('我是回调函数')
})
```

# 16 事件流

## 16.1 事件流与两个阶段说明

事件流指的是事件完整执行过程中的流动路径

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230815105041.png)

说明：假设页面里有个div，当触发事件时，会经历两个阶段，分别是捕获阶段、冒泡阶段
简单来说：捕获阶段是从父到子，冒泡阶段是从子到父

## 16.2 事件捕获

从DOM的根元素开始去执行对应的事件(从外到里)，事件捕获需要写对应代码才能看到效果

```js
// 第三个参数传入true代表是捕获阶段触发，默认为false
DOM.addEventListener(事件类型, 事件处理函数, 是否使用捕获机制)
```

以下例子中：

- 点击页面空白处：
  - 弹窗我是爷爷（触发document事件）
- 点击father：
  - 1. 我是爷爷（触发document事件）
  - 2. 我是爸爸（触发father事件）
- 点击页面空白处：
  - 1. 我是爷爷（触发document事件）
  - 2. 我是爸爸（触发father事件）
  - 2. 我是儿子（触发son事件）

```html
<body>
  <div class="father">
    <div class="son"></div>
  </div>
  <script>
    document.addEventListener('click', function () {
      alert('我是爷爷')
    }, true)
    document.querySelector('.father').addEventListener('click', function () {
      alert('我是爸爸')
    }, true)
    document.querySelector('.son').addEventListener('click', function () {
      alert('我是儿子')
    }, true)
  </script>
</body>
```

## 16.3 事件冒泡

当一个元素的事件被触发时，同样的事件将会在该元索的所有祖先元素中依次被触发，这一过程被称为事件冒泡

简单来说：当一个元素触发事件后，会依次向上调用所有父级元素的同名事件，**事件冒泡是默认存在的**

以下例子中：

- 点击页面空白处：
  - 弹窗我是爷爷（触发document事件）
- 点击father：
  - 1. 我是爸爸（触发father事件）
  - 2. 我是爷爷（触发document事件）
- 点击页面空白处：
  - 1. 我是儿子（触发son事件）
  - 2. 我是爸爸（触发father事件）
  - 3. 我是爷爷（触发document事件）

```html
<body>
  <div class="father">
    <div class="son"></div>
  </div>
  <script>
    document.addEventListener('click', function () {
      alert('我是爷爷')
    }, true)
    document.querySelector('.father').addEventListener('click', function () {
      alert('我是爸爸')
    }, true)
    document.querySelector('.son').addEventListener('click', function () {
      alert('我是儿子')
    }, true)
  </script>
</body>
```

## 16.4 阻止冒泡

因为默认就有冒泡模式的存在，所以容易导致事件影响到父级元素。若想把事件就限制在当前元素内，就需要阻止事件冒泡

```js
事件对象.stopPropagation()
```

```js
div.addEventListener('click', function(e) {
	alert('点击')
	e.stopPropagation()
})
```

此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效

## 16.5 阻止默认行为

我们某些情况下需要阻止默认行为的发生，比如 阻止 链接的跳转，表单域跳转

>语法

```js
document.querySelector('a').addEventListener('click', function (e) {
      e.preventDefault()
    })
```

## 16.6 解绑事件

### 1 解绑方式一

on事件方式，直接使用null覆盖就可以实现事件的解绑

```js
// 绑定事件
btn.onclick = function() {
	alert('点击')
}
// 解绑事件
btn.onclick = null
```

### 2 解绑方式二

```js
function fn() {
  alert('点击')
}
// 绑定事件
btn.addEventListener('click', fn)
// 解绑事件
btn.removeEventListener('click', fn)
```

**注意**：匿名函数无法被解绑

## 16.7 鼠标经过事件的区别

鼠标经过事件：

- mouseover 和 mouseout 会有冒泡效果
- mouseenter 和 mouseleave 没有冒泡效果（推荐）

## 16.8 两种事件的区别

- 传统 on 注册（L0）
  - 同一个对象，后面注册的事件会覆盖前面注册的（同一个）事件
  - 直接使用null覆盖就可以实现事件的解绑
  - 都是冒泡阶段执行的
- 事件监听的注册（L2）
  - 语法：`addEventListener(事件类型, 事件处理函数, 是否使用捕获)`
  - 后面注册的事件不会覆盖前面注册（同一个）事件
  - 可以通过第三个参数去确定是在冒泡或者捕获阶段执行
  - 必须使用 `removeEventListener(事件类型, 事件处理函数, 获取捕获或者冒泡阶段)` 进行解绑
  - 匿名函数无法被解绑

# 17 事件委托

## 17.1 为什么需要事件委托？

>思考：我们如何给多个元素注册事件？有没有什么技巧？

```html
<ul>
	<li>第一个li</li>
	<li>第二个li</li>
	<li>第三个li</li>
	<li>第四个小li</li>
	<li>第五个li</li>
</ul>
```

```js
const lis = document.querySelectorAll('ul li') 
for (let i = 0; i < lis.length; i++) {
	lis[i].addEventListener('click', function () { 
		alert('T')
	})
}
```

## 17.2 事件委托的好处

事件委托是利用事件流的特征解决一些开发需求的知识技巧

- 优点：减少注册次数，提高程序性能
- 原理：事件委托其实是利用事件冒泡的特点，给**父元素注册事件**，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230815205312.png)

## 17.3 语法

```js
// 点击每个li，li其中的文字变为红色
const ul = document.querySelector('ul')
ul.addEventListener('click', function (e) {
  // e.target.tagName：真正的触发元素
  if (e.target.tagName === 'LI') {
	e.target.style.color = 'red'
  }
})
```

# 18 日期对象

日期对象：用来表示时间的对象

作用：可以得到当前系统时间

## 18.1 实例化

在代码中发现了new关键字时，一般将这个操作称为**实例化**

>获得当前时间

```js
const date = new Date()
```

>获得指定时间

```js
const date = new Date('2023-08-18 23:40:40')
```

## 18.2 日期对象方法

因为日期对象返回的数据不能直接使用，所以需要转换为实际开发中常用的格式

| 方法          | 作用               | 说明                 |
| ------------- | ------------------ | -------------------- |
| getFullYear() | 获得年份           | 获取四位年份         |
| getMonth()    | 获得月份           | 取值为0-11           |
| getDate()     | 获取月份中的天数 | 不同月份取值也不相同（比如2023-08-18日期返回18） |
| getDay()      | 获取星期           | 取值为0-6            |
| getHours()    | 获取小时           | 取值为0-23           |
| getMinutes()  | 获取分钟           | 取值为0-59           |
| getSeconds()  | 获取秒             |  取值为0-59                    |

## 18.3 时间戳

### 18.3.1 什么是时间戳

是指1970年01月01日08时00分00秒起至现在的**毫秒数**，它是一种特殊的计量时间的方式

### 18.3.2 算法

- 将来的时间戳 - 现在的时间戳 = 剩余时间毫秒数（倒计时时间）

### 18.3.3 获取时间戳

>方式一

```js
new Date().getTime()
```

>方式二

```js
+new Date()
```

>方式三

```js
Date.now()
```

# 19 节点操作

## 19.1 DOM节点

DOM树里每一个内容都称之为节点

>节点类型

- 元素节点
  - 所有的标签比如 body、 div
  - html是根节点
- 属性节点：所有的属性，比如  href
- 文本节点：所有的文本
- 其他

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230819143500.png)

## 19.2 查找节点

### 19.2.1 父节点查找

获取子元素的父节点

```js
子元素.parentNode
```

### 19.2.2 子节点查找

#### childNodes 属性

获得所有子节点、包括文本节点(空格、换行)、注释节点等：

#### children 属性

选择父元素的亲儿子

- **仅获得所有元素节点**
- **返回的还是一个伪数组**

```js
父元素.children
```

### 19.2.3 兄弟关系查找

1. 下一个兄弟节点：nextElementSibling 属性
2. 上一个兄弟节点：previousElementSibling 属性

## 19.3 增加节点

很多情况下，我们需要在页面中增加元素，比如，点击发布按钮，可以新增一条信息

一般情况下，我们新增节点，按照如下操作:

- 创建一个新的节点
- 把创建的新的节点放入到指定的元素内部

### 19.3.1 创建节点

创建节点即创造出一个新的网页元素，再添加到网页内，一般先创建节点，然后插入节点

#### 创建元素节点方法

```js
document.createElement('标签名') 
```

#### 追加节点

要想在界面看到，还得插入到某个父元素中，插入到父元素的最后一个子元素：

>父元素最后一个子元素后插入

```js
父元素.appendChild(要插入的元素)
```

>插入到父元素中某个子元素的前面

```js
父元素.insertBefore(要插入的元素, 在哪个元素前面)
```

#### 克隆节点

```js
元素.cloneNode(布尔值)
```

cloneNode会克隆出一个跟原标签一样的元素，括号内传入布尔值

- 若为true，则代表克隆时会包含后代节点一起克隆
- 若为false，则代表克隆时不包含后代节点
- **默认为false**

## 19.4 删除节点

若一个节点在页面中已不需要时，可以删除它

### 19.4.1 通过父元素删除节点

```js
父元素.removeChild(要删除的元素)
```

>备注

删除节点和隐藏节点 `(display:none)` 有区别的：隐藏节点还是存在的，但是删除，则从html中删除节点

### 19.4.2 删除指定的节点

```js
要删除的节点.remove()
```

# 20 M端（移动端）事件

移动端也有自己独特的地方。比如触屏事件 touch (也称触摸事件)，Android 和 IOS 都有。

touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。

常见的触屏事件如下:

| 触屏touch事件 | 说明                          |
| ------------- | ----------------------------- |
| touchstart    | 手指触摸到一个DOM元素时触发   |
| touchmove     | 手指在一个DOM元素上滑动时触发 |
| touchend      | 手指从一个DOM元素上移开时触发 |

# 21 Window 对象

## 21.1 BOM 对象

BOM(Browser Object Model)是浏览器对象模型

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230820202015.png)

- window对象是一个全局对象，也可以说是JavaScript中的顶级对象
- 像document、alert()、console.log()这些都是window的属性，基本BOM的属性和方法都是window的。
- 所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法
- window对象下的属性和方法调用的时候可以省略window

## 21.2 定时器-延时函数

JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeout

>开启延迟函数

```js
setTimeout(回调函数, 等待的毫秒数)
```

setTimeout 仅仅只执行一次，所以可以理解为就是把一段代码延迟执行，平时省略 window

>清除延迟函数

```js
let timer = setTimeout(回调函数, 等待的毫秒数)
clearTimeout(timer)
```

>注意

- 延时器需要等待，所以后面的代码先执行
- 每一次调用延时器都会产生一个新的延时器

## 21.3 JS执行机制

JavaScript语言的一大特点就是**单线程**，也就是说，**同一个时间只能做一件事**。

这是因为Javascript这门脚本语言诞生的使命所致，JavaScript是为处理页面中用户的交互，以及操作DOM而诞生的。比如我们对某个DOM元素进行添加和删除操作，不能同时进行。应该先进行添加，之后再删除。

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是：如果jS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

为了解决这个问题，利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程。于是，JS中出现了同步和异步。

### 21.3.1 同步

前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后）再去切菜，炒菜。

同步任务都在主线程上执行，形成一个**执行栈**。

### 21.3.2 异步

你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。

**他们的本质区别:这条流水线上各个流程的执行顺序不同。**

JS的异步是通过回调函数实现的。一般而言，异步任务有以下三种类型:

- 普通事件，如click、resize等
- 资源加载，如load、error等
- 定时器，包括 setlnterval、setTimeout等

异步任务相关添加到**任务队列**中（任务队列也称为消息队列）

### 21.3.3 执行机制

1. **先执行执行栈中的同步任务**。
2. 异步任务放入任务队列中。
3. 一旦**执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务**，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230820204958.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230820205159.png)

由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（event loop)。

## 21.4 location 对象

location的数据类型是对象，它拆分并保存了URL地址的各个组成部分

常用属性和方法：

- href：获取完整的URL地址，对其赋值时用于地址的跳转
- search： 获取地址中携带的参数，符号 `?` 后面部分
- hash：获取地址中的哈希值，符号 `#` 后面部分
- reload：刷新当前页面（相当于F5刷新页面），传入参数 true 时表示强制刷新

## 21.5 navigator 对象

navigator的数据类型是对象，该对象下记录了浏览器自身的相关信息

常用属性和方法：

- 通过 userAgent 检测浏览器的版本以及平台

```js
// 检测 userAgent(浏览器信息) 
!(function () {
  const userAgent = navigator.userAgent
  // 验证是否为Android或iPhone
  const android = userAgent.match(/(Android);?[\s\/]+([\d.]+)?/) 
  const iphone = userAgent.match(/(iPhone\sOS)\s([\d_]+)/)
  // 如果是Android或iPhone，则跳转至移动站点 
  if (android || iphone) {
    location.href = 'http://www.baidu.com' 
  }
})();
```

## 21.6 history 对象

history的数据类型是对象，主要管理历史记录，该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等

常用属性方法

| 对象方法  | 作用     |
| --------- | -------- |
| back()    | 后退功能 |
| forward() | 前进功能 |
| go(参数)  | 前进后退功能，1代表前进一个页面，-1代表后退一个页面 |

# 22 本地存储

## 22.1 本地存储介绍

随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。

1. 数据存储在用户浏览器中
2. 设置、读取方便、甚至页面刷新不丢失数据
3. 容量较大，sessionStorage 和 localStorage 约5M左右

## 22.2 本地存储分类

### 22.2.1 localStorage

localStorage 可以将数据永久存储在本地（用户的电脑），除非手动删除，否则关闭页面也会存在。

#### 特点

1. 可以多窗口（页面）共享（同一浏览器可以共享）
2. 以键值对的形式存储使用

#### 语法

>存储数据 / 修改数据

```js
localStorage.setItem(key, value)
```

>获取数据

```js
localStorage.getItem(key)
```

>删除数据

```js
localStorage.removeItem(key)
```

#### 注意

本地存储只能存储字符串的数据类型，及时在存入的时候为数字类型，最后也会被转成字符串类型

### 22.2.3 sessionStorage

- 生命周期为关闭浏览器窗口
- 在同一个窗口（页面）下数据可以共享
- 以键值对的形式存储使用
- 用法跟localStorage基本相同

## 22.3 存储复杂数据类型

如果我们直接将对象存入复杂数据类型，那么会无法正常显示和使用

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230821092543.png)

要想正常使用，需要将复杂数据类型转换成JSON字符串，在存储到本地

>对象转为JSON字符串

```js
JSON.stringify(对象)
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230821092844.png)

>JSON字符串转为对象

```js
JSON.parse(JSON字符串)
```

# 23 正则表达式

## 23.1 介绍

正则表达式(Regular Expression)是用于匹字符串中字符组合的模式。在JavaScript中，正则表达式也是对象通常用来查找、替换那些符合正则表达式的文本，许多语言都支持正则表达式。

正则表达式在JavaScript中的使用场景，比如：

- 验证表单：用户名表单只能输入英文字母、数字或者下划线，昵称输入框中可以输入中文（**匹配**）
- 过滤掉页面内容中的一些敏感词（**替换**）
- 从字符串中获取我们想要的特定部分（**提取**）

## 23.2 语法

### 23.2.1 定义正则表达式规则语法

```js
// 其中 / / 是正则表达式字面量
const reg = /表达式/
```

### 23.2.2 判断是否符合正则表达式

test()方法在一个指定字符串中执行一个搜索匹配，如果匹配成功，返回一个true，否则返回false

```js
正则表达式.test(被检测的字符串)
```

### 23.2.3 检索（查找）符合规则的字符串

exec()方法在一个指定字符串中执行一个搜索匹配，如果匹配成功，返回一个数组，否则返回null

```js
正则表达式.exec(被检测的字符串)
```

### 23.2.4 字符串替换

replace() 方法可以替换符合正则表达式的字符串

```js
原文本.replace(/正则表达式/, '符合正则表达式，需要替换成的文本')
```

## 23.3 元字符

- 普通字符：大多数的字符仅能够描述它们本身，这些字符称作普通字符，例如所有的字母和数字。也就是说普通字符只能够匹配字符串中与它们相同的字符。
- 元字符（特殊字符）：是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能。
  - 比如，规定用户只能输入英文26个英文字母，普通字符的话只能将26个字母全部列举出来
  - 但是换成元字符写法就简便很多：[a-z]

>参考文档：

- MDN:<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions>
- 正则测试工具：<http://tooL.oschina.net/regex>

### 23.3.1 边界符

正则表达式中的边界符（位置符）用来**提示字符所处的位置**，主要有两个字符

| 边界符 | 说明                           |
| ------ | ------------------------------ |
| ^      | 表示匹配行首的文本（以谁开始） |
| $      | 表示匹配行尾的文本（以谁结束） |

### 23.3.2 量词

量词用来**设定某个模式出现的次数**

| 量词  | 说明          |
| ----- | ------------- |
| *     | 重复0次或多次 |
| +     | 重复1次或多次 |
| ?     | 重复0次或1次  |
| {n}   | 重复n次       |
| {n,}  | 重复n次或多次 |
| {n,m} | 重复n到m次 |

### 23.3.3 字符类

使用 `[]` 表示一个范围，字符串只要包含[]中任意一个字符，都返回true。

| 字符类   | 说明                                      |
| -------- | ----------------------------------------- |
| [a-z]    | 表示 a-z 包含26个字母都行                 |
| [A-Z]    | 表示 A-Z 包含26个字母都行                 |
| [a-zA-Z] | 表示包含 a-z 和 A-Z 包括52个字母都行，包括大小写 |
| [0-9]    | 表示 0-9 的数字都行 |

>取反：^

`[]` 里面加上 `^` 表示取反，比如：[^a-z]匹配除了小写字母以外的字符

>匹配换行符之外的任何单个字符

`.` 匹配除换行符之外的任何单个字符

### 23.3.4 预定义类

预定义类：指的是某些常见模式的简写方式。

| 预定义类 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| \d       | 匹配0-9之间的任一数字，相当于[0-9]                           |
| \D       | 匹配所有0-9以外的字符，相当干[^0-9]                          |
| \w       | 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]             |
| \W       | 除所有字母、数字和下划线以外的字符，相当于 [^A-Za-z0-9_]     |
| \s       | 匹配空格（包括换行符、制表符、空格符等），相等于[\t\r\n\v\f] |
| \S       | 匹配非空格的字符，相当于[^\t\r\n\v\f] |

日期格式：`/^\d{4}-\d{1,2}-\d{1,2}/`

## 23.4 修饰符

修饰符约束正则执行的某些细节行为，如是否区分大小写、是否支持多行匹配等

```js
/正则表达式/修饰符1[修饰符2...修饰符3]s
```

```js
// 输出 I'm good!
'I\'m OK!'.replace(/ok/ig, 'good')
```

修饰符有以下两种：

- i：忽略大小写。例如，正则表达式 `/apple/i` 会匹配"apple"、"Apple"、"APple"等。
- g：全局匹配。默认情况下，正则表达式只匹配字符串中的第一个匹配项。使用修饰符 `g` 可以实现全局匹配，即匹配所有符合规则的项。
- m：多行匹配。默认情况下，正则表达式只匹配字符串的开头和结尾。使用修饰符 `m` 可以实现多行匹配，即匹配每行的开头和结尾。
- s：允许换行符。默认情况下，正则表达式中的.匹配除了换行符之外的任何字符。使用修饰符 `s` 可以让.匹配包括换行符在内的所有字符。
- x：忽略空格和注释。正则表达式中的空格和注释并不会被忽略，而是作为正则表达式的一部分。使用修饰符 `x` 可以忽略空格和注释，使得正则表达式更易于理解和维护。

# 24 作用域

作用域（scope）规定了变量能够被访问的"范围"，离开了这个"范围"变量便不能被访问，作用域分为局部作用域和全局作用域

## 24.1 局部作用域

局部作用域分为函数作用域和块作用域

### 24.1.1 函数作用域

在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。

```js
function getSum() {
  // 局部变量
  const num = 10
}
// 报错
console.log(num)
```

- 函数内部声明的变量，在函数外部无法被访问
- 函数的参数也是函数内部的局部变量
- 不同函数内部声明的变量无法互相访问
- 函数执行完毕后，函数内部的变量实际被清空了

### 24.1.2 块作用域

在JavaScript中使用{}包裹的代码称为代码块，代码块内部声明的变量外部将 **【有可能】** 无法被访问。

```js
for (let t = 1; t <= 6; t++) {
  // t 只能在该代码块中被访问
  console.log(t)  // 正常
}
// 超出 t 的作用域
console.log(t)  // 报错
```

- let声明的变量会产生块作用域，var不会产生块作用域
- const声明的常量也会产生块作用域
- 不同代码块之间的变量无法互相访问
- 推荐使用let或const

## 24.2 全局作用域

`<script>` 标签和js文件的 **【最外层】** 就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。全局作用域中声明的变量，任何其它作用域都可以被访问

```js
// 全局作用域下声明了num变量
const num = 10 
function fn() {
  // 函数内部可以使用全局作用域的变量
  console.log(num)
}
```

- 为window对象动态添加的属性默认也是全局的（window.a = 10），**不推荐**
- 函数中未使用任何关键字声明的变量为全局变量（num=10），**不推荐**
- 尽可能少的声明全局变量，防止全局变量被污染

## 24.3 作用域链

作用域链本质上是底层的**变量查找机制**。

- 在函数被执行时，会**优先查找当前函数**作用域中查找变量
- 如果当前作用域查找不到则会依次**逐级查找父级作用域**直到全局作用域

```js
// 全局作用域
let a = 1 
let b = 2 
// 局部作用域
function f() {
  let a = 1 
  // 局部作用域
  function g() {
    a=2
    // 输出2
    console.log(a)
  }
  // 调用g()
  g()
}
// 调用f
f()
```

- 嵌套关系的作用域串联起来形成了作用域链
- 相同作用域链中按着从小到大的规则查找变量
- 子作用域能够访问父作用域，父级作用域无法访问子级作用域

## 24.4 垃圾回收机制（GC）

JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收

### 24.4.1 内存的生命周期

JS环境中分配的内存，一般有如下生命周期：

1. **内存分配**：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存
2. **内存使用**：即读写内存，也就是使用变量、函数等
3. **内存回收**：使用完毕，由垃圾回收器自动回收不再使用的内存

### 24.4.2 说明

全局变量一般不会回收（关闭页面回收）
一般情况下局部变量的值，不用了，会被自动回收掉

### 24.4.3 内存泄漏

程序中分配的内存由于某种原因程序未释放或无法释放叫做内存泄漏

### 24.4.4 JS垃圾回收机制-算法说明

堆栈空间分配区别：

1. 栈：由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面。
2. 堆：一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放到堆里面。

目前有两种常见的浏览器垃圾回收算法：**引用计数法**和**标记清除法**

#### 1. 引用计数法

IE采用的引用计数算法，定义"内存不再使用"，就是看一个对象是否有指向它的引用，没有引用了就回收对象

1. 跟踪记录被引用的次数
2. 如果被引用了一次，那么就引用次数加1
3. 如果减少一个，则引用减少1
4. 如果引用次数是0，则释放内存

>引用计数法的缺点：

引用计数发存在一个致命缺点：嵌套引用（循环引用）
如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。

```js
function fn() {
  let o1 = {}
  let o2 = {}
  o1.a = o2
  o2.a = o1
  return '引用计数无法回收'
}
fn()
```

因为他们的引用次数永远不会是0，这样的相互引用如果说很大量的存在就会导致大量的内存泄露

#### 2. 标记清除法

现代的浏览器已经不再使用引用计数算法了。现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。

1. 标记清除算法将"不再使用的对象"定义为"无法达到的对象"。
2. 就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。
3. 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230823202349.png)

## 24.5 闭包

一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域，**闭包 = 内层函数 + 外层函数的变量**

### 24.5.1 闭包的基本格式

```js
function outer() {
  const a = 1 
  function f() {
    console.log(a)
  }
  return f
}
// 此时 fun 等价于 f 方
const fun = outer()
// 外层函数使用内部函数的变量
fun()
```

### 24.5.2 闭包的使用

以下代码实现的功能为：统计函数调用次数

```js
function getCunt() {
    let count = 0
    function fn() {
        count++
        return count
    }
    return fn
}
let f = getCunt()
for (let i = 0; i < 5; i++) {
    console.log(f());
}
```

### 24.5.3 闭包可能会引起的问题

闭包可能会引起内存泄漏，闭包内的变量始终处于被引用的状态，及时我们程序运行完了也不会进行释放，所以会产生内存泄漏

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230823205816.png)

### 24.5.4 变量提升

变量提升是JavaScript中比较"奇怪"的现象，它允许在变量声明之前即被访问（仅存在于var声明变量）

```js
// 会输出 undefined
console.log(num)
var num = 10
```

1. 变量在var声明之前即被访问，变量的值为undefined
2. let/const 声明的变量不存在变量提升，如果 let/const 声明的变量在声明前被使用将会报错，而不是 undefined
3. **变量提升出现在相同作用域当中，函数中的局部变量只将赋值提升至函数作用域**
4. 实际开发中推荐先声明再访问变量

# 25 函数进阶

## 25.1 函数提升

函数提升与变量提升比较类似，是指函数在声明之前即可被调用。

```js
fn()  // 打印函数提升
function fn() {
  console.log('函数提升')
}
```

1. 函数提升能够使函数的声明调用更灵活
2. 函数表达式（`let fn = function(){console.log('不提升')}`）不存在提升的现象
3. 函数提升出现在相同作用域当中

## 25.2 函数参数

### 25.2.1 动态参数

arguments 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参

```js
function getSum() {
    let sum = 0
    for (let i = 0; i < arguments.length; i++) {
        sum += arguments[i]
    }
    return sum
}
// 输出6
console.log(getSum(1, 2, 3));
// 输出21
console.log(getSum(1, 2, 3, 4, 5, 6));
```

【注意】arguments 为伪数组，没办法使用 push()，shift() 等方法

### 25.2.2 剩余参数

```js
function getSum(a, b, ...arr) {
    let sum = 0
    for (let i = 0; i < arr.length; i++) {
        sum += arr[i]
    }
    return sum
}
// 输出3
console.log(getSum(1, 2, 3));
// 输出18
console.log(getSum(1, 2, 3, 4, 5, 6));
```

1. ...是语法符号，置于最末函数形参之前，用于获取多余的实参
2. 借助...获取的剩余实参，是个真数组，可以使用 push()，shift() 等方法s
3. **开发中提倡多使用剩余参数**

### 25.2.3 展开运算符

展开运算符(...)，将一个数组进行展开，并且不会修改原数组

```js
const arr = [1, 5, 3, 8, 2]
// 输出 1 5 3 8 2
console.log(...arr)
```

>使用场景

求数组最大值（最小值）、合并数组等

求数组最大值：

```js

const arr = [1, 2, 3, 4, 5, 6]
// ...arr 等价于 1, 2, 3, 4, 5, 6
console.log(Math.max(...arr))
```

数组合并：

```js
const arr1 = [1, 2, 3, 4, 5, 6]
const arr2 = [7, 8, 9, 10]
console.log([...arr1, ...arr2])
```

## 25.3 箭头函数

箭头函数更适用于那些本来需要匿名函数的地方

### 25.3.1 基本语法

#### 语法1

```js
const fn = () => {
    console.log('我是箭头函数')
}
fn()
```

#### 语法2

只有一个参数可以省略小括号

```js
const fn = x => {
  return x + x
}
// 输出2
console.log(fn(1))
```

#### 语法3

如果函数体只有一行代码，可以写到一行上，并且无需写return直接返回值

```js
const fn = x => x + x
// 输出2
console.log(fn(1))
```

#### 语法4

加括号的函数体返回对象字面量表达式

```js
const fn = uname => ({uname: uname})
console.log(fn('pink老师'))
```

### 25.3.2 箭头函数参数

- 普通函数有arguments动态参数
- **箭头函数没有arguments动态参数，但是有剩余参数...args**

```js
// 求和函数
const getSum = (...args) => {
    let sum = 0
    for (let i = 0; i < args.length; i++) {
        sum += args[i]
    }
    return sum
}
// 输出6
console.log(getSum(1, 2, 3, 4, 5))
```

### 25.3.3 箭头函数 this

在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的this值，非常令人讨厌。

**箭头函数不会创建自己的this**，它只会从自己的作用域链的上一层沿用this。

```js
const user = {
    name: '小明',
    sleep: function () {
        // 由于普通函数中的 this 是谁调用就指向谁，所以这里的this 指向对象
        console.log(this)
        const fn = () => {
            // 箭头函数中的 this 与 sleep 中的 this 一致
            console.log(this)
        }
    }
}
// 输出对象
user.sleep()
```

在开发中使用箭头函数前需要考虑函数中this的值，事件回调函数使用箭头函数时，this为全局的window，因此DOM事件回调函数为了简便，还是不太推荐使用箭头函数。

```js
const btn = document.querySelector('.btn');

// 箭头函数，此时 this 指向 window
btn.addEventListener('click', () => {
    console.log(this)
})

// 普通函数，此时 this 指向 DOM
btn.addEventListener('click', function () {
    console.log(this)
})
```

# 26 解构赋值

## 26.1 数组解构

数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法。

### 26.1.1 基础语法

```js
const arr = [1, 2, 3]
// 批量声明变量abc
// 同时将数组单元值123依次赋值给变量abc
const [a, b, c] = arr
console.log(a)  // 1
console.log(b)  // 2
console.log(c)  // 3
```

```js
// 批量声明变量abc
// 同时将数组单元值123依次赋值给变量abc
const [a, b, c] = [1, 2, 3]
console.log(a)  // 1
console.log(b)  // 2
console.log(c)  // 3
```

1. 赋值运算符等号左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量
2. 变量的顺序对应数组单元值的位置依次进行赋值操作

### 26.1.2 典型应用：交换两个变量

**注意** ：数组开头的，特别是前面有语句的一定注意加分号

```js
const a = 1
const b = 2
// 注意，这里有分号
;[a, b] = [b, a]
```

### 26.1.3 数组解构的特殊情况

#### 1. 变量多，单元值少的情况

```js
const arr = [1, 2]
// 批量声明变量abc
// 同时将数组单元值123依次赋值给变量abc
const [a, b, c] = arr
console.log(a)  // 1
console.log(b)  // 2
console.log(c)  // undefined
```

#### 2. 变量少，单元值多的情况

```js
const arr = [1, 2, 3, 4]
// 批量声明变量abc
// 同时将数组单元值123依次赋值给变量abc
const [a, b, c] = arr
console.log(a)  // 1
console.log(b)  // 2
console.log(c)  // 3
```

#### 3. 利用剩余参数解快变量少单元值多的情况

```js
const arr = [1, 2, 3, 4, 5, 6, 7]  
const [a, b, ...c] = arr  
console.log(a)  // 1  
console.log(b)  // 2  
console.log(c)  // [3, 4, 5, 6, 7]
```

#### 4. 防止有undefined传递单元值的情况，可以设置默认值

```js
const [a = '小米', b = '华为'] = []  
// 小米  
console.log(a)  
// 华为  
console.log(b)
```

#### 5. 按需导入，忽略某些返回值

```js
const [a, b, , d] = [1, 2, 3, 4]  
// 1  
console.log(a)  
// 2  
console.log(b)  
// 4  
console.log(d)
```

#### 6. 支持多维数组的解构

```js
const [a, b, [c, d]] = [1, 2, [3, 4]]  
// 1  
console.log(a)  
// 2  
console.log(b)  
// 3  
console.log(c)  
// 4  
console.log(d)
```

## 26.2 对象解构

对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法
### 26.2.1 基本语法

```js
const {uname, age} = {uname: 'michiko', age: 18}  
// michiko
console.log(uname)  
// 18
console.log(age)
```

1. 赋值运算符等号左侧的用于批量声明变量，右侧对象的属性值
2. 对象属性的值将被赋值给与属性名**相同**的变量
3. 注意解构的变量名不要和外面的变量名冲突否则报错
4. 对象中找不到与变星名一致的属性时变星值为undefined

### 26.2.2 特殊情况

#### 1 给新的变量名赋值

```js
// 对象对应的属性名: 新的属性名
const {uname: username, age} = {uname: 'michiko', age: 18}  
// michiko  
console.log(username)  
// 18  
console.log(age)
```

#### 2 数组对象解构

```js
const pig = [  
    {        
	    name: '佩奇',  
        age: 6  
    } 
]  
const [{name, age}] = pig  
// 佩奇  
console.log(name)  
// 6  
console.log(age)
```

#### 3 多级对象解构

```js
const pig = {  
    name: '佩奇',  
    family: {  
        mother: '猪妈妈',  
        father: '猪爸爸',  
        sister: '乔治'  
    },  
    age:6  
}  
const {name, family: {mother, father, sister}, age} = pig  
// 佩奇  
console.log(name)  
// 猪妈妈  
console.log(mother)  
// 猪爸爸  
console.log(father)  
// 乔治  
console.log(sister)  
// 6  
console.log(age)
```

### 26.2.3 应用

```js
const msg = {  
    "code": 200,  
    "msg": "获取新闻列表成功",  
    "data": [  
        {            
	        "id": 1,  
            "title": "日本排污",  
            "count": 9999  
        },  
        {           
	        "id": 2,  
            "title": "2023国庆新加坡政府演讲",  
            "count": 6888  
        },  
        {            
	        "id": 3,  
            "title": "超级小桀塌房",  
            "count": 5555  
        }  
    ]}  
  
const {data} = msg  
console.log(data)  
  
// 渲染函数  
function render({data}) {  
    console.log(data)  
}  
render(msg)  
  
// 将 data 对象赋值为新的变量名  
function render({data: mydate}) {  
    console.log(mydate)  
}  
render(msg)
```

# 27 深入对象

## 27.1 创建对象的三种方式

### 27.1.1 利用对象字面量创建对象

```js
const obj = {name: 'michiko'}
```

### 27.1.2 利用 new Object 创建对象

```js
const o = new Object({name: 'michiko'})
```

### 27.1.3 利用[[#^f6d153|构造函数]]创建对象

## 27.2 构造函数

^f6d153

### 27.2.1 定义

构造函数是一种特殊的函数，主要用来初始化对象

### 27.2.2 使用场景

常规的 `{...}` 语法允许创建一个对象。比如我们创建了佩奇的对象，继续创建乔治的对象还需要重新写一遍，**此时可以通过构造函数来快速创建多个类似的对象。**

### 27.2.3 语法

构造函数在技术上是常规函数，不过构造函数有两个约定：

1. 它们的命名以大写字母开头。
2. 它们只能由 `new` 操作符来执行，使用new关键字调用函数的行为被称为实例化
3. 实例化构造函数时没有参数时可省略()
4. 构造函数内部无需写return，返回值即为新创建的对象

```js
function Pig(name) {
	this.name = name
}

const papa = new Pig('猪爸爸')
const mama = new Pig('猪妈妈')
const peiqi = new Pig('佩奇')
```

### 27.3.4 实例化过程

1. 创建新的空对象
2. 构造函数this指向新对象
3. 执行构造函数代码，修改this，添加新的属性
4. 返回新对象

## 27.3 实例成员 & 静态成员

### 27.3.1 实例成员

通过**构造函数创建**的对象称为**实例对象**，**实例对象中**的属性和方法称为**实例成员**（实例属性和实例方法）

1. 为构造函数传入参数，**每个创建出来的对象只有结构相同但值不同（是两个对象）**
2. 构造函数创建的**实例对象彼此独立互不影响**

```js
function Pig(name) {
	// 实例方法
	this.name = name
	this.sayHi = () => {
		console.log('hi!')
	}
}

const papa = new Pig('猪爸爸')
// 实例方法
console.log(papa.name)
// 实例方法
console.log(papa.sayHi())
```

### 27.3.2 静态成员

构造函数的属性和方法被称为静态成员（静态属性和静态方法）

```js
function Pig(name) {  
}  
  
Pig.name = '猪猪'  
Pig.sayHi = () => {  
    console.log('hi!')  
}  

// 猪猪
console.log(Pig.name)  
// hi!
Pig.sayHi()
```

1. 静态成员只能构造函数来访问
2. 静态方法中的this指向构造函数

举例：Date.now()，Math.PI，Math.floor()

# 28 内置构造函数

在JavaScript中最主要的数据类型有6种：

- 基本数据类型：字符串，数值，布尔，undefined，null
- 引用类型：对象

但是，会出现特殊情况，比如说字符串类型有 `'abc'.length` 属性，按道理基本数据类型不会有属性

其实字符串，数值，布尔等基本类型也都有专门的构造函数，这些我们称为**包装类型**。JS中几乎所有的数据都可以基于构成函数创建。

JavaScript提供一些内置的构造函数：

- 引用类型
	- Object
	- Array
	- RegExp
	- Date

- 包装类型
	- String
	- Number
	- Boolean

## 28.1 Object

Object是内置的构造函数，用于创建普通对象。**推荐使用字面量方式声明对象，而不是Object构造函数。**

```js
const obj = new Object({name: '小明', age: 18})
```

### 28.1.1 静态方法：Object.keys()

`Object.keys()` 用于获取对象中所有属性（键），返回值为数组

```js
const obj = {name: '小明', age: 18}  
// ['names', 'age']
console.log(Object.keys(obj))
```

### 28.1.2 静态方法：Object.values()

`Object.values()` 用于获取对象中所有值，返回值为数组

```js
const obj = {name: '小明', age: 18}  
// ['小明', 18]
console.log(Object.values(obj))
```

### 28.1.3 静态方法：Object.assign(target, src)

`Object.assign(target, src)` 用于对象的拷贝，参数1为源对象，参数2为目标对象

```js
const obj = {name: '小明', age: 18} 
const obj2 = {}  
Object.assign(obj2, obj)  
// {name: '小明', age: 18}  
console.log(obj2)
```

>使用场景：给对象追加属性

```js
const obj = {name: '小明', age: 18}  
Object.assign(obj, {gender: '男'})  
// {name: '小明', age: 18, gender: '男'}  
console.log(obj)
```

## 28.2 Array

Array是内置的构造函数，用于创建数组。**创建数组建议使用字面量创建，不用Array构造函数创建**

```js
const arr = new Array(1, 2)
// [1, 2]
console.log(arr)
```

| 方法    | 作用     | 说明                                       |
| ------- | -------- | ------------------------------------------ |

| reduce  | 累计器   | 返回累计处理的结果，经常用于求和等         |

### 28.2.1 reduce() 方法

`reduce()` 返回累计处理的结果，经常用于求和等

1. 如果没有起始值，则上一次值以数组的第一个数组元素的值
2. 每一次循环，把返回值给做为下一次循环的上一次值
3. 如果有起始值，则起始值做为上一次值

```js
// 如果有起始值，则把初始值累加到里面
arr.reduce(function(上一次值, 当前值){}, 起始值)
```

>普通数组求和

```js
let arr = [1, 2, 3, 4, 5, 6, 7, 8]  
// 36  
console.log(arr.reduce((prev, currentValue) => prev + currentValue));  
// 46  
console.log(arr.reduce((prev, currentValue) => prev + currentValue, 10));
```

>对象数组属性求和（注意：需要设置初始值，因为对象相加会得到NaN）

```js
const arr = [  
    {        name: '小张',  
        salary: 1000  
    },  
    {        name: '小钱',  
        salary: 2000  
    },  
    {        name: '小孙',  
        salary: 3000  
    }  
]  
console.log(arr.reduce((previousValue, currentValue) => previousValue + currentValue.salary, 0));
```

### 28.2.2 Array.from() 方法

`Array.from()` 方法可以把伪数组转换为真数组

```js
// 伪数组
const lis = document.querySelectorAll('ul li')
// 转为真数组
const arr = Array.from(lis)
```

### 28.2.3 其他常见实例方法

| 方法    | 作用                               | 说明                                                                          |
| --------- | ---------------------------------- | ----------------------------------------------------------------------------- |
| forEach | 遍历数组 | 不返回数组，经常用于查找遍历数组元素       |
| join    |  数组转为字符串        | 将数组所有元素转换为一个字符串                                           |
| map     | 迭代数组 | 返回新数组，返回的是处理之后的数组元素     |
| find      | 查找元素                           | 返回符合测试条件的**第一个数组元素值**，如果没有符合条件的则返回undefined（重点） |
| every     | 检测数组所有元素是否都符合指定条件 | 如果所有元素都通过检测返回true，否则返回false（重点）                         |
| some      | 检测数组中的元素是否满足指定条件   | 如果数组中有元素满足条件返回true，否则返回false                               |
| concat    | 合并两个数组                       | 返回生成新数组                                                                |
| sort      | 对原数组单元值排序                 |                                                                               |
| splice    | 删除或替换原数组单元               |                                                                               |
| reverse   | 反转数组                           |                                                                               |
| findIndex | 查找元素的索引值                   |                                                                               |
| filter  | 过滤数组 | 返回新数组，返回的是筛选满足条件的数组元素 |

## 28.3 String

| 方法                                     | 作用                                                                    |
| ---------------------------------------- | ----------------------------------------------------------------------- |
| String(数字)                                   | 将数字转换为字符串                                                |
| length                                   | 获取字符串的长度（重点）                                                |
| split(分隔符)                            | 将字符串拆分成数组（重点）                                              |
| substring(起始下标[，终止下标])          | 字符串截取（重点）                                                      |
| startsWith(检测字符串[, 搜索的起始位置]) | 检测是否以某字符开头（重点）                                            |
| includes[搜索的字符串[, 搜索的起始位置]] | 判断一个字符串是否包含在另一个字符串中，根据情况返回true或false（重点） |
| toUpperCase                              | 将字母转换成大写                                                        |
| toLowerCase                              | 将字母转换成小写                                                        |
| indexOf(字符)                            | 检测是否包含某个字符                                                    |
| endsWith(检测字符串[, 搜索的起始位置])                           | 检测是否以某个字符结尾                                                  |
| replace(原字符串，替换字符串)            | 替换字符串，支持正则表达式                                              |
| match(字符串，匹配子串)                                    | 用于查找字符串，支持正则匹配                                                                        |

## 28.4 Number

| 方法    | 作用 |
| ------- | ---- |
| toFixed | 设置保留的位数（四舍五入后）     |
| toString() | 将数字转换为字符串     |
| Number() | 将字符串转换为Number     |

```js
const price = 12.3456
// 12.35
console.log(price.toFixed(2))
```


# 29 深入面向对象

## 29.1 编程思想

### 29.1.1 面向过程

面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。

蛋炒饭：煮饭 -> 炒饭 -> 炒蛋

### 29.1.2 面向对象

面向对象是把事务分解成为一个个对象：然后由对象之间分工与合作。举个例子：牛肉盖浇饭 = 牛肉 + 饭，番茄炒蛋盖浇饭 = 番茄炒蛋 + 饭

在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。

面向对象的特性：

- 封装性
- 继承性
- 多态性

### 29.1.3 面向过程和面向对象的对比

#### 面向过程编程

- 优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。
- 缺点：没有面向对象易维护、易复用、易扩展

#### 面向对象编程

- 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
- 缺点：性能比面向过程低

## 29.2 构造函数

封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。**构造函数体现了面向对象的封装特性**

同样的将变量和函数组合到了一起并能通过this实现数据的共享，所不同的是借助构造函数创建出来的实例对象之间是彼此不影响的。**构造函数实例创建的对象彼此独立、互不影响**

但是，**构造函数存在内存浪费的问题：**

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230825094431.png)

## 29.3 原型

### 29.3.1 原型对象

#### 原型对象定义

- 枸造函数通过原型分配的函数是**所有对象所共享**的。
- JavaScript规定，**每一个构造函数都有一个 prototype 属性**，指向另一个对象，所以我们也称为**原型对象**，这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存
- **我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。**
- **构造函数和原型对象中的this都指向实例化的对象**

```js
function Person(name) {  
    this.name = name  
}  
Person.prototype.sing = function sing() {  
    console.log('唱歌')  
}  
  
const ldh = new Person('刘德华')  
const zxy = new Person('张学友')  
// false
console.log(ldh === zxy)  
// true
console.log(ldh.sing === zxy.sing)
```

#### 原型对象应用

给所有的数组对象封装求和方法

```js
Array.prototype.getTotalSum = () => {  
    return this.reduce((previousValue, currentValue) => previousValue + currentValue)  
}  
  
const arr = [1, 2, 3, 4, 5]  
// 15
console.log(arr.getTotalSum());
```

### 29.3.2 constructor 属性

constructor 属性指向该原型对象的构造函数

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230825102101.png)

```js
function Person(name) {  
    this.name = name  
}  
  
// true  
console.log(Person.prototype.constructor === Person);
```

#### 使用场景

如果有多个对象的方法，我们可以给原型对象采取对象形式赋值。

但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了

此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。

```js
Person.prototype = {  
    // 将原型指向原型对象
    // 如果缺少这句话，由于是赋值操作，那么原型就会被覆盖，而不是添加属性
    constructor: Person,  
    sing: function() {  
        console.log('唱歌')  
    },    dance: () => {  
        console.log('唱歌')  
    },    act: () => {  
        console.log('表演')  
    }}  
  
new Person('michiko').sing()
```

### 29.3.3 对象原型

对象都会有一个属性 `_proto_` 指向构造函数的 `prototype` 原型对象，之所以我们对象可以使用构造函数 `prototype` 原型对象的属性和方法，就是因为对象有 `_poto_` 原型的存在。

>注意

- `__proto__` 是JS非标准屈属性
- `[[prototype]]` 和 `___proto__` 意义相同
- 用来表明当前实例对象指向哪个原型对象 `prototype`
- `__proto__` 对象原型里面也有一个 `constructor` 属性，指向**创建该实例对象的构造函数**

```js
function Person(name) {  
    this.name = name  
}
// true
console.log(new Person('michiko').__proto__ === Person.prototype)
```

### 29.3.4 原型继承

继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript中大多是借助原型对象实现继承的特性。

```js
const Person = {  
    eye: 2,  
    head: 1  
}  
  
function Woman() {  
  
}  
Woman.prototype = Person  

// {  eye: 2,  head: 1  }  
console.log(new Woman())
```

#### 原型继承会出现的问题

看如下代码，Man构造函数和Woman构造函数都是继承了Person类，Man的原型对象指向Person，Woman的原型对象也指向Person。结果是：导致当Woman的原型对象改变后，Man的原型对象也一同改变

```js
const Person = {  
    eye: 2,  
    head: 1  
}  
  
function Woman() {  
  
}  
Woman.prototype = Person  
Woman.prototype.constructor = Woman  
Woman.prototype.baby = function () {  
    console.log('生孩子')  
}  
console.log(new Woman())  
  
function Man() {  
  
}  
Man.prototype = Person  
Man.prototype.constructor = Man  

console.log(new Man())
```

![](https://raw.githubusercontent.com/michik0/notes-image/master/20230825145446.png)

#### 问题解决

将通用继承的属性（父类：Person），变为构造函数，将创建出来的对象，赋值给个子（子类）的原型对象即可解决

```js
// 将通用的Person改为构造函数写法
function Person() {  
    this.eye = 2  
    this.head = 1  
}  
  
function Woman() {  
  
}  
// 将父类的对象复制给原型对象
Woman.prototype = new Person()  
Woman.prototype.constructor = Woman  
Woman.prototype.baby = function() {  
    console.log('生孩子')  
}  
console.log(new Woman())  
  
function Man() {  
  
}  
// 将父类的对象复制给原型对象
Man.prototype = new Person()  
Man.prototype.constructor = Man  
  
console.log(new Man())
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230825150519.png)

### 29.3.5 原型链

基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对象的链状结构关系称为**原型链**

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230825152117.png)

#### 查找规则

1. 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。
2. 如果没有就查找它的原型（也就是 `__proto__` 指向的 `prototype` 原型对象）
3. 如果还没有就查找原型对象的原型(Object的原型对象)
4. 依此类推一直找到Object为止(null)
5. `__proto__` 对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线
6. 可以使用 `instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上

# 30 深浅拷贝

## 30.1 浅拷贝

浅拷贝中，拷贝的是地址

常见方法：

- 拷贝对象
	- `Object.assign(target, src)` 用于对象的拷贝，参数1为源对象，参数2为目标对象
	- `{...obj}`

- 拷贝数组
	- `Array.prototype.concat()`
	- `[...arr]`


## 30.2 深拷贝

深拷贝，拷贝的是对象，不是地址

深拷贝常见实现方法：

1. 通过递归实现深拷贝
2. `lodash` / `cloneDeep()`
3. 通过 `JSON.stringify()` 实现

### 30.2.1 递归

```js
function deepCopy(srcObj, targetObj) {  
    for (let k in srcObj) {  
        if (srcObj[k] instanceof Array) {  
            targetObj[k] = deepCopy(srcObj[k], [])  
        }        
        else if (srcObj[k] instanceof Object) {  
            targetObj[k] = deepCopy(srcObj[k], {})  
        }        
        else {  
            targetObj[k] = srcObj[k]  
        }    
	}    
	return targetObj  
}
```

### 30.2.2 `_.cloneDeep()` 进行深拷贝

```html
<!-- 引入lodash -->
<script src="lodash.min.js"></script>
<script>
	const objAfterClone = _.cloneDeep(obj);
</script>
```

### 30.2.3 `JSON.stringify()` 进行深拷贝

```js
const ObjAfterClone = JSON.parse(JSON.stringify(obj))
```

# 31 异常处理

## 31.1 throw 抛异常

异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行

```js
throw new Error('程序执行异常')
```

- throw 抛出异常信息，程序也会终止执行
- throw 后面跟的是错误提示信息
- Error 对象配合 throw 使用，能够设置更详细的错误信息

## 31.2 try / catch 捕获异常

我们可以通过 try / catch 捕获错误信息（浏览器提供的错误信息），可以使用 finally 最后进行处理

```js
try {  
    throw new Error('抛出异常')  
} catch (err) {  
    alert(`捕获到异常：${err.message}`)  
} finally {  
    console.log('执行收尾工作')  
}
```

1. `try...catch` 用于捕获错误信息
2. 如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息
3. finally 不管是否有错误，都会执行（即使 return 之后，也会执行 finally 中的代码）

## 31.3 debugger

在代码中加上 debugger 可以在浏览器渲染时，卡在 debugger 上，进行代码的调试

```js
console.log('调试代码')
debugger
```

# 32 处理 this

## 32.1 this 指向

### 32.1.1 普通函数 this 指向

普通函数的调用方式决定了this的值，即【谁调用this的值指向谁】

```js
// 普通函数
function sayHi () {
	console.log(this)
}
// 函数表达式
const sayHello = function () {
	console.log(this)
}
// 函数的调用方式决定了this的值
sayHi()   // window
window.sayHi()
```

```js
// 普通对象
const user = {
	name:'小明'，
	walk: function () {
		console.log(this)
	}
// 动态为user添加方法
user.sayHi = sayHi
uesr.sayHello = sayHello
// 函数调用方式，决定了this的值
user.sayHi() // user
user.sayHello() // user
```

### 32.1.2 箭头函数 this 指向

箭头函数中的 this 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 this

1. 箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的
2. 箭头函数中的 this 引用的就是最近作用域中的 this
3. 向外层作用域中，一层一层查找 this，直到有 this 的定义

```js
// 此处为window
console.log(this)
//箭头函数
const sayHi = function(){
	//该箭头函数中的 this 为函数声明环境中 this 一致
	console.log(this)
}
```

```js
// 普通对象
const user = {
	name:'小明',
	// 该箭头函数中的 this 为函数声明环境中 this 一致
	walk: ()=>{
		console.log(this)
	}
}
```

**【注意】** 同样由于箭头函数 this 的原因，基于原型的面向对象也不推荐采用箭头函数

## 32.2 改变 this 指向

JavaScript 中还允许指定函数中 this 的指向，有3个方法可以动态指定普通函数中 this 的指向

- call()
- apply()
- bind()

### 32.2.1 call()

使用 call 方法调用函数，同时指定被调用函数中 this 的值

```js
// thisArg：在 fun 函数运行时指定的 this 值
// arg1，arg2：传递的其他参数
// 返回值就是函数的返回值
fun.call(thisArg, arg1, arg2[, arg3, ...])
```

```js
const obj = {  
    name: 'michiko'  
}  
function fn(x, y) {  
    console.log(this, x, y)  
}  
// this指向window  
fn(1, 2)  
// this指向obj  
fn.call(obj, 1, 2)
```

### 32.2.2 apply()

使用 apply 方法调用函数，同时指定被调用函数中 this 的值

apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值：`Math.max.apply(Math, [1,2,3])`

```js
// thisArg：在fun函数运行时指定的this值
// argsArray：传递的值，必须包含在数组里面
// 返回值就是函数的返回值
fun.apply(thisArg,[argsArray])
```

```js
const obj = [1, 2, 3]  
function fn(x, y) {  
    console.log(this, x, y)  
}  
// this指向window  
fn()  
// this指向obj  
fn.apply(obj)  
// 输出 obj, 5, 6
fn.apply(obj, [5, 6])
```

>apply() 和 call() 的区别

- 都是调用函数，都能改变 this 指向
- 参数不一样，apply 传递的必须是数组

### 32.2.3 bind()

**bind() 方法不会调用函数**，但是能改变函数内部 this 指向，返回由指定的this值和初始化参数改造的**原函数拷贝（新函数）**

```js
// thisArg：在fun函数运行时指定的 this 值
// arg1，arg2：传递的其他参数
// 返回由指定的this值和初始化参数改造的**原函数拷贝（新函数）**
fun.bind(thisArg, arg1, arg2, ...)
```

```js
const obj = {  
    name: 'michiko'  
}  
function fn() {  
    console.log(this)  
}  
// 生成拷贝后的新的函数  
const newFn = fn.bind(obj);  
// {name: 'michiko'}  
newFn()
```

因此当我们只是想改变tihs指向，并且不想调用这个函数的时候，可以使用 bind，比如改变定时器内部的 this 指向

```js
//需求，有一个按钮，点击里面就禁用，2秒钟之后开后
document.querySelector('button').addEventListener('click',function () {
	//禁用按钮
	this.disabled = true
	setTimeout(function () {
		//在这个普通函数里面，我们要this由原来的window改为btn
		this.disabled = false
	}.bind(this),2000)
})
```

## 32.3 call，apply，bind 总结

>相同点：

都可以改变函数内部的this指向

>区别：

- call和apply会调用函数，并且改变函数内部this指向
- cal和apply传递的参数不一样
	- call()传递参数arg1，arg2形式
	- apply传递数组形式[arg]
- **bind不会调用函数，可以改变函数内部this指向**

>主要应用场景：

- call调用函数并且可以传递参数
- apply经常跟数组有关系，比如借助于数学对象实现数组最大值最小值
- **bind不调用函数，但是还想改变this指向，比如改变定时器内部的this指向**

## 33 防抖（debounce）

防抖指单位时间内，频繁触发事件，**只执行最后一次**

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230826094607.png)

## 33.1 使用场景：

- 搜索框搜索输入：只需用户最后一次输入完，再发送请求
- 手机号、邮箱验证输入检测

## 33.2 实现防抖

### 33.2.1 自定义防抖函数

防抖的核心就是利用定时器（setTimeout）来实现：

1. 声明一个定时器变量
2. 当鼠标每次滑动都先判断是否有定时器了，**如果有定时器先清除以前的定时器**
3. 如果没有定时器则开启定时器
4. 在定时器里面调用要执行的函数

```js
const debounceFn = function (fn, timeout) {  
    let timer  
    return () => {  
        if (timer) clearTimeout(timer)  
        timer = setTimeout(() => {  
            fn()  
        }, timeout)  
    }}
```
### 33.2.2 lodash 实现防抖

```js
_.debounce(func, [wait=0], [options=])
```

创建一个 debounced（防抖动）函数，该函数会从上一次被调用后，延迟 `wait` 毫秒后调用 `func` 方法。 debounced（防抖动）函数提供一个 `cancel` 方法取消延迟的函数调用以及 `flush` 方法立即调用。 可以提供一个 options（选项） 对象决定如何调用 `func` 方法，`options.leading` 与|或 `options.trailing` 决定延迟前后如何触发（注：是 先调用后等待 还是 先等待后调用）。 `func` 调用时会传入最后一次提供给 debounced（防抖动）函数 的参数。 后续调用的 debounced（防抖动）函数返回是最后一次 `func` 调用的结果。

参数：

1. `func` _(Function)_: 要防抖动的函数。
2. `[wait=0]` _(number)_: 需要延迟的毫秒数。
3. `[options=]` _(Object)_: 选项对象。
4. `[options.leading=false]` _(boolean)_: 指定在延迟开始前调用。
5. `[options.maxWait]` _(number)_: 设置 `func` 允许被延迟的最大值。
6. `[options.trailing=true]` _(boolean)_: 指定在延迟结束后调用。

返回：

_(Function)_: 返回新的 debounced（防抖动）函数。

>参考：<https://www.lodashjs.com/docs/lodash.debounce#_debouncefunc-wait0-options>

## 33.3 案例：利用防抖来处理鼠标滑过盒子显示文字

```js
let i = 0  
const box = document.querySelector('.box');  
// 防抖函数  
const debounceFn = _.debounce(() => {  
    console.log('鼠标滑动')  
    box.innerHTML = ++i  
}, 100);  
box.addEventListener('mousemove', debounceFn)
```

# 34 节流

单位时间内，频繁触发事件，**只执行一次**

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230826101827.png)

## 34.1 使用场景

高频事件：

- 鼠标移动：mousemove
- 页面尺寸缩放：resize
- 滚动条滚动：scroll等等

## 34.2 实现节流

### 34.2.1 自定义节流函数

节流的核心就是利用定时器（setTimeout）来实现

1. 声明一个定时器变量
2. 当鼠标每次滑动都先判断是否有定时器了，如果有定时器则不开启新定时器
3. 如果没有定时器则开启定时器
	1. 定时器里面调用执行的函数
	2. 把定时器清空

```js
const throttleFn = function (fn, timeout) {  
    let timer = null  
    return () => {  
        if (!timer) {  
            timer = setTimeout(() => {  
                fn()  
                timer = null  
            }, timeout)  
        }    
	}
}
```
### 33.4.2 lodash 实现节流

```js
_.throttle(func, [wait=0], [options=])
```

创建一个节流函数，在 wait 秒内最多执行 `func` 一次的函数。 该函数提供一个 `cancel` 方法取消延迟的函数调用以及 `flush` 方法立即调用。 可以提供一个 options 对象决定如何调用 `func` 方法， options.leading 与|或 options.trailing 决定 wait 前后如何触发。 `func` 会传入最后一次传入的参数给这个函数。 随后调用的函数返回是最后一次 `func` 调用的结果。  
  
**注意:** 如果 `leading` 和 `trailing` 都设定为 `true` 则 `func` 允许 trailing 方式调用的条件为: 在 `wait` 期间多次调用。  
  
如果 `wait` 为 `0` 并且 `leading` 为 `false`, `func`调用将被推迟到下一个点，类似`setTimeout`为`0`的超时。

参数：

1. `func` _(Function)_: 要节流的函数。
2. `[wait=0]` _(number)_: 需要节流的毫秒。
3. `[options=]` _(Object)_: 选项对象。
4. `[options.leading=true]` _(boolean)_: 指定调用在节流开始前。
5. `[options.trailing=true]` _(boolean)_: 指定调用在节流结束后。

返回：

_(Function)_: 返回节流的函数。

## 34.3 案例：利用节流来处理鼠标滑过盒子显示文字

```js
let i = 0  
const box = document.querySelector('.box');  
// 节流函数  
const debounceFn = _.throttle(() => {  
    console.log('鼠标滑动')  
    box.innerHTML = ++i  
}, 500);  
box.addEventListener('mousemove', debounceFn)
```

## 34.4 案例：视频从指定位置开始播放

```js
const video = document.querySelector('video');  
video.onloadeddata = () => {  
  video.currentTime = +localStorage.getItem('time')  
}  
video.ontimeupdate = _.throttle(() => {  
  localStorage.setItem('time', `${video.currentTime}`)  
}, 1000)
```

# 附录

## 1. TAB栏切换

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230815104521.png)

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tab栏切换</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    .tab {
      width: 590px;
      height: 340px;
      margin: 20px;
      border: 1px solid #e4e4e4;
    }

    .tab-nav {
      width: 100%;
      height: 60px;
      line-height: 60px;
      display: flex;
      justify-content: space-between;
    }

    .tab-nav h3 {
      font-size: 24px;
      font-weight: normal;
      margin-left: 20px;
    }

    .tab-nav ul {
      list-style: none;
      display: flex;
      justify-content: flex-end;
    }

    .tab-nav ul li {
      margin: 0 20px;
      font-size: 14px;
    }

    .tab-nav ul li a {
      text-decoration: none;
      border-bottom: 2px solid transparent;
      color: #333;
    }

    .tab-nav ul li a.active {
      border-color: #e1251b;
      color: #e1251b;
    }

    .tab-content {
      padding: 0 16px;
    }

    .tab-content .item {
      display: none;
    }

    .tab-content .item.active {
      display: block;
    }
  </style>
</head>

<body>
  <div class="tab">
    <div class="tab-nav">
      <h3>每日特价</h3>
      <ul>
        <li><a class="active" href="javascript:;" data-id="0">精选</a></li>
        <li><a href="javascript:;" data-id="1">美食</a></li>
        <li><a href="javascript:;" data-id="2">百货</a></li>
        <li><a href="javascript:;" data-id="3">个护</a></li>
        <li><a href="javascript:;" data-id="4">预告</a></li>
      </ul>
    </div>
    <div class="tab-content">
      <div class="item active"><img src="./images-03/tab00.png" alt="" /></div>
      <div class="item"><img src="./images-03/tab01.png" alt="" /></div>
      <div class="item"><img src="./images-03/tab02.png" alt="" /></div>
      <div class="item"><img src="./images-03/tab03.png" alt="" /></div>
      <div class="item"><img src="./images-03/tab04.png" alt="" /></div>
    </div>
  </div>

  <script>
    document.querySelector('.tab-nav ul').addEventListener('click', function (e) {
      const target = e.target
      if (target.tagName === 'A') {
        document.querySelector('.tab-nav ul .active').classList.remove('active')
        target.classList.add('active')
        document.querySelector('.tab-content .active').classList.remove('active')
        document.querySelector(`.tab-content .item:nth-child(${+target.dataset.id + 1})`).classList.add('active')
      }
    })
  </script>

</body>

</html>
```

## 2. 全选反选案例

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230815104456.png)

```html
<!DOCTYPE html>

<html>

<head lang="en">
  <meta charset="UTF-8">
  <title></title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    table {
      border-collapse: collapse;
      border-spacing: 0;
      border: 1px solid #c0c0c0;
      width: 500px;
      margin: 100px auto;
      text-align: center;
    }

    th {
      background-color: #09c;
      font: bold 16px "微软雅黑";
      color: #fff;
      height: 24px;
    }

    td {
      border: 1px solid #d0d0d0;
      color: #404060;
      padding: 10px;
    }

    .allCheck {
      width: 80px;
    }
  </style>
</head>

<body>
  <table>
    <tr>
      <th class="allCheck">
        <input type="checkbox" name="" id="checkAll"> <span class="all">全选</span>
      </th>
      <th>商品</th>
      <th>商家</th>
      <th>价格</th>
    </tr>
    <tr>
      <td>
        <input type="checkbox" name="check" class="ck">
      </td>
      <td>小米手机</td>
      <td>小米</td>
      <td>￥1999</td>
    </tr>
    <tr>
      <td>
        <input type="checkbox" name="check" class="ck">
      </td>
      <td>小米净水器</td>
      <td>小米</td>
      <td>￥4999</td>
    </tr>
    <tr>
      <td>
        <input type="checkbox" name="check" class="ck">
      </td>
      <td>小米电视</td>
      <td>小米</td>
      <td>￥5999</td>
    </tr>
  </table>
  <script>
    // 勾选全选时，所有项目打勾，取消全选时，所有项目取消打勾
    const checkAll = document.querySelector('#checkAll')
    const allCheckBox = document.querySelectorAll('.ck')
    checkAll.addEventListener('click', function () {
      for (let i = 0; i < allCheckBox.length; i++) {
        allCheckBox[i].checked = this.checked
      }
    })
    for (let i = 0; i < allCheckBox.length; i++) {
      allCheckBox[i].addEventListener('click', function () {
        checkAll.checked = allCheckBox.length === document.querySelectorAll('.ck:checked').length
      })
    }
  </script>
</body>

</html>
```

## 3. 倒计时

```js
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
  <style>
    .countdown {
      width: 240px;
      height: 305px;
      text-align: center;
      line-height: 1;
      color: #fff;
      background-color: brown;
      /* background-size: 240px; */
      /* float: left; */
      overflow: hidden;
    }

    .countdown .next {
      font-size: 16px;
      margin: 25px 0 14px;
    }

    .countdown .title {
      font-size: 33px;
    }

    .countdown .tips {
      margin-top: 80px;
      font-size: 23px;
    }

    .countdown small {
      font-size: 17px;
    }

    .countdown .clock {
      width: 142px;
      margin: 18px auto 0;
      overflow: hidden;
    }

    .countdown .clock span,
    .countdown .clock i {
      display: block;
      text-align: center;
      line-height: 34px;
      font-size: 23px;
      float: left;
    }

    .countdown .clock span {
      width: 34px;
      height: 34px;
      border-radius: 2px;
      background-color: #303430;
    }

    .countdown .clock i {
      width: 20px;
      font-style: normal;
    }
  </style>
</head>

<body>
  <div class="countdown">
    <p class="next"></p>
    <p class="title">下班倒计时</p>
    <p class="clock">
      <span id="hour">00</span>
      <i>:</i>
      <span id="minutes">25</span>
      <i>:</i>
      <span id="scond">20</span>
    </p>
    <p class="tips">18:30:00下班</p>
  </div>
  <script>


    function getRestTime() {
      document.querySelector('.next').innerHTML = `今天是${getDate(new Date())}`
      const endTime = `${getDate(new Date())} 18:00:00`
      document.querySelector('.tips').innerHTML = endTime

      const restTs = +new Date(endTime) - +new Date()
      document.querySelector('#hour').innerHTML = getRestTimeHours(restTs)
      document.querySelector('#minutes').innerHTML = getRestTimeMinutes(restTs)
      document.querySelector('#scond').innerHTML = getRestTimeSeconds(restTs)
    }

    getRestTime()

    setInterval(getRestTime, 1000);

    // 获取日期
    function getDate(date) {
      const fullYear = date.getFullYear()
      let month = date.getMonth() + 1
      month = month < 10 ? '0' + month : month
      let day = date.getDate()
      day = day < 10 ? '0' + day : day
      return `${fullYear}-${month}-${day}`
    }

    function getRestTimeDays(ts) {
      ts /= 1000
      return parseInt(ts / 60 / 60 / 24)
    }

    function getRestTimeHours(ts) {
      ts /= 1000
      return parseInt(ts / 60 / 60 % 24)
    }

    function getRestTimeMinutes(ts) {
      ts /= 1000
      return parseInt(ts / 60 % 60)
    }

    function getRestTimeSeconds(ts) {
      ts /= 1000
      return parseInt(ts % 60)
    }

  </script>
</body>

</html>
```

## 4. 获取日期时分秒

```js
function getDate(date) {
    let fullYear = date.getFullYear();
    let month = date.getMonth() + 1;
    let day = date.getDate();
    let hour = date.getHours();
    let minute = date.getMinutes();
    let second = date.getSeconds();
    month = month < 10 ? '0' + month : month
    day = day < 10 ? '0' + day : day
    hour = hour < 10 ? '0' + hour : hour
    minute = minute < 10 ? '0' + minute:minute
    second = second < 10 ? '0' + second : second
    return `${fullYear}-${month}-${day} ${hour}:${minute}:${second}`
}
```

## 5. 轮播图插件：Swiper 插件

官网：<https://www.swiper.com.cn/>

## 6. 放大镜效果

```html
<!DOCTYPE html>  
<html lang="en">  
  
<head>  
  <meta charset="UTF-8">  
  <title>小兔鲜儿 - 新鲜 惠民 快捷!</title>  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">  
  <meta name="renderer" content="webkit">  
  <!-- <link rel="stylesheet" href="//at.alicdn.com/t/font_1939705_bgtmkonu28.css"> -->  
  <link rel="stylesheet" href="./css/common.css">  
  <link rel="stylesheet" href="./css/product.css">  
</head>  
  
<body>  
  <!-- 项部导航 -->  
  <div class="xtx_topnav">  
    <div class="wrapper">  
      <!-- 顶部导航 -->  
      <ul class="xtx_navs">  
        <li>          <a href="javascript:;">请先登录</a>  
        </li>        <li>          <a href="javascript:;">免费注册</a>  
        </li>        <li>          <a href=".javascript:;">我的订单</a>  
        </li>        <li>          <a href="javascript:;">会员中心</a>  
        </li>        <li>          <a href="javascript:;">帮助中心</a>  
        </li>        <li>          <a href="javascript:;">在线客服</a>  
        </li>        <li>          <a href="javascript:;">  
            <i class="mobile sprites"></i>  
            手机版  
          </a>  
        </li>      </ul>    </div>  </div>  <!-- 头部 -->  
  <div class="xtx_header">  
    <div class="wrapper">  
      <!-- 网站Logo -->  
      <h1 class="xtx_logo"><a href="/">小兔鲜儿</a></h1>  
      <!-- 主导航 -->  
      <div class="xtx_navs">  
        <ul class="clearfix">  
          <li>            <a href="javascript:;">首页</a>  
          </li>          <li>            <a href="javascript:;">生鲜</a>  
          </li>          <li>            <a href="javascript:;">美食</a>  
          </li>          <li>            <a href="javascript:;">餐厨</a>  
          </li>          <li>            <a href="javascript:;">电器</a>  
          </li>          <li>            <a href="javascript:;">居家</a>  
          </li>          <li>            <a href="javascript:;">洗护</a>  
          </li>          <li>            <a href="javascript:;">孕婴</a>  
          </li>          <li>            <a href="javascript:;">服装</a>  
          </li>        </ul>      </div>      <!-- 站内搜索 -->  
      <div class="xtx_search clearfix">  
        <!-- 购物车 -->  
        <a href="javascript:;" class="xtx_search_cart sprites">  
          <i>2</i>  
        </a>        <!-- 搜索框 -->  
        <div class="xtx_search_wrapper">  
          <input type="text" placeholder="搜一搜" onclick="location.href='./search.html'">  
        </div>      </div>    </div>  </div>  <div class="xtx-wrapper">  
    <div class="container">  
      <!-- 面包屑 -->  
      <div class="xtx-bread">  
        <a href="javascript:;"> 首页 > </a>  
        <a href="javascript:;"> 电子产品 > </a>  
        <a href="javascript:;"> 电视 > </a>  
        <span>小米电视4A 32英寸</span>  
      </div>      <!-- 商品信息 -->  
      <div class="xtx-product-info">  
        <div class="left">  
          <div class="pictrue">  
            <div class="middle">  
              <img src="./images/1.jpg" alt="">  
              <div class="layer"></div>  
            </div>            <div class="small">  
              <ul>                <li class="active"><img src="./images/1.jpg" alt=""></li>  
                <li><img src="./images/2.jpg" alt=""></li>  
                <li><img src="./images/3.jpg" alt=""></li>  
                <li><img src="./images/4.jpg" alt=""></li>  
                <li><img src="./images/5.jpg" alt=""></li>  
              </ul>            </div>            <div class="large"></div>  
          </div>          <div class="other">  
            <ul>              <li>                <p>销量人气</p>  
                <p>1999+</p>  
                <p>销量人气</p>  
              </li>              <li>                <p>商品评价</p>  
                <p>999+</p>  
                <p>查看评价</p>  
              </li>              <li>                <p>收藏人气</p>  
                <p>299+</p>  
                <p><a href="javascript:;">收藏商品</a></p>  
              </li>              <li>                <p>品牌信息</p>  
                <p>小米</p>  
                <p><a href="javascript:;">品牌主页</a></p>  
              </li>            </ul>          </div>        </div>        <div class="right">  
          <h3 class="name">小米电视4A 32英寸</h3>  
          <p class="desc">全面屏设计 / 高清分辨率 / 海量内容 / 1G+4G大内存 / 多核处理器</p>  
          <p class="price"><span class="now">¥1899</span><span class="old">¥2999</span></p>  
          <div class="address">  
            <div class="item">  
              <div class="dt">促销</div>  
              <div class="dd">12月好物放送，App领券购买直降120元</div>  
            </div>            <div class="item">  
              <div class="dt">配送</div>  
              <div class="dd">至  
                <div class="box">  
                  <span>陕西 西安 <i></i></span>  
                </div>              </div>            </div>            <div class="item">  
              <div class="dt">服务</div>  
              <div class="dd">  
                <span class="fw">无忧退货</span>  
                <span class="fw">快速退款</span>  
                <span class="fw">免费包邮</span>  
                <a href="#" class="lj">了解详情</a>  
              </div>            </div>          </div>          <div class="attrs">  
            <div class="item">  
              <div class="dt">颜色</div>  
              <div class="dd">  
                <img src="./uploads/img/cate-06.png" alt="">  
                <img src="./uploads/img/cate-07.png" alt="">  
              </div>            </div>            <div class="item">  
              <div class="dt">颜色</div>  
              <div class="dd">  
                <span class="size">22英寸</span>  
                <span class="size">42英寸</span>  
                <span class="size">52英寸</span>  
                <span class="size">62英寸</span>  
              </div>            </div>            <div class="item">  
              <div class="dt">数量</div>  
              <div class="dd">  
                <div class="num">  
                  <a href="javascript:;">-</a>  
                  <input type="text" value="1">  
                  <a href="javascript:;">+</a>  
                </div>              </div>            </div>            <div class="item">  
              <a class="buy" href="javascript:;">立即购买</a>  
            </div>          </div>        </div>      </div>      <!-- 同类产品推荐 -->  
      <div class="xtx-relevant-product">  
        <h3>同类产品推荐</h3>  
        <ul>          <li>            <a href="#">  
              <img src="./uploads/history_goods_1.jpg" alt="">  
              <p class="name">USB Type C数据线</p>  
              <p class="desc">快速充电，稳定传输</p>  
              <p class="price">¥39</p>  
            </a>          </li>          <li>            <a href="#">  
              <img src="./uploads/history_goods_2.jpg" alt="">  
              <p class="name">红米Note 5A 高配版</p>  
              <p class="desc">1600万像素柔光自拍</p>  
              <p class="price">¥1899</p>  
            </a>          </li>          <li>            <a href="#">  
              <img src="./uploads/history_goods_3.jpg" alt="">  
              <p class="name">VGA网口多功能转接器</p>  
              <p class="desc">小巧便携，节省桌面空间</p>  
              <p class="price">¥19</p>  
            </a>          </li>          <li>            <a href="#">  
              <img src="./uploads/history_goods_4.jpg" alt="">  
              <p class="name">笔记本Pro 15.6"</p>  
              <p class="desc">全金属强化机身搭配独显</p>  
              <p class="price">¥4899</p>  
            </a>          </li>        </ul>        <a href="javascript:;" class="prev"><span class="iconfont icon-angle-left"></span></a>  
        <a href="javascript:;" class="next"><span class="iconfont icon-angle-right"></span></a>  
      </div>      <!-- 商品详情 -->  
      <div class="xtx-product-detail">  
        <div class="main">  
          <div class="cont">  
            <div class="tab-head">  
              <a href="javascript:;">商品详情</a>  
              <a href="javascript:;">商品评价<span>（998+）</span></a>  
            </div>            <div class="tab-pane">  
              <!-- 静态属性 -->  
              <div class="attrs">  
                <div class="item"><span>商品名称：</span><span>小米L32M5-AZ </span></div>  
                <div class="item"><span>商品编号：</span><span>4620979 </span></div>  
                <div class="item"><span>商品毛重：</span><span>8.0kg </span></div>  
                <div class="item"><span>商品产地：</span><span>中国大陆 </span></div>  
                <div class="item"><span>屏幕尺寸：</span><span>32英寸及以下 </span></div>  
                <div class="item"><span>能效等级：</span><span>三级能效 </span></div>  
                <div class="item"><span>电视类型：</span><span>人工智能 </span></div>  
                <div class="item"><span>选购指数：</span><span>6.9-6.0 </span></div>  
                <div class="item"><span>观看距离：</span><span>2m以下（≤32英寸）</span></div>  
              </div>              <!-- 详情内容 -->  
              <div class="detail">  
                <img src="https://yanxuan-item.nosdn.127.net/39d7f2407c90d0442566a719146ee9c1.jpg" alt=""  
                  data-v-2c43c764=""><img src="https://yanxuan-item.nosdn.127.net/7dfee58e7c6b3996badf368610ed62b1.jpg"  
                  alt="" data-v-2c43c764=""><img  
                  src="https://yanxuan-item.nosdn.127.net/d1acff1a29bddd21c2ad337d892a9f7c.jpg" alt=""  
                  data-v-2c43c764=""><img src="https://yanxuan-item.nosdn.127.net/ac722b04b2014ac337d8db695ee46f0c.jpg"  
                  alt="" data-v-2c43c764=""><img  
                  src="https://yanxuan-item.nosdn.127.net/c63e36faa0848ee37c825897f5cec179.jpg" alt=""  
                  data-v-2c43c764=""><img src="https://yanxuan-item.nosdn.127.net/e0f13dbf14c8a2f07e86bf3df3ca002b.jpg"  
                  alt="" data-v-2c43c764="">  
              </div>            </div>            <div class="tab-pane" style="display: none;">评价</div>  
          </div>          <!-- 注意事项 -->  
          <div class="warn">  
            <h3>注意事项</h3>  
            <p class="tit">• 购买运费如何收取？ </p>  
            <p>单笔订单金额(不含运费)满88元免邮费；不满88元，每单收取10元运费。（港澳台地区需满500元免邮费；不满500元，每单收取30元运费) </p>  
            <br>            <br>            <p class="tit">• 使用什么快递发货? </p>  
            <p>默认使用顺丰快递发货(个别商品使用其他快递） </p>  
            <p>配送范围覆盖全国大部分地区(港澳台地区除外）。 </p>  
            <br>            <br>            <p class="tit">• 如何申请退货? </p>  
            <p>1.自收到商品之日起30日内，顾客可申请无忧退货，退款将原路返还，不同的银行处理时间不同，预计1-5个工作日到账； </p>  
            <p>2.内裤和食品等特殊商品无质量问题不支持退货； </p>  
            <p>3.退货流程： 确认收货-申请退货-客服审核通过-用户寄回商品-仓库签收验货-退款审核-退款完成； </p>  
            <p>4.因小兔鲜儿产生的退货，如质量问题，退货邮费由小兔鲜儿承担，退款完成后会以现金券的形式报销。因客户个人原因产生的退货，购买和寄回运费由客户个人承担。</p>  
          </div>        </div>        <div class="aside">  
          <div class="tit">24小时热销榜</div>  
          <div class="product">  
            <img src="./uploads/fresh_goods_3.jpg" alt="">  
            <p class="name">USB Type C数据线</p>  
            <p class="desc">快速充电，稳定传输</p>  
            <p class="price">¥29</p>  
          </div>          <div class="product">  
            <img src="./uploads/fresh_goods_3.jpg" alt="">  
            <p class="name">USB Type C数据线</p>  
            <p class="desc">快速充电，稳定传输</p>  
            <p class="price">¥29</p>  
          </div>          <div class="product">  
            <img src="./uploads/fresh_goods_3.jpg" alt="">  
            <p class="name">USB Type C数据线</p>  
            <p class="desc">快速充电，稳定传输</p>  
            <p class="price">¥29</p>  
          </div>          <div class="tit">专题推荐</div>  
          <div class="special">  
            <img src="./uploads/discuss_goods_1.jpg" alt="">  
            <p class="name">一往无前，诞生于崛起</p>  
          </div>          <div class="special">  
            <img src="./uploads/discuss_goods_1.jpg" alt="">  
            <p class="name">一往无前，诞生于崛起</p>  
          </div>          <div class="special">  
            <img src="./uploads/discuss_goods_1.jpg" alt="">  
            <p class="name">一往无前，诞生于崛起</p>  
          </div>        </div>      </div>    </div>  </div>  <!-- 公共底部 -->  
  <div class="xtx_footer clearfix">  
    <div class="wrapper">  
      <!-- 联系我们 -->  
      <div class="contact clearfix">  
        <dl>          <dt>客户服务</dt>  
          <dd class="chat">在线客服</dd>  
          <dd class="feedback">问题反馈</dd>  
        </dl>        <dl>          <dt>关注我们</dt>  
          <dd class="weixin">公众号</dd>  
          <dd class="weibo">微博</dd>  
        </dl>        <dl>          <dt>下载APP</dt>  
          <dd class="qrcode">  
            <img src="./uploads/qrcode.jpg">  
          </dd>          <dd class="download">  
            <span>扫描二维码</span>  
            <span>立马下载APP</span>  
            <a href="javascript:;">下载页面</a>  
          </dd>        </dl>        <dl>          <dt>服务热线</dt>  
          <dd class="hotline">  
            400-0000-000  
            <small>周一至周日 8:00-18:00</small>  
          </dd>        </dl>      </div>    </div>    <!-- 其它 -->  
    <div class="extra">  
      <div class="wrapper">  
        <!-- 口号 -->  
        <div class="slogan">  
          <a href="javascript:;" class="price">价格亲民</a>  
          <a href="javascript:;" class="express">物流快捷</a>  
          <a href="javascript:;" class="quality">品质新鲜</a>  
        </div>        <!-- 版权信息 -->  
        <div class="copyright">  
          <p>            <a href="javascript:;">关于我们</a>  
            <a href="javascript:;">帮助中心</a>  
            <a href="javascript:;">售后服务</a>  
            <a href="javascript:;">配送与验收</a>  
            <a href="javascript:;">商务合作</a>  
            <a href="javascript:;">搜索推荐</a>  
            <a href="javascript:;">友情链接</a>  
          </p>          <p>CopyRight &copy; 小兔鲜儿</p>  
        </div>      </div>    </div>  </div>  <script>  
    const small = document.querySelector('.small');  
    const middle = document.querySelector('.middle');  
    const large = document.querySelector('.large');  
    const layer = middle.querySelector('.layer');  
  
    small.addEventListener('mouseover', function (e) {  
      if (e.target.tagName === 'IMG') {  
        large.style.backgroundImage = `url(${this.querySelector('img').src})`  
        this.querySelector('ul li.active').classList.remove('active')  
        e.target.parentNode.classList.add('active')  
        middle.querySelector('img').src = `${e.target.src}`  
      }  
    })  
    middle.addEventListener('mouseenter', function () {  
      large.style.backgroundImage = `url(${this.querySelector('img').src})`  
      show()  
    })  
    middle.addEventListener('mouseleave', function () {  
      hide()  
    })  
    let layerTimer  
    // 展示遮罩层  
    middle.addEventListener('mousemove', function (e) {  
      clearTimeout(layerTimer)  
      let middleWidth = middle.offsetWidth  
      let middleHeight = middle.offsetHeight  
      let x = e.pageX - middle.getBoundingClientRect().left - layer.offsetWidth / 2  
      let y = e.pageY - middle.getBoundingClientRect().top - document.documentElement.scrollTop - layer.offsetHeight / 2  
      layer.style.display = 'block'  
      if (x < 0) x = 0  
      else x = Math.min(x, middleWidth - layer.offsetWidth)  
      layer.style.left = `${x}px`  
      if (y < 0) y = 0  
      else y = Math.min(y, middleHeight - layer.offsetHeight)  
      layer.style.top = `${y}px`  
      large.style.backgroundPosition = `${-x*2}px ${-y*2}px`  
    })  
  
    // 取消遮罩层  
    middle.addEventListener('mouseleave', function () {  
      layerTimer = setTimeout(function () {  
        layer.style.display = 'none'  
      }, 200);  
    })  
    large.addEventListener('mouseenter', function () {  
      show()  
    })  
    large.addEventListener('mouseleave', function () {  
      hide()  
    })  
    let largeTimer  
    function show() {  
      clearTimeout(largeTimer)  
      large.style.display = 'block'  
    }  
  
    function hide() {  
      largeTimer = setTimeout(function () {  
        large.style.display = 'none'  
      }, 200);  
    }  
  </script>  
</body>  
</html>
```

## 获取 `<select>` 标签中所选的元素

```js
document.querySelector('select').value
```

## 富文本编辑器：WangEditor

>快速开始：<https://www.wangeditor.com/>

配置例子：

```js
// 富文本编辑器  
// 创建编辑器函数，创建工具栏函数  
const { createEditor, createToolbar } = window.wangEditor  
  
const editorConfig = {  
    placeholder: '发布文章',  
    onChange(editor) {  
        const html = editor.getHtml()  
        console.log('editor content', html)  
        // 也可以同步到 <textarea>        // 为了后续快速收集整个表单内容做铺垫  
        document.querySelector('.publish-content').value = html  
    }  
}  
  
// 编辑区配置对象  
const editor = createEditor({  
    // 创建位置  
    selector: '#editor-container',  
    // 默认内容  
    html: '<p><br></p>',  
    // 编辑器配置项目  
    config: editorConfig,  
    // 配置集成模式  
    mode: 'default', // or 'simple'  
})  
  
// 工具栏配置对象  
const toolbarConfig = {}  
  
// 创建工具栏  
const toolbar = createToolbar({  
    // 为指定编辑器创建工具栏  
    editor,  
    // 工具栏创建的位置  
    selector: '#toolbar-container',  
    // 工具栏配置对象  
    config: toolbarConfig,  
    // 配置集成模式  
    mode: 'default', // or 'simple'  
})
```
