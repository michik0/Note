# 1 Ajax

## 1.1 什么是 Ajax？
 
### 1.1.1 概念

Ajax：Asynchronous JavaScript And XML，异步的JavaScript和XML。

### 1.1.2 作用

- 数据交换：通过Ajax可以给服务器发送请求，并获取服务器响应的数据。
- 异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想、用户名是否可用的校验等等。

## 1.2 同步和异步

**同步：** 在客户端向服务器发送请求之后，直到服务器处理后逻辑产生响应之后客户端才能执行其他操作。（比如在搜索框内输入网址访问后，只有整个html页面加载出来了，但是点击任何一个地方都没法跳转，只有整个页面完全加载完成，在服务器端响应完成之后，在网页上的操作才会有反应。）

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230826161055.png)

**异步：** 并行处理，程序向服务器发送一个请求，在结果返回之前，还是可以执行其它操作，不需要等待响应结果。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230826161108.png)

## 1.3 XML

XML 被设计用来传输和存储数据。HTML 被设计用来显示数据。XML 指可扩展标记语言

XML被设计用来传输和存储数据，其焦点是数据的内容。HTML被设计用来显示数据，其焦点是数据的体现

# 2 Axios

## 2.1 Axios定义

Axios 是一个基于 _[promise](https://javascript.info/promise-basics)_ 网络请求库，作用于[`node.js`](https://nodejs.org/) 和浏览器中。 它是 _[isomorphic](https://www.lullabot.com/articles/what-is-an-isomorphic-application)_ 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 `node.js` `http` 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。

## 2.2 Axios 文件

```html
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
```

## 2.3 Axios 语法

```js
axios(config)
```

config 为请求对象，包括以下属性：

```js
{
	// `url` 是用于请求的服务器 URL
	url: '/user',
	
	// `method` 是创建请求时使用的方法
	method: 'get', // 默认值
	
	// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。
	// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL
	baseURL: 'https: //some-domain.com/api/',
	
	// `transformRequest` 允许在向服务器发送前，修改请求数据
	// 它只能用于 'PUT', 'POST' 和 'PATCH' 这几个请求方法
	// 数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream
	// 你可以修改请求头。
	transformRequest: [function (data, headers) {
		// 对发送的 data 进行任意转换处理
		return data;
	}],
	
	// `transformResponse` 在传递给 then/catch 前，允许修改响应数据
	transformResponse: [function (data) {
		// 对接收的 data 进行任意转换处理
		return data;
	}],
	
	// 自定义请求头
	headers: {'X-Requested-With': 'XMLHttpRequest'
	},

	// `params` 是与请求一起发送的 URL 参数
	// 必须是一个简单对象或 URLSearchParams 对象
	params: {
		ID: 12345
	},
	
	// `paramsSerializer`是可选方法，主要用于序列化`params`
	// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)
	paramsSerializer: function (params) {
		return Qs.stringify(params,{arrayFormat: 'brackets'})
	},
	
	// `data` 是作为请求体被发送的数据
	// 仅适用 'PUT', 'POST', 'DELETE' 和 'PATCH' 请求方法
	// 在没有设置 `transformRequest` 时，则必须是以下类型之一:
	// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams
	// - 浏览器专属: FormData, File, Blob
	// - Node 专属: Stream, Buffer
	data: {
		firstName: 'Fred'
	},
	
	// 发送请求体数据的可选语法
	// 请求方式 post
	// 只有 value 会被发送，key 则不会
	data: 'Country=Brasil&City=Belo Horizonte',
	
	// `timeout` 指定请求超时的毫秒数。
	// 如果请求时间超过 `timeout` 的值，则请求会被中断
	timeout: 1000, // 默认值是 `0` (永不超时)

	// `withCredentials` 表示跨域请求时是否需要使用凭证
	withCredentials: false, // default
	
	// `adapter` 允许自定义处理请求，这使测试更加容易。
	// 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）。
	adapter: function (config) {
		/* ... */
	},
	
	// `auth` HTTP Basic Auth
	auth: {
		username: 'janedoe',
		password: 's00pers3cret'
	},
	
	// `responseType` 表示浏览器将要响应的数据类型
	// 选项包括: 'arraybuffer', 'document', 'json', 'text', 'stream'
	// 浏览器专属：'blob'
	responseType: 'json', // 默认值
	
	// `responseEncoding` 表示用于解码响应的编码 (Node.js 专属)
	// 注意：忽略 `responseType` 的值为 'stream'，或者是客户端请求
	// Note: Ignored for `responseType` of 'stream' or client-side requests
	responseEncoding: 'utf8', // 默认值
	
	// `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称
	xsrfCookieName: 'XSRF-TOKEN', // 默认值
	
	// `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称
	xsrfHeaderName: 'X-XSRF-TOKEN', // 默认值
	
	// `onUploadProgress` 允许为上传处理进度事件
	// 浏览器专属
	onUploadProgress: function (progressEvent) {
		// 处理原生进度事件
	},
	
	// `onDownloadProgress` 允许为下载处理进度事件
	// 浏览器专属
	onDownloadProgress: function (progressEvent) {
		// 处理原生进度事件
	},
	
	// `maxContentLength` 定义了node.js中允许的HTTP响应内容的最大字节数
	maxContentLength: 2000,
	
	// `maxBodyLength`（仅Node）定义允许的http请求内容的最大字节数
	maxBodyLength: 2000,
	
	// `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。
	// 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，
	// 则promise 将会 resolved，否则是 rejected。
	validateStatus: function (status) {
		return status >= 200 && status < 300; // 默认值
	},
	
	// `maxRedirects` 定义了在node.js中要遵循的最大重定向数。
	// 如果设置为0，则不会进行重定向
	maxRedirects: 5, // 默认值
	
	// `socketPath` 定义了在node.js中使用的UNIX套接字。
	// e.g. '/var/run/docker.sock' 发送请求到 docker 守护进程。
	// 只能指定 `socketPath` 或 `proxy` 。
	// 若都指定，这使用 `socketPath` 。
	socketPath: null, // default
	
	// `httpAgent` and `httpsAgent` define a custom agent to be used when performing http
	// and https requests, respectively, in node.js. This allows options to be added like
	// `keepAlive` that are not enabled by default.
	httpAgent: new http.Agent({ keepAlive: true}),
	httpsAgent: new https.Agent({ keepAlive: true}),
	
	// `proxy` 定义了代理服务器的主机名，端口和协议。
	// 您可以使用常规的`http_proxy` 和 `https_proxy` 环境变量。
	// 使用 `false` 可以禁用代理功能，同时环境变量也会被忽略。
	// `auth`表示应使用HTTP Basic auth连接到代理，并且提供凭据。
	// 这将设置一个 `Proxy-Authorization` 请求头，它会覆盖 `headers` 中已存在的自定义 `Proxy-Authorization` 请求头。
	// 如果代理服务器使用 HTTPS，则必须设置 protocol 为`https`
	proxy: {
		protocol: 'https',
		host: '127.0.0.1',
		port: 9000,
		auth: {
			username: 'mikeymike',
			password: 'rapunz3l'
		}
	},
	
	// see https://axios-http.com/zh/docs/cancellation
	cancelToken: new CancelToken(function (cancel) {}),

	// `decompress` indicates whether or not the response body should be decompressed
	// automatically. If set to `true` will also remove the 'content-encoding' header
	// from the responses objects of all decompressed responses
	// - Node only (XHR cannot turn off decompression)
	decompress: true // 默认值
}
```

## 2.4 无参数调用

```js
axios({
	url: '目标资源地址'
}).then((result) => {
	// 对服务器返回的数据做处理
})
```

```js
axios({  
    url: 'http://hmajax.itheima.net/api/province',  
}).then((result) => {  
    document.querySelector('body').innerHTML = result.data.list.join('<br>')  
})
```

## 2.5 URL参数调用

使用 axios 提供的 params 选项

```js
axios({
	url: '目标资源地址',
	params: {
		参数名1: 值1,
		参数名2: 值2
	}
}).then(result => {
	// 后续处理
})
```

```js
axios({  
    url: 'http://hmajax.itheima.net/api/area',  
    params: {  
        pname: '福建省',  
        cname: '福州市'  
    }  
}).then((result) => {  
    console.log(result)  
})
```

## 2.6 带有请求方式调用

### 2.6.1 常用的请求方式

当对服务器资源进行访问时，需要携带有请求方式，`method` 默认为 get

| 请求方式 | 操作             |
| -------- | ---------------- |
| GET      | 获取数据         |
| POST     | 提交数据（全部）         |
| PUT      | 修改数据         |
| DELETE   | 删除数据                 |
| PATCH    | 修改数据（部分） |

### 2.6.2 调用语法

```js
axios({
	url: '目标资源地址',
	method: '请求方式',
	// 请求体（Body）参数
	data: {
		参数1: 值1,
		参数2: 值2
	}
}).then(result => {
	// 后续处理
})
```

## 2.7 Axios错误请求

当服务器抛出错误时，前端会产生错误信息，影响程序执行，我们需要将错误信息直观地呈现给用户

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230827095905.png)

在 then 方法的后面，通过调用 catch 方法，传入**回调函数**并定义形参，即可处理异常

```js
axios({
	// 请求选项
}).then(result => {
	// 处理数据
}).catch(error => {
	// 处理错误
})
```

```js
axios({  
  url: 'http://hmajax.itheima.net/api/register',  
  method: 'POST',  
  data: {  
    username: 'itheima151212',  
    password: '7654321'  
  }  
}).then(result => {  
  console.log(result)  
}).catch(err => {  
  alert(err.response.data.message)  
})
```

## 2.8 案例-图书管理系统

```js
const creator = 'michiko'  
function getBooksList() {  
    axios({  
        url: 'http://hmajax.itheima.net/api/books',  
        method: 'get',  
        params: {  
            creator: creator  
        }  
    }).then(result => {  
        const bookList = result.data.data  
        const tbody = bookList.map((book, index) => {  
            return `  
                <tr>                    <td>${index+1}</td>  
                    <td>${book.bookname}</td>  
                    <td>${book.author}</td>  
                    <td>${book.publisher}</td>  
                    <td data-id="${book.id}">  
                    <span class="del">删除</span>  
                    <span class="edit">编辑</span>  
                    </td>                </tr>            `        }).join('')  
        // result  
        document.querySelector('tbody.list').innerHTML = tbody  
    }).catch(err => {  
        alert(err.response.data.message)  
    })}  
  
/**  
 * 渲染图书列表  
 */  
getBooksList()  
  
/**  
 * 保存图书  
 * @type {Element}  
 */  
const addModalDom = document.querySelector('.add-modal');  
const addModal = new bootstrap.Modal(addModalDom)  
document.querySelector('.add-btn').addEventListener('click', () => {  
    // 收集表单元素  
    const addForm = document.querySelector('.add-form');  
    const addFormData = serialize(addForm, {hash: true, empty: true})  
    axios({  
        url: 'http://hmajax.itheima.net/api/books',  
        method: 'post',  
        data: {  
            ...addFormData,  
            creator  
        }  
    }).then(result => {  
        getBooksList()  
        addForm.reset()  
        addModal.hide()  
    })})  
  
/**  
 * 删减图书  
 */  
document.querySelector('.list').addEventListener('click', e => {  
    if (e.target.classList.contains('del')) {  
        const bookId = e.target.parentNode.dataset.id  
        axios({  
            url: `http://hmajax.itheima.net/api/books/${bookId}`,  
            method: 'delete',  
        }).then(result => {  
            getBooksList()  
        })    }})  
  
/**  
 * 编辑图书（代入数据）  
 */  
const editModalDom = document.querySelector('.edit-modal');  
const editModal = new bootstrap.Modal(editModalDom)  
document.querySelector('.list').addEventListener('click', e => {  
    if (e.target.classList.contains('edit')) {  
        editModal.show()  
        const bookId = e.target.parentNode.dataset.id  
        // 数据代入  
        axios({  
            url: `http://hmajax.itheima.net/api/books/${bookId}`,  
            method: 'get',  
        }).then(result => {  
            const book = result.data.data;  
            for(let k in book) {  
                document.querySelector(`.edit-form [name="${k}"]`).value = book[k]  
            }        })    }})  
  
// 修改图书（修改按钮）  
document.querySelector('.edit-btn').addEventListener('click', () => {  
    const editForm = document.querySelector('.edit-form');  
    const {id, bookname, author, publisher} = serialize(editForm, {hash: true, empty: true});  
    axios({  
        url: `http://hmajax.itheima.net/api/books/${id}`,  
        method: 'put',  
        data: {  
            bookname,  
            author,  
            publisher,  
            creator}  
    }).then(result => {  
        getBooksList()  
    })    editModal.hide()  
})
```

## 2.9 图片上传



# 附件

## 1 表单元素快速收集插件（`form-serialize` 插件）

>官网：<https://www.npmjs.com/package/form-serialize>

`form-serialize` 插件的作用：快速收集表单元素的值

>语法

- 参数

- form：表单元素
- hash：设置获取数据结构
	- true，表示获取得到的是JS对象 {name: 'michiko', age: 18}，推荐和接口文档参数名一致
	- false，表示获取得到的是查询字符串 name=michiko&age=18
- empty：是否获取空值
	- true：获取空值
	- false：不获取空值，即返回值对象中不存在为空值的属性

- 返回值

表单元素的name值，将会作为对象的属性名

```js
serialize(form, {hash: true, empty: true});  
```

```js
const form = document.querySelector('.example-form');  
const data = serialize(form, {hash: true, empty: true});  

console.log(data)
```

>`form-serilize.js`

```js
// get successful control from form and assemble into object  
// http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2  
  
// types which indicate a submit action and are not successful controls  
// these will be ignored  
var k_r_submitter = /^(?:submit|button|image|reset|file)$/i;  
  
// node names which could be successful controls  
var k_r_success_contrls = /^(?:input|select|textarea|keygen)/i;  
  
// Matches bracket notation.  
var brackets = /(\[[^\[\]]*\])/g;  
  
// serializes form fields  
// @param form MUST be an HTMLForm element  
// @param options is an optional argument to configure the serialization. Default output  
// with no options specified is a url encoded string  
//    - hash: [true | false] Configure the output type. If true, the output will  
//    be a js object.  
//    - serializer: [function] Optional serializer function to override the default one.  
//    The function takes 3 arguments (result, key, value) and should return new result  
//    hash and url encoded str serializers are provided with this module  
//    - disabled: [true | false]. If true serialize disabled fields.  
//    - empty: [true | false]. If true serialize empty fields  
function serialize(form, options) {  
    if (typeof options != 'object') {  
        options = { hash: !!options };  
    }    else if (options.hash === undefined) {  
        options.hash = true;  
    }  
    var result = (options.hash) ? {} : '';  
    var serializer = options.serializer || ((options.hash) ? hash_serializer : str_serialize);  
  
    var elements = form && form.elements ? form.elements : [];  
  
    //Object store each radio and set if it's empty or not  
    var radio_store = Object.create(null);  
  
    for (var i=0 ; i<elements.length ; ++i) {  
        var element = elements[i];  
  
        // ingore disabled fields  
        if ((!options.disabled && element.disabled) || !element.name) {  
            continue;  
        }        // ignore anyhting that is not considered a success field  
        if (!k_r_success_contrls.test(element.nodeName) ||  
            k_r_submitter.test(element.type)) {  
            continue;  
        }  
        var key = element.name;  
        var val = element.value;  
  
        // we can't just use element.value for checkboxes cause some browsers lie to us  
        // they say "on" for value when the box isn't checked        if ((element.type === 'checkbox' || element.type === 'radio') && !element.checked) {  
            val = undefined;  
        }  
        // If we want empty elements  
        if (options.empty) {  
            // for checkbox  
            if (element.type === 'checkbox' && !element.checked) {  
                val = '';  
            }  
            // for radio  
            if (element.type === 'radio') {  
                if (!radio_store[element.name] && !element.checked) {  
                    radio_store[element.name] = false;  
                }                else if (element.checked) {  
                    radio_store[element.name] = true;  
                }            }  
            // if options empty is true, continue only if its radio  
            if (val == undefined && element.type == 'radio') {  
                continue;  
            }        }        else {  
            // value-less fields are ignored unless options.empty is true  
            if (!val) {  
                continue;  
            }        }  
        // multi select boxes  
        if (element.type === 'select-multiple') {  
            val = [];  
  
            var selectOptions = element.options;  
            var isSelectedOptions = false;  
            for (var j=0 ; j<selectOptions.length ; ++j) {  
                var option = selectOptions[j];  
                var allowedEmpty = options.empty && !option.value;  
                var hasValue = (option.value || allowedEmpty);  
                if (option.selected && hasValue) {  
                    isSelectedOptions = true;  
  
                    // If using a hash serializer be sure to add the  
                    // correct notation for an array in the multi-select                    // context. Here the name attribute on the select element                    // might be missing the trailing bracket pair. Both names                    // "foo" and "foo[]" should be arrays.                    if (options.hash && key.slice(key.length - 2) !== '[]') {  
                        result = serializer(result, key + '[]', option.value);  
                    }                    else {  
                        result = serializer(result, key, option.value);  
                    }                }            }  
            // Serialize if no selected options and options.empty is true  
            if (!isSelectedOptions && options.empty) {  
                result = serializer(result, key, '');  
            }  
            continue;  
        }  
        result = serializer(result, key, val);  
    }  
    // Check for all empty radio buttons and serialize them with key=""  
    if (options.empty) {  
        for (var key in radio_store) {  
            if (!radio_store[key]) {  
                result = serializer(result, key, '');  
            }        }    }  
    return result;  
}  
  
function parse_keys(string) {  
    var keys = [];  
    var prefix = /^([^\[\]]*)/;  
    var children = new RegExp(brackets);  
    var match = prefix.exec(string);  
  
    if (match[1]) {  
        keys.push(match[1]);  
    }  
    while ((match = children.exec(string)) !== null) {  
        keys.push(match[1]);  
    }  
    return keys;  
}  
  
function hash_assign(result, keys, value) {  
    if (keys.length === 0) {  
        result = value;  
        return result;  
    }  
    var key = keys.shift();  
    var between = key.match(/^\[(.+?)\]$/);  
  
    if (key === '[]') {  
        result = result || [];  
  
        if (Array.isArray(result)) {  
            result.push(hash_assign(null, keys, value));  
        }        else {  
            // This might be the result of bad name attributes like "[][foo]",  
            // in this case the original `result` object will already be            // assigned to an object literal. Rather than coerce the object to            // an array, or cause an exception the attribute "_values" is            // assigned as an array.            result._values = result._values || [];  
            result._values.push(hash_assign(null, keys, value));  
        }  
        return result;  
    }  
    // Key is an attribute name and can be assigned directly.  
    if (!between) {  
        result[key] = hash_assign(result[key], keys, value);  
    }    else {  
        var string = between[1];  
        // +var converts the variable into a number  
        // better than parseInt because it doesn't truncate away trailing        // letters and actually fails if whole thing is not a number        var index = +string;  
  
        // If the characters between the brackets is not a number it is an  
        // attribute name and can be assigned directly.        if (isNaN(index)) {  
            result = result || {};  
            result[string] = hash_assign(result[string], keys, value);  
        }        else {  
            result = result || [];  
            result[index] = hash_assign(result[index], keys, value);  
        }    }  
    return result;  
}  
  
// Object/hash encoding serializer.  
function hash_serializer(result, key, value) {  
    var matches = key.match(brackets);  
  
    // Has brackets? Use the recursive assignment function to walk the keys,  
    // construct any missing objects in the result tree and make the assignment    // at the end of the chain.    if (matches) {  
        var keys = parse_keys(key);  
        hash_assign(result, keys, value);  
    }    else {  
        // Non bracket notation can make assignments directly.  
        var existing = result[key];  
  
        // If the value has been assigned already (for instance when a radio and  
        // a checkbox have the same name attribute) convert the previous value        // into an array before pushing into it.        //        // NOTE: If this requirement were removed all hash creation and        // assignment could go through `hash_assign`.        if (existing) {  
            if (!Array.isArray(existing)) {  
                result[key] = [ existing ];  
            }  
            result[key].push(value);  
        }        else {  
            result[key] = value;  
        }    }  
    return result;  
}  
  
// urlform encoding serializer  
function str_serialize(result, key, value) {  
    // encode newlines as \r\n cause the html spec says so  
    value = value.replace(/(\r)?\n/g, '\r\n');  
    value = encodeURIComponent(value);  
  
    // spaces should be '+' rather than '%20'.  
    value = value.replace(/%20/g, '+');  
    return result + (result ? '&' : '') + encodeURIComponent(key) + '=' + value;  
}
```
