>官网：https://cn.vuejs.org/

# ↓↓↓↓↓↓↓↓↓↓↓↓↓↓ Vue2 ↓↓↓↓↓↓↓↓↓↓↓↓

# 1 Vue 快速上手
## 1.1 Vue 是什么

概念：Vue是一个用于 **构建用户界面** 的 **渐进式** **框架**

### 1.1.1 构建用户页面

Vue 能够基于数据动态渲染页面

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906084228.png)

### 1.1.2 渐进式

Vue 有包括很多插件，但是核心包可以进行局部模块的改造

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906083913.png)

Vue 的两种使用方式：

1. Vue核心包开发，场景：**局部**模块改造
2. Vue核心包&Vue插件工程化开发，场景：**整站**开发

### 1.1.3 框架

框架是一套完整的项目解决方案，可以提升开发效率

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906084702.png)

## 1.2 创建实例

核心步骤：

1. 准备容器
2. 引包（官网）- 开发版本/生产版本
3. 创建Vue实例new Vue()
4. 指定配置项→渲染数据
	1. el 指定挂载点
	2. data 提供数据

```html
<div id="app">  
    <!-- 编写用于渲染的代码逻辑  -->  
    {{ msg }}  
</div>  
  
<!-- 引入的是开发版本包~包含完整的注释和警告 -->  
<script src="https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js"></script>  
  
<script>  
    // 一旦引入了 VueJS 核心包，在全局环境下，就有了 Vue 构造函数  
    const app = new Vue({  
        // 通过 el 配置选择起，指定 Vue 管理的是那个盒子  
        el: '#app',  
        // 通过 data 可以提供渲染的数据  
        data: {  
            msg: 'Hello Michiko'  
        }  
    })  
</script> 
```

## 1.3 插值表达式

插值表达式是一种 Vue 的模板语法

### 1.3.1 作用

利用表达式进行插值，渲染到页面中

### 1.3.2 语法：{{ 表达式 }}

```html
<h3>{{ tit1e }}</h3>
<p>{{ nickname.toUppercase() }}</p>
<p>{{ age >= 18 ? '成年' : '未成年' }}</p>
<p>{{ obj.name }}</p>
```

### 1.3.3 注意

1. 使用的数据必须在 data 中被定义

2. 支持的是表达式，而非语句，所以不支持 if，for ... 

```html
<p>{{ if }}</p>
```

3. 不能在标签属性中使用 `{{ }}` 插值

```html
<p title="{{ username }}">p标签</p>
```

## 1.4 Vue 核心特性：响应式

除了基本的模板渲染，Vue 背后还做了大量工作，比如说数据的响应式处理

数据的响应式处理→响应式：**数据变化，视图自动更新**

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906095133.png)

使用Vue开发，关注业务的核心逻辑，根据业务修改数据即可

data中的数据，最终会被添加到实例上，我们可以通过 `实例.属性名` 来获取数据，通过 `实例.属性名 = 值` 来修改属性

```js
const app = new Vue({  
    el: '#app',  
    data: {  
        msg: 'Hey!'  
    }  
})  
// 两秒后，属性被修改成 Hi!
setTimeout(() => {  
    app.msg = 'Hi!'  
}, 2000)
```

# 2 Vue 指令

Vue会根据不同的 **指令**，针对标签实现不同的 **功能**。

指令：带有 `v-前缀` 的特殊 `标签属性`

## 2.1 v-html

`v-html` 可以更新元素的 `innerHTML`。

```html
<div v-html="str"></div>
```

## 2.2 v-show 与 v-if

### 2.2.1 v-show

#### 作用

`v-show` 用来控制元素显示隐藏

#### 语法

```html
<!-- 表达式值true显示，false隐藏 -->
v-show="表达式"
```

`v-show` 通过切换 css 的 `display:none` 来控制显示隐藏

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906102017.png)

#### 使用场景

频繁切换显示隐藏的场景

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906102207.png)

### 2.2.2 v-if

#### 作用

`v-if` 用来控制元素显示隐藏（条件渲染）

#### 语法

```html
<!-- 表达式值true显示，false隐藏 -->
v-if="表达式"
```

#### 原理

基于条件判断，进行创建或移除元素节点

#### 场景

要么显示，要么隐藏，不频繁切换的场景

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906102232.png)

## 2.3 v-else 与 v-else-if

### 2.3.1 作用

辅助 `v-if` 进行判断渲染，注意：**需要紧挨着 `v-if` 一起使用**

### 2.3.2 语法

```html
v-if="表达式"
v-else-if="表达式"
v-else
```

```html
<p v-if="gender === 1">性别：♂ 男</p>  
<p v-else>性别：♀ 女</p>  
<hr>  
<p v-if="score > 90">成绩评定A：奖励电脑一台</p>  
<p v-else-if="score > 70 && score <= 90">成绩评定B：奖励周末郊游</p>  
<p v-else-if="score > 60 && score <= 70">成绩评定C：奖励零食礼包</p>  
<p v-else>成绩评定D：惩罚一周不能玩手机</p>
```

## 2.4 v-on

### 2.4.1 作用

为元素注册事件

注册事件 = 添加监听 + 提供处理逻辑

### 2.4.2 语法

#### 语法一

```html
v-on:事件名="内联语句"
```

```html
<button v-on:click="count--">-</button>  
<span>{{ count }}</span>  
<button v-on:click="count++">+</button>  
```

#### 语法二

```html
v-on:事件名="methods中的函数名"
```

```html
<div id="app">  
  <button v-on:click="changeShow">切换显示隐藏</button>  
  <h1 v-show="show" >黑马程序员</h1>  
</div>  
```

```js
const app = new Vue({  
	el: '#app',  
	data: {  
	  show: true  
	},  
	// 方法
	methods: {  
	  // 提供处理逻辑函数  
	  changeShow() {  
	    // this 指向当前实例
		this.show = !this.show  
	  }  
	}  
})  
```

#### 简写

`v-on:` 可以替换为 `@`，即 `v-on:click` 可以简写为 `@click`

#### 调用传参

当 v-on 提供的处理逻辑为函数时，可以进行调用传参，即：

```html
<button v-on:click="fn(参数1, 参数2)"></button>
```

```js
const app = new Vue({
	el: '#app',
	methods: {
		fn(a, b) {
			console.log(a, b)
		}
	}
})
``` 

## 2.5 v-bind

### 2.5.1 作用

动态地设置 html 的**标签属性** → src，url，title 等

### 2.5.2 语法

```html
v-bind:属性名="表达式"
```

```js
<img v-bind:src="imgUrl">
```

### 2.5.3 简写

`v-bind` 可以进行简写，`v-bind:属性名` 可以简写为 `:属性名`，即 `v-bind:src` 等价于 `:src`

### 2.5.4 v-bind 样式控制的增强

为了方便开发者进行**样式控制**，Vue 扩展了 v-bind 的语法，可以针对 **class类名** 和 **style行内样式** 进行控制。

####  操作 class

```html
:class="对象/数组"
```

##### 对象

键就是类名，值是布尔值。如果值为true，有这个类，否则没有这个类

```html
<div class="box" :class="{ 类名1: 布尔值, 类名2: 布尔值 }"></div>
```

```html
<div class="box" :class="{ pink: true, big: true }">michiko</div>
```

##### 数组

数组中的所有类，都回添加到盒子上。本质上就是一个 class 列表

```html
<div class="box" :class="[ 类名1, 类名2, 类名3 ]"></div>
```

```html
<div class="box" :class="['pink', 'big']">michiko</div>
```

#### 操作 style

```html
:style="样式对象"
```

```html
<div class="box" :style="{ CSS属性名1: CSS属性值, CSS属性名2: CSS属性值 }"></div>
```

```html
<div class="box" :style="{ width: '400px', backgroundColor: 'pink ' }"></div>
```

#### 使用场景

某个具体属性的动态设置，比如说进度条

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906193932.png)


## 2.6 v-for

### 2.6.1 作用

基于**数据**循环，**多次渲染**整个元素

`v-for` 可以遍历数组，对象，数字等

### 2.6.2 语法

```html
<!--  index 可省略 -->
v-for="(item[, index]) in 数组"
```

```html
<ul>  
  <li v-for="(item, index) in list">{{ index + 1 }} - {{ item }}</li>  
</ul>
```

### 2.6.3 v-for 中的 key

#### 为什么需要 key？

1. 下面，我们使用了 `v-for` 渲染出4本，并且第一本的背景色为粉色

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906163106.png)

2. 现在删除第一本书，发现背景色还在

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906163226.png)

分析原因：是因为 `v-for` 的默认行为会尝试原地修改元素（就地复用），只是把文字给做了修改，但是样式却还在

解决办法：使用 `key`

#### 作用

`v-for` 中的 `key` 给列表项添加的**唯一标识**，便于 Vue 进行列表项的**正确排序复用**。

#### 语法

```html
:key属性="唯一标识"
```

#### 注意点

1. key的值只能是**字符串或数字类型**
2. key的值必须具有**唯一性**
3. 推荐使用 id 作为 key(唯一)，不推荐使用 index 作为 key（会变化，不对应）

## 2.7 v-model

### 2.7.1 作用

`v-model` 可以给**表单元素**使用，

**双向数据绑定** → 可以快速**获取或设置**表单元素内容

- 数据变化 -> 表单自动更新
- 表单变化 -> 数据自动更新

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906164615.png)

### 2.7.2 语法

```html
v-model="变量"
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230906164902.png)

### 2.7.3 v-model 应用于其他表单元素

常见的表单元素都可以用 `v-model` 绑定关联，快速获取或设置表单元素的值

`v-model` 会根据控件类型自动选取正确的方法来更新元素

>输入框

input:text -> value

>文本域

textarea -> value

>复选框

input:checkbox -> checked

>单选框

input:radio -> checked

>下拉菜单

select -> value


## 2.8 指令修饰符

通过 `.` 指明一些指令后缀，不同后缀封装了不同的处理操作，可以大幅简化代码

### 2.8.1 按键修饰符

#### `@keyup.enter`：监听键盘回车时间

```html
<input @keyup.enter="fn" v-model="username" type="text">
```

### 2.8.2 v-model 修饰符

#### `v-model.trim`：去除首尾空格

```html
姓名：<input v-model.trim="username" type="text"><br>  
```

#### `v-model.number`：转数字

```html
年纪：<input v-model.number="age" type="text"><br>
```

### 2.8.3 事件修饰符

#### `事件名.stop`：阻止冒泡

```html
<div @click="fatherFn" class="father">  
  <div @click.stop="sonFn" class="son">儿子</div>  
</div>
```

#### `事件名.prevent`：阻止默认行为

```html
<a @click.prevent href="http://www.baidu.com">阻止默认行为</a>
```

# 3 计算属性

## 3.1 概念

基于现有的数据，计算出来的新属性。依赖的数据变化，自动重新计算。

## 3.2 语法

- 声明在 `computed` 配置项中，一个计算属性对应一个函数
- 使用起来和普通属性一样使用 `{{ 计算属性名 }}`

```js
computed: {
	计算属性名 () {
		// 基于现有数据，编写求值逻辑
		return 结果
	}
}
```

## 3.3 应用

```html
总数：{{ totalGiftNum }} 个
```

```js
computed: {  
  totalGiftNum() {  
	// 求得总数
    return this.list.reduce((sum, curVal) => sum + curVal.num, 0)  
  }  
}
```

## 3.4 computed 计算属性 与 methods 方法

>computed 计算属性

作用：封装了一段对于数据的处理，求得一个结果。

缓存特性：计算属性会对计算出来的**结果缓存**，再次使用**直接读取缓存**，**依赖项变化了，会自动重新计算，并再次缓存**

>methods 方法

作用：给实例提供一个方法，调用以处理业务逻辑。

## 3.5 计算属性完整写法

计算属性**默认的简写**，只能读取访问，不能”修改"。

```js
computed: {
	计算属性名: {
		get() {
			// 基于现有数据，编写求值逻辑
			return 结果
		},
		set(修改的值) {
			// 基于现有数据，编写修改逻辑
		}
	}
}
```

```html
姓：<input v-model="firstName" type="text"><br>  
名：<input v-model="lastName" type="text"><br>  
<p>姓名：{{ fullName }}</p>  
<button @click="fullName = 'M多多'">修改姓名</button>
```

```js
computed: {  
  fullName: {  
    get() {  
      return this.firstName + this.lastName  
    },  
    set(newName) {  
      this.firstName = newName.substring(0, 1)  
      this.lastName = newName.substring(1)  
    }  
  }  
}
```

# 4 watch 监听器（监视器）

## 4.1 作用

`watch` 可以监视数据变化，执行一些业务逻辑或异步操作。

## 4.2 语法

```js
data: {
	words: '苹果',
	obj: {
		words: '苹果'
	}
},
watch: {
	// 该方法会在数据变化时，触发执行
	数据属性名 (newValue, oldValue) {
		// 业务逻辑 或 异步操作
	}
	'对象.属性名' (newValue, oldValue) {
		// 业务逻辑 或 异步操作
	}
}
```

## 4.3 应用

```js
const app = new Vue({  
  el: '#app',  
  data: {  
    words: '',  
    wordsAfterTranslate: '',  
    lang: 'italy'  
  },  
  watch: {  
    words (newVal, oldVal) {  
      this.translate(newVal, this.lang)  
    },  
    lang (newVal, oldVal) {  
      this.translate(this.words, newVal)  
    }  
  },  
  methods: {  
    translate(words, lang) {  
      axios({  
        url: 'https://applet-base-api-t.itheima.net/api/translate',  
        method: '',  
        params: { words, lang },  
      }).then(result => {  
        this.wordsAfterTranslate = result.data.data  
      })  
    }  
  }  
})
```

## 4.4 完整写法

当我们需要有多个对象监控时，我们通常会把这些对象丢到一个对象里面进行深度监视

watch 属性有额外配置：

- `deep`：是否开启深度监视
- `immediate`：页面加载后是否立即执行一次 handler 处理方法

```js
data: {
	obj: {
		words: '苹果',
		lang: 'english'
	}
},
watch: {
	// 该方法会在数据变化时，触发执行
	数据属性名: {
		// 深度监视
		deep: true,
		// 页面加载后是否立即执行一次 handler 处理方法
		immediate: true,
		// 监视属性发现变动后执行的操作
		handler (newVal) {
			// 业务逻辑 或 异步操作
		}
	}
}
```

```js
const app = new Vue({  
  el: '#app',  
  data: {  
    obj: {  
      words: '欢迎使用本翻译软件',  
      lang: 'italy'  
    },  
    wordsAfterTranslate: '',  
  },  
  watch: {  
    obj: {  
	  // 深度监视
      deep: true,  
      // 一进页面立刻执行 handler
      immediate: true,  
      handler (newVal) {  
        axios({  
          url: 'https://applet-base-api-t.itheima.net/api/translate',  
          method: '',  
          params: { words: newVal.words, lang: newVal.lang },  
        }).then(result => {  
          this.wordsAfterTranslate = result.data.data  
        })  
      }  
    }  
  }  
})
```

# 5 Vue 生命周期

生命周期：一个 Vue 实例从创建到销毁的整个过程。

生命周期四个阶段：

- 创建
- 挂载
- 更新
- 销毁

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230907225419.png)

Vue 生命周期过程中，会**自动运行一些函数**，被称为 **生命周期钩子** ，以便开发者可以在 **特定阶段** 运行**自己的代码**。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230907230216.png)

```js
// 创建阶段（准备数据）  
beforeCreate() {  
  console.log('beforeCreate 响应式数据准备好前')  
},  
created() {  
  // 可以处理业务逻辑，以及发起异步请求  
  console.log('created 响应式数据准备好后')  
},  
// 挂载阶段（渲染模板）  
beforeMount() {  
  console.log('beforeMount 模板渲染前')  
},  
mounted() {  
  // 可以操作 DOM 了  
  console.log('mounted 模板渲染后')  
},  
// 更新阶段（修改数据 -> 更新视图）  
beforeUpdate() {  
  console.log('beforeUpdate', document.querySelector('span').innerHTML)  
},  
updated() {  
  console.log('updated', document.querySelector('span').innerHTML)  
},  
// 卸载阶段  
beforeDestroy() {  
  // 清除掉一些Vue意外的资源占用，定时器，延时器  
  console.log('beforeDestroy')  
},  
destroyed() {  
  console.log('destroyed')  
}
```

# 6 工程化开发 & 脚手架 Vue CLI

开发Vue的两种方式:

1. 核心包传统开发模式：基于 html/css/js 文件，直接引入核心包，开发Vue。
2. 工程化开发模式：**基于构建工具（例如：webpack）的环境中开发Vue。**

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908105308.png)

>问题

- webpack 配置**不简单**
- **雷同**的基础配置
- **缺乏统一标准**

## 6.1 定义

`Vue CLI` 是 Vue 官方提供的一个全局命令工具，可以帮助我们快速创建一个开发Vue项目的标准化基础架子，**集成了webpack配置**

## 6.2 好处

1. 开箱即用，零配置
2. 内置 babel 等工具
3. 标准化

## 6.3 搭建步骤

1. 全局安装（一次）：`yarn global add @vue/cli` 或 `npmi @vue/cli -g`
2. 查看 Vue 版本：`vue --version`
3. 创建项目架子：`vue create project-name`
4. 启动项目（package.json目录下）：`yarn serve` 或 `npm run serve`

## 6.4 脚手架目录文件介绍 & 项目运行流程

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908113154.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908114352.png)

# 7 组件化开发

## 7.1 组件化

组件化：一个页面可以拆分成一个个组件，**每个组件有着自己独立的结构、样式、行为。**

便于维护，利于复用，提升效率。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908114701.png)

## 7.2 根组件

组件分类：普通组件，根组件

**根组件**：整个应用最上层的组件，包裹所有普通小组件。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908115904.png)

## 7.3 单文件组件的三个组成部分

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908134509.png)

- template：结构（Vue2中有且只能一个根元素）
- script：Js 逻辑
- style：样式（可支持 less 语法，需要装包）

>让组件支持 less

- `<style lang="less">` 开启 less 功能
- 装包：`yarn add less less-loader`

## 7.4 普通组件的注册使用

组件注册的两种方式：

1. 局部注册：只能在注册的组件内使用
2. 全局注册：所有组件内都能使用

### 7.4.1 局部注册

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230908163851.png)

##### 1. 创建 Vue 文件

>组件名规范使用**大驼峰命名法**，如：`MyHeader.vue`

```vue
<template>  
  <div id="myHeader" class="my-header">  
    我是头部组件  
  </div>  
</template>  
  
<script>  
export default {  
  
}  
</script>  
  
<style lang="less">  
  .my-header {  
    height: 100px;  
    line-height: 100px;  
    text-align: center;  
    font-size: 30px;  
    background-color: #8064a2;  
    color: white;  
  }  
  
</style>
```

##### 2. 在使用的组件中进行注册其他组件

```vue
<script>  
import 组件名 from "vue文件路径";  

export default {  
  components: {  
	'组件名': '组件对象'  
  }  
}  
</script>
```

##### 3. 在使用的组件中使用其他组件

```html
<template>
	<组件名></组件名>
</template>
```

### 7.4.2 全局注册

##### 1. 创建 Vue 文件

>组件名规范使用**大驼峰命名法**，如：`MyBtn.vue`

```js
<template>  

</template>  
  
<script>  

</script>  
  
<style lang="less">  
  
</style>
```

##### 2. **main.js** 中进行全局注册

```js
import 组件名 from "组件路径";  

Vue.component('组件名', 组件名)  
```

##### 3. 使用

```html
<组件名></组件名>
```

## 7.5 data 函数

组件的 data 选项必须是一个函数，保证每个组件实例，维护独立的一份数据对象。

```js
export default {  
  data() {  
    return {  
      count: 100,  
    }  
  },  
}
```

三个一样的组件，其 `data` 不一样，每个**组件实例**，维护独立的一份数据对象。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909093620.png)

# 8 组件的样式冲突

写在组件中的样式会**全局生效**，因此很容易造成多个组件之间的样式冲突问题。

为了防止样式冲突，我们可以给组件的 `<style>` 加上 `scoped` 属性，可以让**样式只作用于当前组件**

>scoped 原理

1. 当前组件内标签都被添加 `data-v-hash` 值的属性
2. css 选择器都被添加 `data-v-hash` 的属性选择器

最终效果：必须是当前组件的元素，才会有这个自定义属性，才会被这个样式作用到

# 9 组件通信

组件通信，就是指组件与组件之间的数据传递。由于组件的数据是独立的，无法直接访问其他组件的数据。所以想用其他组件的数据就需要组件通信

## 9.1 组件关系

组件关系分类：

1. 父子关系
2. 非父子关系

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909093952.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909093944.png)

## 9.2 通信解决方案

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909094054.png)

## 9.3 父子通信流程图

1. 父组件通过 `props` 将数据传递给子组件
2. 子组件利用 `$emit` 通知父组件修改更新

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909094302.png)

### 9.3.1 父 -> 子

1. 父组件通过 `:参数名` 将参数传递给子组件
2. 子组件通过定义 `props` 来进行参数的接收
3. 像平常属性一样使用 `{{}}` 进行参数的使用

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909095124.png)

### 9.3.2 子 -> 父

子组件无法直接修改修改父组件中的数据，子组件只能通知父组件进行修改

1. 子组件通过 `this.$emit('事件名', '参数')`
2. 父组件中添加消息监听 `@事件名="处理函数"`
3. 父组件中事先处理函数

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909100423.png)


## 9.4 非父子通信 - event bus 时间总线

`event bus` 可以在非父子组件之间，进行简易消息传递。

复杂场景：**使用 Vuex**

>步骤

1. 创建一个都能访问到的事件总线（空Vue实例，`utils/EventBus.js`）

```js
import Vue from 'vue'
const Bus = new Vue()
export default Bus
```

2. A组件（接收方），监听 Bus 实例的事件

```js
created() {
	Bus.$on('sendMsg', (msg) => {
		this.msg = msg
	})
}
```

3. B组件（发送方），触发 Bus 实例的事件

```js
Bus.$emit('sendMsg', '这是一个消息')
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909164012.png)

## 9.5 非父子通信 - provide & inject

provide & inject 作用：**跨层级**共享数据，子孙后代也可以进行取值使用

>步骤

1. 父组件 provide 提供数据

```js
export default {
	provide() {
		return {
			// 普通类型【非响应式】
			color: this.color,
			// 复杂类型【响应式】
			userInfo: this.useInfo
		}
	}
}
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909172312.png)

2. 子/孙组件 inject 取值使用

```js
export default {
	inject: ['color', 'userInfo']
	created() {
		console.log(this.color, this.userInfo)
	}
}
```

## 9.6 什么是 Prop ？

### 9.6.1 定义

Prop 是组件上注册的一些 `自定义属性`

### 9.6.2 作用

Prop 可以向子组件传递数据

### 9.6.3 特点

可以传递 **任意数量** 的 prop
可以传递 **任意类型** 的 prop

>父组件

```js
data() {  
  return {  
    username: '小帅',  
    age: 28,  
    isSingle: true,  
    car: {  
      brand: '宝马',  
    },  
    hobby: ['篮球', '足球', '羽毛球'],  
  }  
}
```

```html
<UserInfo  
    :username="username"  
    :age="age"  
    :isSingle="isSingle"  
    :car="car"  
    :hobby="hobby"  
></UserInfo>
```

>子组件

```js
props: [  
    'username',  
    'age',  
    'isSingle',  
    'car',  
    'hobby'  
]
```

```html
<div class="userinfo">  
  <h3>我是个人信息组件</h3>  
  <div>姓名：{{ username }}</div>  
  <div>年龄：{{ age }}</div>  
  <div>是否单身：{{ isSingle ? '是' : '否' }}</div>  
  <div>座驾：{{ car.brand }}</div>  
  <div>兴趣爱好：{{ hobby.join('，') }}</div>  
</div>
```

### 9.6.4 props 校验

开发者可以为组件的 props 指定验证要求，不符合要求，控制台就会有错误提示，以便帮助开发者，快速发现错误

#### 校验类型

- 类型校验
- 非空校验
- 默认值
- 自定义校验

#### 类型校验

```js
props: {
	// 类型可为 Number String Boolean 等等
	校验的属性名: 类型
}
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230909102528.png)

#### 非空校验 / 默认值 / 自定义校验

```js
props: {  
  w: {  
	// Number String Boolean 等等
    type: Number,  
    // 是否必填
    required: true,  
    // 默认值
    default: 默认值,  
    // 自定义校验逻辑
    validator(value) {  
      return 是否通过校验  
    }  
  }  
}
```

```js
props: {  
  w: {  
    type: Number,  
    // required: true,  
    default: 0,  
    validator(value) {  
      // 自定义校验逻辑  
      if (value >= 0 && value <= 100) {  
        return true  
      }  
      else {  
        console.error('prop 必须 0～100')  
        return false  
      }  
    }  
  }
}
```

### 9.6.5 prop 与 data

#### 共同点

prop 与 data 都可以给组件提供数据

#### 区别

- data 的数据属于各自组件，可以**随意修改**
- prop 的数据是外部的，**不能直接改**，遵循[[#^1faf98|单向数据流]]

>单向数据流

^1faf98

父组件的 props 更新，会单向向下流动，影响子组件

prop 如果想要修改，需要使用 `this.$emit()` 通知父组件进行修改

### 9.6.6 注意

#### 当父组件传递的参数名-时，子组件 props 中需要采用小驼峰接收

如果子组件在 `props` 接受的参数名带特殊符号，比如 `-`，那么在子组件需要转换为小驼峰进行获取，比如：

>父组件

```html
<TestComponent :test-id="1">
<TestComponent>
```

>子组件

```js
export default {
	props: {
		// 注意：这里需要转换为小驼峰
		testId: Number
	},
	created () {
		console.log(this.testid)
	}
}
```

### 9.6.7 拓展

当子组件中的值发生变化时，我们需要通知父组件，但是子组件只会返回单个改变的值，但是父组件除了要子组件中的值之外，也要其他的值，我们可以考虑二次封装，比如：

>父组件

```html
// 针对子组件的 $emit 触发，二次封装，传递给方法更多的值
<SonComponent :value="value" @input="(newValue) => change(newValue, 其他参数..)">
</SonComponent>
```

>子组件

```html
<input 
	   :value=value
	   @change="changeValue"
>
></input>
```

```js
export default {
	props: {
		value: Number
	},
	methods: {
		changeValue () {
			this.$emit()
		}
	}
}
```

# 10 进阶语法

## 10.1 vue-model 原理

### 10.1.1 原理

`v-model` 本质上是一个语法糖。例如应用在**输入框**上，就是 `value 属性` 和 `input事件` 的合写。 

`v-model` 用于在不同的控件上，属性和事件可能会有些区别，比如 `v-model` 如果作用于复选框上，那么底层就是 `checked属性` 与 `change事件` 的合写
### 10.1.2 作用

`v-model` 提供数据的双向绑定

```html
<input v-model="msg" type="text>
```

等价于

```html
<!-- $event 用于在模板中，获取事件的形参 -->
<!-- :value 可以将 msg 属性值显示在 input 框中 -->
<!-- @input 可以获取 input 事件，并且将 input 值赋值给 msg -->
<input :value="msg" @input="msg = $event.target.value" type="text>
```

### 10.1.3 表单类组件封装 & v-model 简化代码

#### 表单类组件封装

1. 父传子：数据应该是父组件 `props` 传递过来的，`v-model` 拆解绑定数据

```html
<BaseSelect  
    :cityId="selectId"  
    @changeId="handleChangeId"  
></BaseSelect>
```

2. 子传父：监听输入，子传父传值给父组件修改

```html
<select :value="cityId" @change="handleChange">  
  <option value="101">北京</option>  
  <option value="102">上海</option>  
  <option value="103">武汉</option>  
  <option value="104">广州</option>  
  <option value="105">深圳</option>  
</select>
```

```js
props: {  
  cityId: String  
},  
methods: {  
  handleChange(e) {  
    this.$emit('changeId', e.target.value)  
  }  
}
```

#### v-model 简化代码

父组件使用 `v-model` 简化代码，实现子组件和父组件数据双向绑定

**注意**：例子里面是单选框，所以 `v-model` 等价于 `:value="xx" @change="xx"`，如果是多选框，则 `v-model` 等价于 `:checked="xx" @change="xx"` ，需要根据不同的控件来选择不同的属性和事件

1. 子组件中：`props` 通过 `value` 接收，事件触发 `input`

```html
<div>  
  <select :value="value" @change="handleChange">  
    <option value="101">北京</option>  
    <option value="102">上海</option>  
    <option value="103">武汉</option>  
    <option value="104">广州</option>  
    <option value="105">深圳</option>  
  </select>  
</div>
```

```js
props: {  
  value: String  
},  
methods: {  
  handleChange(e) {  
    this.$emit('input', e.target.value)  
  }  
}
```

2. 父组件中：`v-model` 给组件直接绑数据

```html
<div class="app">  
  <!-- 由于输入框环境下， v-model 等价于 :value="msg" @input="msg = $event.target.value"，所以直接写 v-model -->  <BaseSelect  
    v-model="selectId"  
  ></BaseSelect>  
</div>
```

## 10.2 .sync 修饰符

### 10.2.1 作用

`.sync` 可以实现**子组件与父组件数据的双向绑定**，简化代码

### 10.2.2 特点

`prop` 属性名，可以自定义，非固定值 `value` 或者固定值 `checked`

>关于为什么是固定值参考 [[#v-model 简化代码|v-model 简化代码]]

### 10.2.3 场景

封装弹框类的基础组件，使用 `props.visible` 属性，其中 true：显示，false：隐藏

### 10.2.4 语法

这里通过控制弹窗的显示与隐藏展示语法

#### 父组件

```html
<!-- visiable 为 prop 属性值 -->
<BaseDialog :visiable.sync="isShow"/>
```

等价于

```html
<BaseDialog 
	:visiable="isShow"
	@update:visiable="isShow = $event"
/>
```

#### 子组件

```js
props: {
	visiable: Boolean
}
```

```js
this.$emit('update:visiable', false)
```

## 10.3 ref 和 $refs

### 10.3.1 作用

利用 `ref` 和 `$refs` 可以用于获取**组件内的 DOM 元素**，或**组件实例**

**注意**：`document.querySelector('xxx')` 会检索出页面上第一个，而不是组件内

### 10.3.2 特点

`ref` 与 `$refs` 的查找范围为当前组件内（更精确稳定）

### 10.3.3 语法

#### 获取 DOM 元素

```html
<div ref="chartRef">我是渲染图的容器</div>
```

```js
mounted() {
	console.log(this.$refs["chartRef"])
}
```

#### 获取组件实例

```html
<BaseForm ref="baseForm"></BaseForm>
```

```js
this.$refs["baseForm"].组件方法()
```

## 10.4 Vue 异步更新机制 & $nextTick

### 10.4.1 问题出现

>思考：我们想要点 `编辑按钮` ，显示输入框，并且让输入框聚焦

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230910115703.png)

我们可能会写出以下代码：

```js
// 显示输入框
this.isShowEdit = true
// 获取焦点
this.$refs.inp.focus()
```

但是问题就出现了，控制台打印显示 `this.$refs.inp` 是 undefined，这是为什么？

原因：**Vue是异步更新 DOM（提升性能）**

### 10.4.2 问题解决：$nextTick

`$nextTick` 可以等DOM更新后，才会触发执行此方法里的函数体

```js
this.$nextTick(() => {
	this.$refs.inp.focus()
})
```

# 11 自定义指令

自定义指令：自己定义的指令，可以**封装一些 DOM 操作**，扩展额外功能

## 11.1 基本语法（全局 & 局部注册）

### 11.1.1 注册自定义指令

#### 全局注册

```js
Vue.directive('指令名', {
	// inserted 表示当前这个元素被插入到页面当中后，执行一系列操作
	inserted(el) {
		// 对 el 标签的操作，扩展额外功能
		el.focus()          // 这里是对元素进行聚焦操作
	}
})
```

#### 局部注册

```js
directives: {
	指令名: {
		inserted (el) {
			// 对 el 标签的操作，扩展额外功能
		}
	}
}
```

### 11.1.2 使用自定义指令

```html
<input v-指令名 type="text">
```

## 11.2 指令的值

>需求：实现一个 color 指令，传入不同的颜色，给标签设置不同的字体颜色

### 11.2.1 语法

```html
<div v-color="color">我是内容</div>
```

通过 `binding.value` 可以拿到指令值，指令值**修改**会触发 `update` 函数。

```js
directives: {
	指令名: {
		inserted (el, binding) {
			// 对 el 标签的操作，扩展额外功能
			// binding 为传递的值
			el.style.color = binding.value
		},
		// 当指令值修改后，会触发 update 函数
		update (el, binding) {
			// 对 el 标签的操作，扩展额外功能
			// binding 为传递的值  
			el.style.color = binding.value
		}
	}
}
```

## 11.3 v-focus 指令封装

我们希望文本框自动对焦，可以使用自定义指令，以便多次使用

```js
Vue.directive('focus', {  
  inserted(el) {  
    el.focus()  
  }})
```

```html
<input v-focus type="class">
```

## 11.4 v-loading 指令封装

>场景：实际开发过程中，发送请求需要时间，在请求的数据未回来时，页面会处于空白状态，影响用户体验

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230911224653.png)

### 11.3.1 本质

1. loading 本质就是一个蒙层，盖在了盒子上
2. 数据请求中，开启 loading 状态，添加蒙层
3. 数据请求完毕，关闭 loading 状态，移除蒙层

### 11.3.2 实现

1. 准备一个 loading 类，通过伪元素定位，设置宽高，实现蒙层
2. 开启关闭 loading 状态（添加移除蒙层），本质只需要添加移除类即可
3. 结合自定义指令的语法进行封装复用

```html
<!-- 添加蒙层效果 -->
<div class="box" v-loading="isLoading">
	<ul>  
	  <li v-for="item in list" :key="item.id" class="news">  
	    <div class="left">  
	      <div class="title">{{ item.title }}</div>  
	      <div class="info">  
	        <span>{{ item.source }}</span>  
	        <span>{{ item.time }}</span>  
	      </div>  
	    </div>  
	  
	    <div class="right">  
	      <img :src="item.img" alt="">  
	    </div>  
	  </li>  
	</ul>
</div>
```

```css
/* 伪类 - 蒙层效果 */.loading:before {  
  content: '';  
  position: absolute;  
  left: 0;  
  top: 0;  
  width: 100%;  
  height: 100%;  
  background: #fff url('./loading.gif') no-repeat center;  
}
```

```js
directives: {  
  loading: {  
	  <!-- 数据返回后，取消蒙层 --> 
    inserted(el, binding) {  
      binding.value ? el.classList.add('loading') : el.classList.remove('loading')  
    }, 
    <!-- 数据返回后，取消蒙层 --> 
    update(el, binding) {  
      binding.value ? el.classList.add('loading') : el.classList.remove('loading')  
    }  
  }  
}
```

# 12 插槽

作用：让组件内部的一些**结构**支持**自定义**

场景：要在页面中显示一个对话框，封装成一个组件

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912102502.png)

## 12.1 默认插槽

1. 组件内需要定制的结构部分，改用 `<slot></slot>` 占位
2. 使用组件时，被调用的组件标签内部，传入结构替换 `<slot></slot>` 内容

### 12.1.1 语法

#### 子组件

```html
<div>
	<!-- 使用 slot 占位 -->
	<slot></slot>
</div>
```

#### 父组件

```html
<SonComponent>
	这里填写的内容会被插入到 slot 中
</SonComponent>
```

### 12.1.2 例子

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912111054.png)

## 12.2 后备内容

通过插槽完成了内容的定制，传什么显示什么，但是**如果不传，则是空白**，影响用户体验

>语法

在 `<slot>` 标签内，放置内容，作为默认显示内容

```html
<slot>我是插槽后备内容（默认值）</slot>
```

## 12.3 具名插槽

一个组件内有 **多处结构**  需要外部传入标签，进行定制

### 12.3.1 语法

1. 多个 `slot` 使用 `name` 属性区分名字
2. `template` 配合 `v-slot:名字` 来分发对应标签

#### 子组件

```html
<slot name="head"></slot>
```

#### 父组件

**简写**：`v-slot:插槽名` 可以简写为 `#插槽名`

```html
<template v-slot:head>
	大标题
</template>
```

### 12.3.2 应用

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912112913.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912113401.png)

## 12.4 作用域插槽

>**注意**：作用域插槽不属于插槽分类，是插槽的传参语法

定义 `slot` 插槽的同时，是可以**传递参数**的。给**插槽**上可以**绑定数据**，将来**使用组件时可以用**。

### 12.4.1 场景：封装表格组件

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912113423.png)

1. 父传子，动态渲染表格内容
2. 利用默认插槽，定制操作列
3. 删除或查看都需要用到 **当前项的id**，属于 **组件内部的数据**
4. 通过 **作用域插槽传值** 绑定，进而使用

### 12.4.2 语法

1. 给 `<slot></slot>` 标签，以添加属性的方式传值
2. 所有添加的属性，都会被收集到一个对象中
3. 在 `<template></template>` 中，通过 `#插槽名="obj"` 接收，默认插槽名为 `default`

#### 子组件

```html
<slot :属性值="值"></slot>
```

#### 父组件

```html
<!-- #default：表示默认插槽 -->  
<!-- obj：接受的来自于参数名，可以自定义 -->  
<template #default="插槽传递过来的属性值">  
	<!-- 访问属性 -->
	{{属性值.xxx}}
</template>
```

### 12.4.3 应用

![](https://raw.githubusercontent.com/michik0/notes-image/master/20230912134303.png)

# 13 路由入门（Vue Router3）

## 13.1 单页应用程序 SPA - Single Page Application

单页面应用（SPA）：所有功能在**一个html页面**上实现

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912155149.png)

>适用场景

- 单页面应用：系统类网站 / 内部网站 / 文档类网站 / 移动端站点
- 多页面应用：公司官网 / 电商类网站

## 13.2 路由概念

Vue中路由是路径和组件的映射关系

## 13.3 VueRouter 的基本使用

>官网：<https://v3.router.vuejs.org/zh/>

### 13.3.1 作用

`VueRouter` 可以在**修改地址栏路径**时，**切换显示**匹配的组件

### 13.3.2 使用

#### 1. 下载

下载 VueRouter 模块到当前工程，版本3.6.5（Vue2 对应 VueRouter 3.x，Vue3 对应 VueRouter 4.x）

```bash
npm i vue-router@3.6.5
```

#### 2. 引入

```js
import VueRouter from 'vue-router'
```

#### 3. 安装注册

```js
Vue.use(VueRouter)
```

#### 4. 创建路由对象

```js
const router = new VueRouter()
```

#### 5. 注入

将路由对象注入到 `new Vue` 实例中，建立关联

```js
new Vue({
	render: h => h(App),
	// 注入 VueRouter
	router
}).$mount('#app')
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912165444.png)

#### 6. 创建需要的组件（views目录），配置路由规则

```js
const router = new VueRouter({  
  routes: [  
    { path: '/find', component: Find },  
    { path: '/my', component: My },  
    { path: '/friend', component: Friend }  
  ]  
})
```

#### 7. 配置导航，配置路由出口（路径匹配的组件显示的位置）

```html
<div class="footer_wrap">  
	<a href="#/find">发现音乐</a>  
	<a href="#/my">我的音乐</a>  
	<a href="#/friend">朋友</a>  
</div>  
<div class="top">  
	<!-- 匹配的组件所展示的位置 -->
	<router-view></router-view>  
</div>
```

## 13.4 组件目录存放问题

>路由相关的组件，为什么放在 `views` 目录呢？

### 13.4.1 组件分类

`.vue` 文件分2类：

- 页面组件
- 复用组件

他们的本质，都是 vue 文件

### 13.4.2 为什么需要分开放

分类开来，更易维护

**规范：**

- `src/views` 文件夹：**页面组件（页面展示）**，配合路由用
- `src/components` 文件夹：**复用组件（展示数据）**，常用于复用

# 14 路由进阶（Vue Router3）

## 14.1 路由模块的封装与抽离

随着项目越来越大，我们需要在 `main.js` 里面定义很多的路由，这样会非常不整洁，我们需要将路由模块抽离出来。

>步骤

1. 创建 `src/router/index.js`

```js
import VueRouter from "vue-router";  
import Find from "@/views/Find.vue";  
import Friend from "@/views/Friend.vue";  
import My from "@/views/My.vue";  
import Vue from "vue";  
  
// 使用 VueRouter 插件  
Vue.use(VueRouter)  
  
// 定义 routerconst router = new VueRouter({  
    routes: [  
        { path: '/find', component: Find },  
        { path: '/my', component: My },  
        { path: '/friend', component: Friend }  
    ]  
})  
  
// 导出 router
export default router
```

2. `main.js` 导入 router

```js
new Vue({  
  render: h => h(App),  
  router  
}).$mount('#app')
```

## 14.2 声明式导航

### 14.2.1 声明式导航

>需求：想要实现导航高亮的效果

`vue-router` 提供了一个全局组件 `router-link`（取代 `<a>` 标签）

#### 特点

- **能跳转**：配置 `to` 属性指定路径，本质还是 `<a>` 标签
- **能高亮**：默认就会提供**高亮类名**，可以直接设置高亮样式

#### 语法

```html
<router-link to="/find">发现音乐</router-link>
```

#### 实现高亮

`router-link` 会自动给当前导航添加了两个高亮类名：`router-link-active` 和 `router-link-exact-active`，因此我们可以通过CSS来控制高亮

```css
a.router-link-active {
	background-color: purple
}
```

### 14.2.2 精确匹配 & 模糊匹配

我们发现 `router-link` 自动给当前导航添加了两个高亮类名

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912201018.png)

#### router-link-active：模糊匹配（更加灵活）

`to="/my"` 可以匹配 `/my`、`/my/a`、`/my/b` ...

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912201841.png)

由于模糊匹配，高亮CSS依然可以匹配到

#### router-link-exact-active：精确匹配

`to="/my"` 仅可以匹配 `/my`

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912202004.png)

由于精确匹配，发现高亮CSS未生效

### 14.2.3 自定义高亮类名

`router-link` 默认的两个高亮类名太长了，我们可以自定义高亮类名

```js
const router = new VueRouter({
	routes: [...],
	linkActiveClass: "模糊匹配类名1",
	linkExactActiveClass: "精确匹配类名2"
})
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230912203309.png)

### 14.2.4 声明式导航传参

在跳转路由时，可以进行值的传递

#### 查询参数传参

##### 源头页面组件传递参数

```html
to="/path?参数名=参数值"
```

##### 目标页面组件获取参数

```js
{{ $route.query.参数名 }}
```

```js
this.$route.query.参数名
```

#### 动态路由传参

##### 配置动态路由

```js
const router = new VueRouter({  
  routes: [  
    { path: '/home', component: Home },  
    { path: '/search/:参数名', component: Search }  
  ]  
})
```

**注意**：`:参数名` 的方式必须需要传递参数，否则会匹配不到组件，如果希望不传递参数也能匹配，可以加个可选符 `?`，比如 `/search/:id?`

##### 源头页面组件传递参数

```html
to="/path/参数值"
```

##### 目标页面组件获取参数

```js
{{ $route.params.参数名 }}
```

```js
this.$route.params.参数名
```

#### 两种传参方式的区别

##### 查询参数传参

比较适合传多个参数

1. 跳转：`to="/path?参数1=值1&参数2=值2"`
2. 获取：`$route.query.参数名`

##### 动态路由传参

1. 配置动态路由：`path:"/path/参数名"`
2. 跳转：`to="/path/参数值"`
3. 获取：`$route.params.参数名`

## 14.3 路由重定向

### 14.3.1 路由重定向

#### 定义

网页打开，url 默认是 `/` 路径，未匹配到组件时，会出现空白

重定向：匹配到指定的 `path` 后，强制跳转至指定的目标路径

#### 语法

```js
const router = new VueRouter({  
  routes: [  
    { path: '/', redirect: '/home' },
    ...
  ]  
})
```

### 14.3.2 路由404

#### 作用

当路径找不到匹配时，我们希望给个提示页面

#### 位置

需要配置在**路由的最后**

#### 语法

```js
const router = new VueRouter({  
  routes: [  
    ...
    { path: '*', components: NotFind }
  ]  
})
```

### 14.3.3 路由模式

路由的路径看起来不自然，有 `#`

- `hash` 路由（默认），例如 `http://localhost:8080/#/home`
- `history` 路由，例如 `http://localhost:8080/home`

```js
const router = new VueRouter({
	routes,
	mode: 'history'
})
```

## 14.4 编程式导航

### 14.4.1 编程式导航

我们可以通过JS代码的方式来进行跳转

#### 1 path 路径跳转

```js
this.$router.push('路由路径')
```

```js
this.$router.push({
	path: '路由路径'
})
```

#### 2 path 路径返回

```js
this.$router.back()
```

#### 3 name 命名路由跳转（适合 path 路径长的场景）

##### 3.1 定义路由 name

```js
const router = new VueRouter({  
  routes: [  
	...
	// 定义路由名  
	{ name: 'search', path: '/search/:words?', component: Search },  
  ]  
})
```

##### 3.2 根据 name 跳转

```js
this.$router.push({
	name: '路由名'
})
```

#### 4. 跳转后返回原页面

##### 原页面
 
```js
this.$router.replace({
	path: '/login',
	query: {
		// fullPath 会包含查询参数，?后面的数据也会被一同携带
		backUrl: this.$route.fullPath
	}
})
```

##### 目标页面

```js
// 判断是否包含了 backUrl 属性，如果没有就返回主页
const backUrl = this.$route.query.backUrl || '/'  
// 替换当前的页面，避免重新创建页面而导致用户点返回会出现返回回登录页的情况
this.$router.replace(backUrl)
```

### 14.4.2 编程式导航传参

#### 1 path 路径跳转传参

##### 1.1 查询参数传参

###### 1.1.1 源头组件传递参数

```js
this.$router.push('路由路径?参数1=值1&参数2=值2')
```

```js
this.$router.push({
	path: '路由路径',
	query: {
		参数1: '值1',
		参数2: '值2'
	}
})
```

###### 1.1.2 目标组件获取值

```js
{{ $route.query.参数名 }}
```

##### 1.2 动态路由传参

###### 1.2.1 配置动态路由

```js
const router = new VueRouter({  
  routes: [  
    { path: '/home', component: Home },  
    { path: '/search/:参数名', component: Search }  
  ]  
})
```

###### 1.2.2 源头组件传递参数

```js
this.$router.push('路由路径/参数值')
```

```js
this.$router.push({
	path: '路由路径/参数值'
})
```

###### 1.2.3 目标组件获取值

```js
{{ $route.params.参数名 }}
```

#### 2 name 命名路由跳转传参

##### 2.1 查询参数传参

```js
this.$router.push() {
	name: '路由名字',
	query: {
		参数1: '值1'
	}
}
```

```js
{{ $route.query.参数名 }}
```

##### 2.2 动态路由传参

```js
this.$router.push() {
	name: '路由名字',
	params: {
		// 这边需要与路由配置中的路径一致
		参数1: '值1'
	}
}
```

```js
{{ $route.params.参数名 }}
```

## 14.5  组件缓存 keep-alive

### 14.5.1 为什么需要组件缓存？

当我们从组件A跳转到组件B，又从组件B返回到组件A时，**由于路由跳转后，A组件被销毁了**，而后返回到组件A时，组件A需要重新构建，耗费事件，影响用户体验

### 14.5.2 定义

`keep-alive` 是 Vue 的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。

`keep-alive` 是一个抽象组件：它自身不会渲染成一个 DOM 元素，也不会出现在父组件链中。

### 14.5.3 优点

在组件切换过程中把切换出去的组件保留在内存中，防止重复渲染DOM，减少加载时间及性能消耗，提高用户体验性。

### 14.5.4 用法

```html
<div>
	<!-- 所匹配的一级路由都会被缓存，这里是Layout和Detail都会被缓存 -->
	<!-- 如果只需要 包含/排除 部分，参考 15.5 三个属性 -->
	<keep-alive>
		<router-view></router-view>
	</keep-alive>
</div>
```

### 14.5.5 keep-alive 三个属性

| 属性    | 说明                                   |
| ------- | -------------------------------------- |
| include | **组件名**数组，只有匹配的组件会被缓存     |
| exclude | **组件名**数组，任何匹配的组件都不会被缓存 |
| max     | 最多可以缓存多少组件实例                                       |

```html
<keep-alive :include="['LayoutPage']">  
  <router-view></router-view>  
</keep-alive>
```

### 14.5.6 注意

如果组件被缓存了，那第二次进入缓存的页面，将**不会触发 `created` 和 `mounted` 这两个钩子函数了**，理所当然，**由于被缓存了，`destroyed` 钩子函数也不会触发**。

Vue 提供了新的两个钩子函数：`actived` 和 `deactived`

```js
activated() {  
  console.log('组件被激活了（进入页面）')  
},  
deactivated() {  
  console.log('组件失活（离开页面）')  
}
```


## 14.6 二级路由

当我们需要在路由中嵌套路由时，可以采用二级路由，比如：有如下一级路由

>`Layout.vue`

```html
<div class="h5-wrapper">  
  <div class="content">  
    <!-- 二级路由出口，匹配到的二级路由就会在这展示 -->  
    <router-view></router-view>  
  </div>  
  <nav class="tabbar">  
    <router-link to="/article">面经</router-link>  
    <router-link to="/collect">收藏</router-link>  
    <router-link to="/like">喜欢</router-link>  
    <router-link to="/user">我的</router-link>  
  </nav>  
</div>
```

我们希望在 `<router-view>` 中重新嵌套一个路由，用于展示，我们可以采用二级路由

```js
routes: [  
	// 一级路由
	{  
		path: '/',  
		component: Layout,
		// 二级路由，内容将会展示在 Layout.vue 中的 <router-view> 中
		children: [  
			{  
				path: '/article',  
				component: Article  
			},  
			{  
				path: '/collect',  
				component: Collect  
			},  
			{  
				path: '/like',  
				component: Like  
			},  
			{  
				path: '/user',  
				component: User  
			}  
		]  
	},  
	// 一级路由
	{ 
		path: '/detail/:id?', 
		component: ArticleDetail 
	}  
]
```

## 14.7 路由导航守卫：页面访问拦截

^10661c

**注意**：Vue3（Vue Router 4）中的写法不同，参考[[#^7a2ec4|Vue Router4路由导航守卫]]

### 14.7.1 背景

在一些电商系统中，大部分页面，游客都可以直接访问，如遇到需要登录才能进行的操作，提示并跳转到登录。但是，对于支付页，订单页等，**必须是登录的用户才能访问的，游客不能进入该页面，需要做拦截处理。**

### 14.7.2 路由导航守卫

当一个导航触发（路由发生改变）时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 **等待中**。

1. 所有的路由一旦被匹配到，都会先经过全局前置守卫
2. 只有全局前置守卫放行，才会真正解析渲染组件，才能看到页面内容

### 14.7.3 配置路由导航守卫

```js
const router = new VueRouter({  
  routes  
})  
  
// to: Route: 即将要进入的目标 路由对象  
// from: Route: 当前导航正要离开的路由  
// next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。  
// next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。  
// next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。  
// next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。  
// next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。  
const authUrl = ['/pay', '/myOrder', '/user']  
router.beforeEach((to, from, next) => {  
  if (!authUrl.includes(to.path) || store.getters.token) next()  
  else next('/login')  
})
```

## 14.8 路由懒加载

参考 [[#^0c9e63|打包优化：路由懒加载]]


# 15 自定义创建项目

在创建项目的时候，如果我们每次都要自己去搭建架子，那么太费事了，我们可以通过 `vue create` 自定义一个架子

## 15.1 步骤

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913135750.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913135845.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913140524.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913140423.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913140516.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913140544.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913140819.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913140623.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913140606.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913140707.png)

## 15.2 生成结果

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913141110.png)

# 16 ESLint && Prettier &&  Husky

## 16.1 ESLint：代码规范工具

### 16.1.1 介绍

>官网：<https://standardjs.com/readme-zhcn>

ESLint 可以定义了代码一系列的规范，不符合规范将会给予警告或者报错，以下列出一部分：

- 字符串使用单引号：'abc'
- 无分号：const name = 'zs'
- 关键字后加空格：if (name = 'ls') { ... }
- 函数名后加空格：function name (arg) { ... }
- 坚持使用全等 `===`

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913142940.png)

### 16.1.2 ESLint 参考配置（`.eslintrc.cjs`）

```jsx
rules: {
	'prettier/prettier': [
	  // 设置 prettier 规范，如果不符合，将会提示警告
	  // 如果需要利用 prettier 自动格式化代码，那么需要在 `.prettierrc.json` 中包含有同样的属性
	  'warn',
	  {
		singleQuote: true, // 单引号
		semi: false, // 无分号
		printWidth: 80, // 每行宽度至多80字符
		trailingComma: 'none', // 不加对象|数组最后逗号
		endOfLine: 'auto' // 换行符号不限制（win mac 不一致）
	  }
	],
	'vue/multi-word-component-names': [
	  'warn',
	  {
		ignores: ['index'] // vue组件名称多单词组成（忽略index.vue）
	  }
	],
	'vue/no-setup-props-destructure': ['off'], // 关闭 props 解构的校验
	// 💡 添加未定义变量错误提示，create-vue@3.6.3 关闭，这里加上是为了支持下一个章节演示。
	'no-undef': 'error'
}
```

## 16.2 Prettier：代码格式化工具

### 16.2.1 介绍

>官网：<https://www.prettier.cn/>

`Prettier` 是一款代码格式化工具，按保存键时，代码就被格式化了，节省时间和精力。

可以在创建项目时，添加 `Prettier` 工具，也可参考[官网教程](https://www.prettier.cn/docs//install.html)进行安装

`Prettier` 会根据 `.prettierrc.json` 所配置的属性，进行代码的格式化

### 16.2.2 WebStorm 配置 `Prettier`

**注意**：如果在 ESLint 中有针对代码格式化作出规范，并且想通过 `prettier` 进行自动格式化，那么**请确保 `.eslintrc.cjs`（设置 prettier 警告的部分） 和 `.prettierrc.json` 的相同属性请保持一致。**

Settings -> Languages & Frameworks -> Prettier

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230919101625.png)

## 16.3 ESLint 和 Prettier 的区别

- ESLint：根据规则，用来规范代码，比如：tab 必须是2个空格、声明的变量必须要使用，否则报错
- Prettier：根据规则进行代码的格式化，比如：将 tab 格式化为2个空格、去除对象后的逗号（，）

## 16.4 Husky：代码检查工具

>官网：https://typicode.github.io/husky/

### 16.4.1 介绍

虽然我们已经要求项目使用` ESLint` 了，但是不能保证组员提交代码之前都将 `ESLint` 中的问题解决掉了，我们希望保证代码仓库中的代码都是**符合 `ESLint` 规范**，那么我们在执行 `git commit` 命令的时候对其**进行校验**，如果不符合 `ESLint` 规范，那么自动通过规范进行修复；

### 16.4.2 配置 Husky

#### 1. 初始化 git 仓库

```bash
git init
```

#### 2. 初始化 husky 工具配置

```bash
pnpm dlx husky-init
```

```bash
pnpm install
```

#### 3. 修改 .husky/pre-commit 文件

```bash
#!/usr/bin/env sh  
. "$(dirname -- "$0")/_/husky.sh"  

# npm test

# 执行 lint 命令  
pnpm lint
```

#### 4. 故意提交错误，查看测试结果

发现提交失败，ESLint 检查出错误，这样保证提交后的代码提交符合 ESLint

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230919115312.png)

### 16.4.3 优化 Husky 配置

由于 `pnpm lint` 是全量检查，耗时较久，并且可能由于历史问题，导致无法保证旧代码符合规范，一定要所有的代码都符合 ESLint 才让提交，不合理。

我们每次新代码，都要先放在暂存区，才能提交，所以我们最好采用 **暂存区 ESLint 校验**

#### 1. 安装 lint-staged

```bash
pnpm i lint-staged -D
```

#### 2. package.json 配置 lint-staged 命令

```json
"lint-staged": {  
  "*.{js,ts,vue}": [  
    "eslint --fix"  
  ]  
}
```

```json
"scripts": {
	"lint-staged": "lint-staged"
}
```

#### 3. husky/pre-commit 文件修改

```bash
#!/usr/bin/env sh  
. "$(dirname -- "$0")/_/husky.sh"  
  
# 执行 lint-staged 命令  
pnpm lint-staged
```

#### 4. 故意提交错，测试代码

发现被 ESLint 拦下了，暂存区 ESLint 校验成功

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230919135746.png)


# 17 Vuex

## 17.1 定义

`Vuex` 是一个 Vue 的状态管理工具，可以帮我们**管理 `Vue` 通用的数据**（多组件共享的数据）

## 17.2 场景

- 某个状态在很多个组件来使用（个人信息）
- 多个组件共同维护一份数据（购物车）

## 17.3 为什么需要 Vuex

1. 共同维护一份数据，**数据集中化管理**
2. **响应式变化**
3. 操作简洁（`Vuex` 提供了辅助函数来供我们操作数据）

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913144224.png)

## 17.4 使用 Vuex

### 17.4.1 初始化空仓库

#### 1. 安装 Vuex

**注意**：`Vue 2.x` 对应 `Vuex 3.x`

```bash
npm i vuex@3
```

#### 2. 新建 Vuex 模块文件

新建 `store/index.js` 放置 `Vuex`

#### 3. 创建仓库

```js
Vue.use(Vuex)  
// 创建仓库  
const store = new Vuex.Store()  
  
export default store
```

#### 4. `main.js` 导入挂载

在 `main.js` 中导入挂载到 `Vue` 实例上

```js
new Vue({  
  render: h => h(App),  
  store  
}).$mount('#app')
```

### 17.4.2 核心概念：state（提供数据）

State 提供唯一的公共数据源，所有共享的数据都要统一放到 `Store` 中的 `State` 中存储。

在 `State` 对象中可以添加我们要共享的数据。

```js
Vue.use(Vuex)  
// 创建仓库  
const store = new Vuex.Store({
		// state 状态，即数据，类似于 Vue 组件中的 data
		// 区别：
		// 1. data是组件自己的据
		// 2. state所件享据
		state: {
			count: 100
		}
	}
)

export default store
```

### 17.4.3 获取数据

#### `<template>` 中获取数据

```html
{{ $store.state.xxx }}
```

#### `<script>` 中获取数据

```js
this.$store.state.xxx
```

#### js 文件中获取数据

```js
import store from 'xxx'

store.state.xxx
```

### 17.4.4 辅助函数：mapState（优化 state）

`mapState` 是辅助函数，帮助我们把 `store` 中的数据**自动**映射到**组件的计算属性**中

#### 导入 mapState

```js
import { mapState } from 'vuex'
```

#### 数组方式引入 state

```js
mapState(['count', 'title', ...])
```

#### 将 mapState 中的属性展开放到 computed 中

```js
computed: {  
  ...mapState(mapState(['count', 'title']))  
}
```

等价于：

```js
computed: {
	count: this.$store.state.count,
	title: this.$store.state.title
}
```

#### 使用 computed 属性

```html
{{ count }}
```

### 17.4.5 核心概念：mutations（修改数据）

>**注意**：Vuex 同样遵循单向数据流，**组件中不能直接修改仓库的数据**

#### 组件中不允许直接修改仓库数据

例如，`this.$store.state.count++` 是不被允许的，但是出于性能的考虑，Vue 不会进行报错

若希望开启严格的单项数据流，则可以**开启严格模式（上线的时候需要关闭，因为消耗性能）**：

```js
const store = Vue.Store({
	// 严格模式
	strict: true
})
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230913170818.png)

#### 语法

state 数据的修改只能通过 `mutations`

##### 1. 定义 mutations 对象，对象中存放修改 state 的方法

```js
const store = new Vuex.Store({  
  // 开启严格模式，上线后需要关闭，因为消耗性能  
  strict: true,  
  state: {  
    title: '大标题',  
    count: 100  
  },  
  mutations: {  
    // 修改count数据的方法  
    // 第一个参数：state    
    // 第二个参数：自定义的业务传递参数
    // 注意：提交参数只能一个，如果有多个参数，包装成一个对象传递
    addCount (state, n) {  
      state.count += n
    }  
  }  
})
```

##### 2. 组件中提交调用 mutations

```js
const num = 5
this.$store.commit('addCount', num)
```

### 17.4.6 辅助函数：mapMutations（优化 mutations）

在通过 `mutations` 修改时，需要在组件内部定义一个方法，方法里面调用 `this.$store.commit('xxx')` 过于繁琐

因此，可以通过 `mapMutations` 进行简化

`mapMutations` 和 `mapState` 很像，它是把位于 `mutations` 中的方法提取了出来，映射到组件 `methods` 中

```js
import { mapMutations } from 'vuex'  
  
export default {  
  name: 'Son2Com',  
  methods: {  
    ...mapMutations(['subCount'])  
  }  
}  
```

```html
// 可以直接调用，参数会被传递到 mutations 的指定方法的参数中
<div @click="subCount(1)"></div>
```

### 17.4.7 核心概念：actions（处理异步操作）

#### 定义

`actions` 用来处理异步操作，比如：在1秒钟后，修改 `state.count` 为 666

**注意**：

1. 不能直接使用 `mutations`，因为 **`mutations` 中的代码必须是同步的**，以下代码是**不允许的**：

```js
mutations: {  
  editCount (state, num) {  
    setTimeout(() => {  
      state.count = num  
    }, 1000)  
  }  
}
```

2. `actions` 中不能直接操作 `state`，`state` 只能由 `mutations` 进行修改
#### 语法

##### 1. 提供 actions 方法

```js
const store = new Vuex.Store({  
	// ....
	mutations: {  
		editCount (state, num) {  
		  state.count = num  
		}  
	},  
	actions: {  
		// count：上下文  
		// num：额外参数  
		changeCountAsync (context, num) {  
			setTimeout(() => {  
				context.commit('editCount', num)  
			}, 1000)  
		}  
	}  
})
```

##### 2. 调用 actions 方法

```js
<script>  
export default {  
	name: 'Son1Com',  
	methods: {  
		handleChange () {  
		// 调用 actions      
		this.$store.dispatch('changeCountAsync', 666)  
	}  
}  
</script>
```

### 17.4.8 辅助函数：mapActions（优化 actions）

`mapActions` 和 `mapMutations` 类似，`mapActions` 是把位于 **`actions` 中的方法**提取了出来，映射到**组件 `methods`** 中

```js
import { mapActions } from 'vuex'

export default {  
  name: 'Son2Com',  
  methods: {  
    ...mapActions(['changeCountAsync'])  
  }  
}  
```

```html
// 直接调用
<div @click="changeCountAsync(888)"></div>
```

### 17.4.9 核心概念：getters（派生 state）

除了 `state` 之外，有时我们还需要从 `state` 中**派生出一些状态**，这些状态是依赖 s`state` 的，此时会用到 `getters`

#### 场景

`state` 中定义了 list，为 1-10 的数组，组件中，需要显示所有大于5的数据

```js
state: {
	list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
}
```

#### 语法

##### 1. 定义 getters

```js
getters: {  
	// 第一个参数为 state
	// 第二个【可选】参数为 getters，可以调用当前的 getters
	filterList (state[, getters]) {  
		return state.list.filter(item => item > 5)  
	}  
}
```

##### 2. 获取 getters 数据

```js
<label>{{ $store.getters.filterList }}</label>
```

### 17.4.10 辅助函数：mapGetters（优化 getters）

`mapGetters` 和 `mapState` 类似，`mapGetters` 是把 `getters` 中的数据**自动**映射到**组件的 `computed` 属性**中

```js
computed: {  
  ...mapGetters(['filterList'])  
}
```

```html
<label>{{ filterList }}</label>
```

## 17.5 进阶语法：模块 module

### 17.5.1 为什么需要模块

由于 Vuex 使用**单一状态树**，应用的所有状态会**集中到一个比较大的对象**。当应用变得非常复杂时，store  对象就有可能变得相当臃肿。当项目变得越来越大的时候，Vuex 会变得越来越难以维护

```js
const store = new Vuex.Store({  
	state: {
		...
	},
	mutations: {
		...
	},
	actions: {
		...
	},
	getters: {
		...
	}
})
```

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230914110430.png)

### 17.5.2 拆分步骤

#### 1. 创建各自模块的js文件

##### `src/store/modules/user.js`

```js
// user 模块  
const state = {  
  userInfo: {  
    name: 'michiko',  
    age: 18  
  },  
  score: 100  
}  
const mutations = {}  
const actions = {}  
const getters = {}  
  
export default {  
  state,  
  mutations,  
  actions,  
  getters  
}
```

##### `src/store/modules/setting.js`

```js
// setting 模块  
const state = {  
  theme: 'light',  
  desc: 'setting模块'  
}  
const mutations = {}  
const actions = {}  
const getters = {}  
  
export default {  
  state,  
  mutations,  
  actions,  
  getters  
}
```

#### 2. `src/store/index.js` 引入子模块

```js
import user from '@/store/modules/user'  
import setting from '@/store/modules/setting'

const store = new Vuex.Store({  
	// ...
	modules: {  
		user,  
		setting  
	}  
	// ...
})
```

### 17.5.3 访问子模块 state

尽管已经分模块了，但其实子模块的 state，还是会挂到根级别的 state 中，属性名就是模块名

#### 语法一：直接通过模块名访问 

```js
$store.state.模块名.xxx
```

#### 语法二：通过 mapState 映射

`mapState(['xxx'])` 默认是根级别的映射，如果需要子模块的映射**需要在子模块JS开启命名空间**

##### 1. 开启命名空间

```js
export default {
	namespaced: true,
	state: {
		...
	},
	mutations: {
		...
	},
	actions: {
		...
	},
	getters: {
		...
	}
}
```

##### 2. mapState 映射

```js
computed: {  
  ...mapState('模块名', ['属性名1', '属性名2', ...])
}
```

##### 3. 获取数据

```html
<span>{{ 属性名 }}</span>
```

### 17.5.4 访问子模块 getters

访问子模块 getters 和 访问子模块 state 类似

#### 语法一：直接通过模块名访问 

```js
$store.getters['模块名/xxx']
```

#### 语法二：通过 mapGetters 映射

`mapGetters(['xxx'])` 默认是根级别的映射，如果需要子模块的映射**需要在子模块JS开启命名空间**

##### 1. 开启命名空间

```js
export default {
	namespaced: true,
	state: {
		...
	},
	mutations: {
		...
	},
	actions: {
		...
	},
	getters: {
		...
	}
}
```

##### 2. mapGetters 映射

```js
computed: {  
  ...mapGetters('模块名', ['属性名1', '属性名2', ...])
}
```

##### 3. 获取数据

```html
<span>{{ 属性名 }}</span>
```

### 17.5.5 调用子模块 mutations

默认模块中的 `mutations` 会被挂载到全局，需要开启命名空间，才会挂载到子模块。

#### 语法一：直接通过模块名调用

```js
$store.commit('模块名/xxx', 额外参数)
```

#### 语法二：通过 mapMutations 映射

`mapMutations(['xxx'])` 默认是根级别的映射，如果需要子模块的映射**需要在子模块JS开启命名空间**

##### 1. 开启命名空间

```js
export default {
	namespaced: true,
	state: {
		...
	},
	mutations: {
		...
	},
	actions: {
		...
	},
	getters: {
		...
	}
}
```

##### 2. mapMutations 映射

```js
method: {  
  ...mapMutations('模块名', ['方法名1', '方法名2', ...])
}
```

##### 3. 调用方法

```html
<span @click="方法名"></span>
```

### 17.5.6 调用子模块 actions

默认模块中的 `actions` 会被挂载到全局，需要开启命名空间，才会挂载到子模块。

#### 语法一：直接通过模块名调用

```js
$store.dispatch('模块名/xxx', 额外参数)
```

#### 语法二：通过 mapActions 映射

`mapActions(['xxx'])` 默认是根级别的映射，如果需要子模块的映射**需要在子模块JS开启命名空间**

##### 1. 开启命名空间

```js
export default {
	namespaced: true,
	state: {
		...
	},
	mutations: {
		...
	},
	actions: {
		...
	},
	getters: {
		...
	}
}
```

##### 2. mapActions 映射

```js
method: {  
  ...mapActions('模块名', ['方法名1', '方法名2', ...])
}
```

##### 3. 调用方法

```html
<span @click="方法名"></span>
```

## 17.6 Vuex 持久化

>问题：每次页面刷新，Vuex 的数据都会清空

为了解决 Vuex 数据会清空的问题，我们需要将数据存储在 localStorage 下

但是由于项目越来越大，因此需要对 localStorage 的操作会变得很频繁，所以最好针对 localStorage 的操作放在一个文件中，方便复用

**解决**：封装 storage 存储模块，利用本地存储，进行 vuex 持久化处理

1. 创建 `src/utils/storage.js`

```js
// 提供针对 localStorage 的封装  
const USER_INFO_KEY = 'user-info'  
export const getUserInfo = () => {  
  const result = localStorage.getItem(USER_INFO_KEY)  
  return result ? JSON.parse(result) : { token: '', userId: '' }  
}  
  
// 设置个人信息  
export const setUserInfo = (userInfo) => {  
  localStorage.setItem(USER_INFO_KEY, JSON.stringify(userInfo))  
}  
  
// 移除个人信息  
export const removeUserInfo = () => {  
  localStorage.removeItem(USER_INFO_KEY)  
}
```

2. 在 `user.js` 中引入并且使用

```js
import { getUserInfo, setUserInfo } from '@/utils/storage'  
  
export default {  
  namespaced: true,  
  state: {  
    // 把本地的拿出来，放到 state 中
    userInfo: getUserInfo()  
  },  
  mutations: {  
	// 设置的时候，往本地存一份
    setAccessToken (state, userInfo) {  
      state.userInfo = userInfo  
      setUserInfo(userInfo)  
    }  
  }  
}
```


# 18 mixins 属性

## 18.1 定义

在一些项目中，我们会有很多公共的逻辑，比如：在电商项目中，用户未登录，就给用户提醒先登录。

如果在每个组件中都 CV 一次，那么非常的费时和难以维护，因此我们可以使用 `mixins` 来进行管理、引入、调用。

## 18.2 使用

### 1. 定义共有的 JS（src/mixins/testMixins.js）

```js
export default {  
	// 此处编写的就是Vue组件实例的配置项，通过一定语法，可以直接混入到组件内部  
	// 组件内能写的，在这都能写 data methods computed 声明周期函数...
	data () {
		return {
			title: 'hey!'
		}
	},
	created: {
		console.log('created')
	},
	methods: {
		sayHi () {
			console.log('Hi!')
		}
	}
	// ...
}
```

### 2. 组件中引入

```js
export default {
	mixins: ['testMixins']
}
```



# 19 打包发布

## 19.1 作用

Vue 脚手架只是开发过程中，协助开发的工具，脚手架不参与上线

打包的作用：

1. 将多个文件压缩合并成一个文件
2. 语法降级
3. less、sass、typescript 语法解析

打包后，可以生成，浏览器能够直接运行的网页

## 19.2 打包命令和配置

Vue 脚手架工具已经提供了打包命令，直接使用即可。

```bash
yarn build
```

### 19.2.1 结果

在项目的根目录会自动创建一个文件夹 `dist`，`dist` 中的文件就是打包后的文件，只需要放到服务器中即可。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230917233446.png)

### 19.2.2 配置

默认情况下，需要放到服务器根目录打开，如果希望双击运行，需要在 `vue.config.js` 配置 `publicPath` 配成相对路径

```js
const { defineConfig } = require('@vue/cli-service')  
module.exports = defineConfig({  
  // 配置为相对路径
  publicPath: './',  
  transpileDependencies: true  
})
```

## 19.3 打包优化：路由懒加载

^0c9e63

当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由**被访问的时候才加载对应组件**，这样就更加**高效**了。

### 19.3.1 配置步骤

```js
// 首页的单页面组件额不配置懒加载
import Layout from '@/views/layout/index.vue'  
import Cart from '@/views/layout/cart.vue'  
import Home from '@/views/layout/home.vue'  
import Category from '@/views/layout/category.vue'  
import User from '@/views/layout/user.vue'  
import store from '@/store'  

// 这里其他一级路由配置懒加载
const Login = () => import('@/views/login/index.vue')  
const Search = () => import('@/views/search/index.vue')  
const SearchList = () => import('@/views/search/list.vue')  
const ProductDetail = () => import('@/views/productDetail/index.vue')  
const Pay = () => import('@/views/pay/index.vue')  
const MyOrder = () => import('@/views/myOrder/index.vue')
```

### 19.3.2 结果

发现被打包为了多个JS，并且配置了懒加载的路由，只有在被访问的时候才会加载对应组件

![](https://raw.githubusercontent.com/michik0/notes-image/master/20230917235103.png)

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230917235329.png)

# ↓↓↓↓↓↓↓↓↓↓↓↓↓↓ Vue3 ↓↓↓↓↓↓↓↓↓↓↓↓

# 20 create-vue

`create-vue` 是 Vue 官方新的脚手架工具，底层切换到了 Vite（下一代构建工具)，为开发提供极速响应

## 20.1 使用 create-vue 创建项目

>前提环境

Node.js：16+

```bash
node -v
```

>创建 Vue 应用

这一指令将会安装并执行 `create-vue`

```bash
npm init vue@latest
```

## 20.2 项目目录和关键文件

关键文件：
1. `vite.config.js`：项目的配置文件**基于 vite 的配置**
2. `package.json`：项目包文件**核心依赖项变成了 `Vue3.x` 和 `vite`**
3. `main.js`：入口文件 **createApp 函数创建应用实例**
4. `app.vue`：根组件 SFC 单文件组件 `script-template-style`
	1. 变化一：脚本 script 和模板 template 顺序调整
	2. 变化二：模板 template 不再要求唯一根元素
	3. 变化三：脚本 script 添加 `setup` 标识支持组合式 API
5. `index.html`：单页入口**提供 id 为 app 的挂载点**

# 21 组合式 API

## 21.1 setup 选项

### 21.1.1 setup 执行时机

setup 有两个特点：

1. setup 执行时机比 beforeCreate 要早  
2. setup 函数中获取不到this，this = undefined  

```js
export default { 
  setup () {  
    console.log('setup')  
  },  
  beforeCreate () {  
    console.log('beforeCreate')  
  }  
}
```

### 21.1.2 setup 特点

在 setup 中提供的任何数据或者函数，**必须通过 return**，这个数据或者函数才能在模版中被使用

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230918095724.png)

### 21.1.3 `<script setup>` 语法糖

我们可以通过在 `<script>` 标签上添加 `setup`，让 Vue 自动帮我们 return，免去了手动 return 的繁琐步骤

```html
<script setup>
	const message = 'Hi!'  
	const logMessage = () => {  
	  console.log(message)  
	}
</script>
```

![](https://raw.githubusercontent.com/michik0/notes-image/master/20230918100445.png)

## 21.2 reactive函数和ref函数

在 Vue 中，默认的数据并不是响应式的，如果需要将数据变为响应式，需要通过 `reactive` 和 `ref` 进行处理

### 21.2.1 reactive 函数

#### 作用

接受**对象类型数据的参数传入**，并返回一个**响应式的对象**

#### 语法

1. 从 vue 包中**导入 reactive 函数**
2. 在 `<script setup>` 中**执行 `reactive` 函数**并传入类型为对象的初始值，并使用变量接收返回值

```html
<script setup>  
  // 导入 reactive
  import { reactive } from 'vue'  
  // reactive 接受一个对象类型的数据，返回一个响应式对象  
  const state = reactive({  
    count: 100  
  })  
</script>  
  
<template>  
  {{ state.count }}  
  <button @click="state.count++">count++</button>  
</template>
```

### 21.2.2 ref 函数（推荐）

#### 作用

接收**简单类型或者对象类型的数据传入**并返回一个**响应式的对象**

#### 语法

```html
<script setup>  
  // 导入 ref
  import { ref } from 'vue'  
  // ref 接收简单类型或者对象类型的数据传入，返回一个响应式的对象  
  const count = ref(0)  
  // 注意：JS 访问 ref 对象，需要加上 .value 才能进行操作  
  const plusCount = () => {  
    count.value++  
  }  
</script>  
  
<template>  
  <!-- 注意：模版中访问 ref 对象，无需加上value -->  
  {{ count }}  
  <button @click="plusCount">count++</button>  
</template>
```

>注意：

1. JS 访问 ref 对象，需要加上 .value 才能进行操作  
2. 模版中访问 ref 对象，无需加上value

#### 本质

`ref` 在原有传入数据的基础上，外层包了一层对象，包成了复杂底层，封装成复杂类型之后，再借助 `reactive` 实现了响应式

## 21.3 computed 计算属性

计算属性基本思想和 Vue2 的完全一致，组合式API下的计算属性只是**修改了写法**

### 21.3.1 简单写法

```html
<script setup>  
  // 导入 computed
  import { computed } from 'vue'  
  const computedState = computed() => {
	return 基于响应式数据计算之后的值
  }
</script>
```

```js
<script setup>  
	import { computed, ref } from 'vue'  
	const arr = ref([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])  
	const computedState = computed(() => {  
	  // 注意，由于 arr 是通过 ref 包装后的，所以需要用 arr.value 后再进行过滤
	  return arr.value.filter(item => item > 5)  
	})  
</script>
```

### 21.3.2 完整写法

组合式API中，同样也提供了 computed 计算属性的完整写法，包含 getter 和 setter 方法

```html
<script setup>  
import { computed, ref } from 'vue'  

// 完整写法  
const firstName = ref('John')  
const lastName = ref('Doe')  
  
const fullName = computed({  
  // getter  
  get() {  
    return `${firstName.value} ${lastName.value}`  
  },  
  // setter  
  set(newValue) {  
    // 这里使用的是解构赋值语法，将 newValue[0] 赋值给 firstName.value
    // 将 newValue[1] 赋值给 lastName.value
    [firstName.value, lastName.value] = newValue.split(' ')  
  }})  
</script>
```

## 21.4 watch

组合式API中的watch和Vue2类似，都是监听一个或者多个数据的变化，数据变化时执行回调函数

组合式API中，watch也支持两个额外参数：1. immediate（立即执行）2. deep（深度侦听）

### 21.4.1 基本语法

#### 监听单个数据变化

```js
import { ref, watch } from 'vue'
watch(ref对象, (newValue, oldValue) => {  
	// 逻辑操作
})
```

#### 监听多个数据变化

```js
import { ref, watch } from 'vue'
watch([ref对象1, ref对象2], (newValue, oldValue) => {  
	// 逻辑操作
})
```

### 21.4.2 immediate

`immediate` 可以在监听器创建时立即触发回调，响应式数据变化之后继续执行回调

```js
watch(ref对象, (newValue, oldValue) => {  
	// 逻辑操作
}, {
	immediate: true
})
```

### 21.4.3 deep

`deep` 可以让监听器进行深度监视，即监视到对象，甚至对象中的对象

```js
watch(ref对象, (newValue, oldValue) => {  
	// 逻辑操作
}, {
	deep: true
})
```

```js
const obj = ref({ 
	name: 'michiko', 
	age: 18, 
	cat: { 
		name: '奶牛猫', 
		age: 5 
	} 
})  
watch(obj, (newValue, oldValue) => {  
  console.log(`obj发生改变:${JSON.stringify(oldValue)} -> ${JSON.stringify(newValue)}`)  
}, { deep: true })
```

### 21.4.4 精确监听对象的某个属性

>场景：只监听对象中的某一个属性

```js
//  精确监听对象中的某个属性  
const obj = ref({ name: 'michiko', age: 18 })  
watch(  
  // 监听的数据
  () => obj.value.name,  
  // 回调函数
  (newValue, oldValue) => {  
    console.log(`name发生变化:${oldValue} -> ${newValue}`)  
  }  
)
```

## 21.5 生命周期 API

| 选项式API            | 组合式API       |
| -------------------- | --------------- |
| **beforeCreate/created** | **setup**           |
| beforeMount          | onBeforeMount   |
| mounted              | onMounted       |
| beforeUpdate         | onBeforeUpdated |
| updated              | onUpdated       |
| **beforeUnmount**        | **onBeforeUnmount** |
| **unmounted**            | **onUnmounted**                |

```js
// 1. beforeCreate 和 created 相关代码一律放在 setup 中执行  
import { onMounted } from 'vue'  
  
const getList = () => {  
  setTimeout(() => {  
    console.log('发起请求')  
  }, 2000)  
}  
// 一进入页面，发起请求  
getList()  
  
// 2. mounted 生命周期中执行  
onMounted(() => {  
  console.log('mounted生命周期执行逻辑1')  
})  
  
// 生命周期钩子可以多次调用，并不会覆盖冲突，会按顺序多次执行  
onMounted(() => {  
  console.log('mounted生命周期执行逻辑2')  
})
```

## 21.6 父子通信

Vue3 中父子通信流程和 Vue2 是大致一致的，在子组件接收的时候有差别
### 21.6.1 父传子（编译宏：defineProps）

基本思想：

1. 父组件中给子组件绑定属性
2. 子组件内部通过 **`编译器宏`** 选项接收

#### 父组件

```html
<script setup>  
import SonComponent from '@/components/SonComponent.vue'  
import { ref } from 'vue'  
  
const money = ref(100)  
</script>

<template>  
  我是父组件  
  <SonComponent :money=money></SonComponent>  
</template>
```

#### 子组件

```html
<script setup>  
  // 通过编译宏获取到 props  
  const props = defineProps({  
    money: Number  
  })
</script>  
  
<template>  
  <div class="son">  
    我是子组件：{{ money }}  
  </div>  
</template>  
```

### 21.6.2 子传父（编译宏：defineEmits）

基本思想：

1. 父组件中给子组件标签通过 `@` 绑定事件
2. 子组件内部通过**编译宏生成 `emit`** ，用 `emit` 方法触发事件

#### 父组件

```html
<script setup>  
	import SonComponent from '@/components/SonComponent.vue'  
	import { ref } from 'vue'  
	  
	const money = ref(100)  
	const earnMoney = (m) => {  
	  money.value += m  
	}  
</script>  
  
<template>  
  我是父组件  
  // 绑定事件
  <SonComponent :money=money @earnMoney="earnMoney"></SonComponent>  
</template>
```

#### 子组件

```html
<script setup>  
    money: Number  
  })  
  // 通过 defineEmits 编译宏生成 emit 方法  
  const emit = defineEmits(['earnMoney'])  
  const earnMoney = (m) => {  
    // 触发自定义事件，并传递参数  
    emit('earnMoney', m)  
  }
</script>  
  
<template>  
  <div class="son">  
    我是子组件：{{ money }}  
    <button @click="earnMoney(5)">赚钱</button>  
  </div>  
</template>  
  
<style scoped>  
  .son {  
    border: 1px solid #000;  
    padding: 30px;  
  }  
</style>
```

## 21.7 模板引用

通过 `ref` 标识获取真实的 `dom` 对象或者组件实例对象

**通过 `ref.value` 可以获取得到真实的 dom 对象**

```js
<script setup>  
  import { ref } from 'vue'  
  
  const inp = ref(null)  
  const focusInput = () => {  
    inp.value.focus()  
  }</script>  
  
<template>  
  <input type="text" ref="inp">  
  <button @click="focusInput">输入框聚焦</button>  
</template>
```

## 21.8 组件暴露属性和方法：defineExpose()

默认情况下在 `<script setup>` 语法糖下**组件内部的属性和方法是不开放给父组件访问的**（正常情况下，无法通过 ref 获取组件，并且获取组件里的数据和函数）

但是可以通过 `defineExpose` 编译宏**指定哪些属性和方法允许访问**

>子组件

```html
<script setup>  
  const count = 999  
  const sayHi = () => {  
    console.log('hi!')  
  }  defineExpose({  
    sayHi
  })  
</script>  
  
<template>  
  
</template>
```

>父组件

```html
<script setup>  
  import { onMounted, ref } from 'vue'  
  import TestComponent from '@/components/TestComponent.vue'  
  
  const test = ref(null)  
  // 挂载后，再进行访问
  onMounted(() => {  
    test.value.sayHi()  
  })  
  </script>  
  
<template>
  <TestComponent ref="test"></TestComponent>  
</template>
```

## 21.9 provide 和 inject

### 21.9.1 作用

`provide` 和 `inject` 可以实现**顶层组件向任意的底层组件传递数据和方法**，实现**跨层组件通信**

1. 顶层组件通过 `provide` 函数提供数据/函数
2. 底层组件通过 `inject` 函数获取数据/函数

### 21.9.2 语法

#### 顶层组件

```js
provide('key', 顶层组件的数据)
```

#### 底层组件

```js
const message = inject('key')
```

### 21.9.3 应用

#### 顶层组件

```html
<script setup>  
  import CenterComponent from '@/components/CenterComponent.vue'  
  import { provide, ref } from 'vue'  
  
  // 1. 传递普通数据  
  provide('theme-color', 'pink')  
  // 2. 传递响应式数据  
  const count = ref(5)  
  provide('count', count)  
  // 3. 传递修改数据函数  
  provide('changeCount', (newCount) => {  
    count.value = newCount  
  })  
</script>  
  
<template>  
  <CenterComponent></CenterComponent>  
</template>
```

#### 底层组件

```html
<script setup>  
  import { inject } from 'vue'  
  
  const themeColor = inject('theme-color')  
  
  const count = inject('count')  
  const changeCountFn = inject('changeCount')  
  // 注意：遵循单向数据流，这里通过父组件提供的修改参数进行修改  
  setTimeout(() => {  
    changeCountFn(666)  
  }, 2000)  
</script>  
  
<template>  
  <h3>底层组件:{{ themeColor }} - {{ count }}</h3>  
</template>
```

## 21.10 Vue3.3 新特性：编译宏：defineOptions

### 21.10.1 背景

#### `<script setup>` 之前

有 `<script setup>` 之前，如果要定义 `props`，`emits` 可以轻而易举地添加一个与 `setup` 平级的属性。

```html
<script>
setup() {

},
props: {

}
</script>
```

#### `<script setup>` 之后

但是用了 `<script setup>` 后，就没法这么干了，因为 `setup` 属性已经没有了，自然无法添加与其平级的属性。

为了解决这一问题，引入了 `defineProps`与 `defineEmits` 这两个宏。但这只解决了 `props` 与 `emits` 这两个属性。

如果我们要定义组件的 `name` 或其他自定义的属性，还是得回到最原始的用法，再添加一个普通的 `<script>` 标签。这样就会存在两个 `<script>` 标签，让人无法接受。

```html
<script>
	export default {
		name: 'ComponentIndex'
	}
</script>

<script setup>
	// 逻辑代码
</script>
```

### 21.10.2 defineOptions 作用以及语法

所以在 **Vue3.3** 中新引入了 `defineOptions` 宏。顾名思义，主要是用来定义 `OptionsAPI` 的选项。可以用 `defineOptions` 定义任意的选项，**`props`，`emits`，`expose`，`slots` 除外（因为这些可以使用 defineXXX来做到）**

```html
<script setup>  
  defineOptions({  
    name: 'Index',  
    inheritAttrs: false,  
    // 更多自定义属性...  
  })  
</script>  
  
<template>  
</template>
```

## 21.11 Vue3.3 新特性：defineModel

**注意**：`defineModel` 是实验性质的特性，可能会被移除或者大改版

### 21.11.1 定义

在Vue3中，自定义组件上使用 `v-model`，相当于传递一个 `modelValue` 属性，同时触发 `update:modelValue` 事件，注意：Vue2 中自定义组件使用 `v-model` 等价于 `:value=xx` 和 `@input` 事件。

```html
<Child v-model="isVisible">
```

相当于

```html
<Child :modelValue="isVisible" @update: modelValue="isVisible=$event">
```

这时候，如果我们子组件要接收，那么子组件需要先定义 `props`，再定义 `emits`。其中有许多重复的代码。如果需要修改此值，还需要手动调用 `emit` 函数。非常的繁琐

### 21.11.2 语法

#### `vite.config.js`

由于 `defineModel` 是实验性质，所以需要进行额外配置

```js
// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue({
      script: {
        defineModel: true
      }
    }),
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
})
```
#### 父组件

```html
<script setup>  
  import { ref } from 'vue'  
  import MyInput from '@/components/MyInput.vue'  
  const mobile = ref('12345678910')  
</script>  
  
<template>  
  <MyInput v-model="mobile"></MyInput>  
</template>
```

#### 子组件

```html
<script setup>  
  import { defineModel } from 'vue'  
  const modelValue = defineModel()  
</script>  
  
<template>  
  <input  
      type="text"  
      :value="modelValue"  
      @input="e => modelValue = e.target.value"  
  >  
</template>
```

# 22 Pinia

## 22.1 定义

Pinia 是 Vue 的**最新状态管理工具**，是 Vuex 的替代品

## 22.2 优势

1. 提供更加简单的API（去掉了 `mutation` ）
2. 提供符合，组合式风格的API（与 Vue3 新语法统一）
3. 每一个 `store` 都是一个独立的模块（去掉了 `modules` ）
4. 配合 `TypeScript` 更加好，提供可靠的型断

## 22.3 配置 Pinia

>在实际开发项目的时候，关于Pinia的配置，可以在项目创建时自动添加

### 1 使用Vite创建一个空的Vue3项目

```bash
# npm create 等价于 npm init
npm create vue@latest
```

### 2 下载并引入 Pinia

#### 下载 pinia

```bash
npm i pinia
```

#### `main.js`

```js
const app = createApp(App)  
app.use(createPinia())  
app.mount('#app')
```

## 22.4 Store

### 22.4.1 定义并使用 Store

#### 定义 Store（一般遵循 useXxxStore 格式规范）

```js
import { defineStore } from 'pinia'  
import { computed, ref } from 'vue'  
  
// 参数1：仓库唯一标识  
export const useCounterStore = defineStore('couter', () => {  
    // 声明数据 state    
    const count = ref(0)  
  
    // 操作数据的方法 actions    
    const plusCount = () => count.value++  
    const subCount = () => count.value--  
  
    // 基于 state 的计算属性 getters    
    const doubleCount = computed(() => count.value * 2)  

	// 导出：只有导出的才能使用
    return {  
        count, plusCount, subCount, doubleCount  
    }  
})
```

#### 使用 Store

```js
<script setup>  
  import { useCounterStore } from '@/store/couter'  
  // 获取 store 对象
  const counterStore = useCounterStore()  
</script>  
  
<template>  
  <div>  
	<!-- 获取 state，getters -->
    <span>Son1 - {{ counterStore.count }} - {{ counterStore.doubleCount }}</span>  
    <!-- 调用 actions -->
    <button @click="counterStore.plusCount">+</button>  
  </div>  
</template>  
  
<style scoped></style>
```

### 22.4.2 注意（storeToRefs）

请注意，`store` 是一个用`reactive` 包裹的对象，这意味着不需要在 getter 之后写 `.value`，但是，就像`setup` 中的 `props` 一样，**我们不能对其进行解构**：

为了从 Store 中提取属性同时保持其响应式，您需要使用 `storeToRefs()`。 它将为任何响应式属性创建 refs。 当您仅使用 store 中的状态但不调用任何操作时，这很有用：

```js
<script setup>  
  import { useCounterStore } from '@/store/couter'  
  import { storeToRefs } from 'pinia'  
  // 数据解构  
  const { count, doubleCount } = storeToRefs(useCounterStore())  
  // 方法解构  
  const { plusCount } = useCounterStore()  
</script>  
  
<template>  
  <div>  
    <span>Son1 - {{ count }} - {{ doubleCount }}</span>  
    <button @click="plusCount">+</button>  
  </div>  
</template>  
  
<style scoped></style>
```

## 22.5 Pinia 持久化插件

>官网：<https://prazdevs.github.io/pinia-plugin-persistedstate/zh/guide/why.html>

经过持久化，可以在 `state` 数据发生变化时，默认自动存入 `localStorage`，刷新页面时，自动从 `localStorage` 将值赋值给 `state`

### 22.5.1 安装

```bash
npm i pinia-plugin-persistedstate
```

### 22.5.2 配置 `main.js`

```js
import { createPinia } from 'pinia' 
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate' 
const pinia = createPinia() 
pinia.use(piniaPluginPersistedstate)
```

### 22.5.3 用法

创建 Store 时，将 `persist` 选项设置为 `true`

```js
import { defineStore } from 'pinia'

export const useStore = defineStore(
  'main',
  () => {
    const someState = ref('你好 pinia')
    return { someState }
  },
  {
    persist: true,
  }
)
```

### 22.5.4 额外配置

参考：<https://prazdevs.github.io/pinia-plugin-persistedstate/zh/guide/config.html>

## 22.6 统一管理

### 22.6.1 Pinia 独立维护

我们需要将在 `main.js` 中关于 `pinia` 的相关代码剥离出来，形成一个单独的 `store/index.js` 文件，以便维护

#### `stores/index.js`

```js
import { createPinia } from 'pinia'  
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'  
  
const pinia = createPinia()  
pinia.use(piniaPluginPersistedstate)  
  
export default pinia
```

#### `src/main.js`

```js
import { createApp } from 'vue'  
  
import App from './App.vue'  
import router from './router'  
import pinia from '@/stores'  
  
const app = createApp(App)  
  
app.use(pinia)  
app.use(router)  
  
app.mount('#app')
```

### 22.6.2 仓库统一导出

正如 `Vuex` 一样，我们会创建 `stores/modules` 文件夹，用于存放业务相关的 `store.js`，但是随着文件的越来越多，我们需要每个 `store.js` 下使用 `return` 导出数据，十分的繁琐，所以我们希望尽可能所有的 `store` 统一导出

#### `stores/index.js` 中进行统一的导出

```js
// 接受 user 所有模块的按需导出  
export * from './modules/user'
```

#### 调用时，直接导入 stores/index.js 即可

```js
import { useUserStore } from '@/stores'
```


# 23 pnpm 管理工具

>官网：<https://www.pnpm.cn/>

- 优势：比同类工具快2倍左右、节省磁盘空间
- 安装方式：`npm install -g pnpm`
- 创建项目：`pnpm create vue`

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230919093959.png)

# 24 Vue Router 4

## 24.1 路由初始化

Vue Router4 比起 Vue Router3 的初始化有一些变化：

1. 创建路由实例由 createRouter 实现
2. 路由模式
	- history 模式使用 createWebHistory()
	- hash 模式使用 createWebHashHistory()
	- 参数：默认为 `/`，相当于 `vite.config.js` 中的 `base` 配置项。比如：如果设置为 `/test`，那么所有的路由都会变为 `/test/xxxx`

```js
import { createRouter, createWebHistory } from 'vue-router'  

// 采用了函数创建路由，Vue Router3中采用的是 new VueRouter()
const router = createRouter({  
  // 设置路由模式为 history
  history: createWebHistory(import.meta.env.BASE_URL),  
  routes: []  
})  
  
export default router
```

## 24.2 使用路由

在 Vue Router 4 中，由于组合式API中，this 指向为 undefined ，所以我们没办法在 `<script>` 中使用 `this.$router.push('/xx')` 进行路由跳转

### 24.2.1 Vue Router 4 获取路由对象

```js
const router = useRouter()  
const toListPage = () => {  
  router.push('/list')  
}
```

### 24.2.2 Vue Router 4 获取路由参数

```js
const route = useRoute()  
const toListPage = () => {  
  router.push('/list')  
  console.log(route.query.key)  
  console.log(route.params.key)  
}
```

## 24.3 路由导航守卫

^7a2ec4

区别于[[#^10661c|Vue Router3路由导航守卫]]，Vue Router 4中的语法有发生变化，如下：

```js
// to：即将要进入的目标
// from：当前导航正要离开的路由
const router = createRouter({ ... })

router.beforeEach((to, from) => {
  // ...
  // 返回值有两种：
  // 1. false：取消当前的导航。如果浏览器的 URL 改变了(可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 `from` 路由对应的地址。
  // 2. 一个路由地址('/login'): 通过一个路由地址跳转到一个不同的地址，就像调用 router.push() 一样，你可以设置诸如 `replace: true` 或 `name: 'home'` 之类的配置。当前的导航被中断，然后进行一个新的导航，就和 `from` 一样。
  // 注：如果什么都没有，不进行返回 或 undefined 或 返回 `true`，则导航是有效的，并调用下一个导航守卫
  return false
})
```

# 附录

## 1 Tab栏切换高亮

```html
<!DOCTYPE html>  
<html lang="en">  
<head>  
  <meta charset="UTF-8">  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">  
  <title>Document</title>  
  <style>    * {  
      margin: 0;  
      padding: 0;  
    }  
    ul {  
      display: flex;  
      border-bottom: 2px solid #e01222;  
      padding: 0 10px;  
    }  
    li {  
      width: 100px;  
      height: 50px;  
      line-height: 50px;  
      list-style: none;  
      text-align: center;  
    }  
    li a {  
      display: block;  
      text-decoration: none;  
      font-weight: bold;  
      color: #333333;  
    }  
    li a.active {  
      background-color: #e01222;  
      color: #fff;  
    }  
  
  </style>  
</head>  
<body>  
  
  <div id="app">  
    <ul>  
      <li v-for="(item, index) in list" :key="item.id">  
        <a :class="{ active:  index === activeIndex}" href="#" @click="activeIndex = index">{{ item.name }}</a>  
      </li>  
    </ul>  
  </div>  
  <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>  
  <script>    const app = new Vue({  
      el: '#app',  
      data: {  
        // 记录高亮下标  
        activeIndex: 0,  
        list: [
          { id: 1, name: '京东秒杀' },  
          { id: 2, name: '每日特价' },  
          { id: 3, name: '品类秒杀' }  
        ]  
      }  
    })  
  </script>  
</body>  
</html>
```

## 2 Json-server

### 2.1 定义

>在 30 秒内获得零编码的完整假 REST API

Json-server 是一个`零代码快速搭建本地 RESTful API 的工具`。它使用 `JSON 文件作为数据源`，并提供了一组简单的路由和端点，可以模拟后端服务器的行为。

### 2.2 使用步骤

#### 1. 安装

```bash
npm install -g json-server
```

#### 2. 创建 JSON 文件

```json
{
  "posts": [
    { "id": 1, "title": "json-server", "author": "typicode" }
  ],
  "comments": [
    { "id": 1, "body": "some comment", "postId": 1 }
  ],
  "profile": { "name": "typicode" }
}
```

#### 3. 启动 JSON 服务器

```bash
json-server --watch db.json
```

#### 4. 访问 API 地址，获取得到相应的 JSON

现在如果访问 <http://localhost:3000/posts/1>，会得到：

```json
{ "id": 1, "title": "json-server", "author": "typicode" }
```

| 请求方式 | 地址   | 说明 |
| -------- | ------ | ---- |
| GET      | /posts | 获取所有信息     |
| GET      | /posts/1 | 获取id为1的数据     |
| POST      | /posts | 插入数据     |
| PUT      | /posts/1 | 修改id为1的数据     |
| PATCH      | /posts/1 | **修改id为1的部分数据，body传什么字段就修改什么字段**     |
| DELETE      | /posts/1 | 删除id为1的数据     |

## 3 Vant 组件库

>Vant 2 官网：<https://vant-contrib.gitee.io/vant/v2/#/zh-CN/>

Vant 是一个**轻量、可靠的移动端组件库**，目前 Vant 官方提供了 [Vue 2 版本](https://vant-contrib.gitee.io/vant/v2)、[Vue 3 版本](https://vant-contrib.gitee.io/vant)和[微信小程序版本](http://vant-contrib.gitee.io/vant-weapp)，并由社区团队维护 [React 版本](https://github.com/3lang3/react-vant)和[支付宝小程序版本](https://github.com/ant-move/Vant-Aliapp)。

>移动端适配

Vant 默认使用 `px` 作为样式单位，如果需要使用 `viewport` 单位 (vw, vh, vmin, vmax)，推荐使用 [postcss-px-to-viewport](https://github.com/evrone/postcss-px-to-viewport) 进行转换。

[postcss-px-to-viewport](https://github.com/evrone/postcss-px-to-viewport) 是一款 PostCSS 插件，用于**将 px 单位自动转化为 vw/vh 单位。**

>其他常用组件库

Vue的组件库并不是唯一的，vant-ui 也仅仅只是组件库的一种。一般会按照不同平台进行分类：

- PC端：`element-ui（element-plus）`、`ant-design-vue`
- 移动端：`vant-ui`、`Mint UI（饿了么)`、`Cube UI（滴滴）`

### 3.1 添加请求 loading 效果

#### 3.1.1 背景

有时候因为网络原因，一次请求的结果可能需要一段时间后才能回来，此时，需要给用户添加 loading 提示。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230915161842.png)

#### 3.1.2 好处

1. **节流处理**：防止用户在一次请求还没回来之前，多次进行点击，发送无效请求
2. **友好提示**：告知用户，目前是在加载中，请耐心等待，用户体验会更好

#### 3.1.3 步骤

>具体的API参考官网：<https://vant-contrib.gitee.io/vant/v2/#/zh-CN/>

1. Axios 请求拦截器中添加加载效果

```js
import Vue from 'vue'  
import axios from 'axios'  
import { Toast } from 'vant'  
  
Vue.use(Toast)  

const instance = axios.create({  
  baseURL: 'http://cba.itlike.com/public/index.php?s=/api/',  
  timeout: 1000  
})  
  
// 添加请求拦截器  
instance.interceptors.request.use(function (config) {  
  // 显示加载中  
  Toast.loading({  
    message: '加载中...',  
    forbidClick: true,  
    loadingType: 'spinner',  
    duration: 0  
  })  
  ...
})
```

2. Axios 响应拦截器中移除加载效果

```js
// 添加响应拦截器  
instance.interceptors.response.use(function (response) {  
  // 清除加载样式
  Toast.clear()  
  ...
})
```

## 4 Sass：CSS预处理器

>官网：<https://www.sass.hk/>

```bash
pnpm install -D sass
```

## 5 Element Plus

`Element Plus` 是基于 Vue 3 的组件库

>官网：<https://element-plus.org/zh-CN/>

### 5.1 安装

#### 下载包

```bash
pnpm install element-plus
```

#### 按需导入（推荐）

```bash
npm install -D unplugin-vue-components unplugin-auto-import
```

#### 修改 `vite.config 2.js`

```js
// vite.config.ts
import { defineConfig } from 'vite'
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

export default defineConfig({
  // ...
  plugins: [
    // ...
    AutoImport({
      resolvers: [ElementPlusResolver()],
    }),
    Components({
      resolvers: [ElementPlusResolver()],
    }),
  ],
})
```

## 6 目录结构以及命名规范

- `src/api`：存放接口请求
	- JS中暴露的名称要以 `模块名xxService`（比如说，用户注册：`userRegisterService`）
- `src/router`：存放路由
- `src/stores`：存放 stores
	- `index.js`：用于统一管理所有模块的导出
	- `modules/xx.js`：业务 stores 模块
- `src/utils`：存放工具类
- `src/views`：存放一级路由、二级路由....
	- 必须以大驼峰命名
- `src/components`：存放组件
	- 必须以大驼峰命名