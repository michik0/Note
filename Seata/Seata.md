>引用
>

# 1 单数据源事务 & 多数据源事务

在分布式场景下，一个系统由多个子系统构成，每个子系统有独立的数据源。多个子系统之间通过互相调用来组合出更复杂的业务。在时下流行的微服务系统架构中，每一个子系统被称作一个微服务，同样每个微服务都维护自己的数据库，以保持独立性。

但是一个数据库的本地事务机制仅仅对落到自己身上的增删改查等操作起作用，无法干涉对其他数据库的查询操作。比如购物业务包括了 `仓库数据库的更新` 以及 `订单数据库的更新` 。

**所以，数据库自身提供的本地事务机制无法确保业务对多数据源全局操作的可靠性。基于此，针对多数据源操作提出的分布式事务机制就出现了。分布式事务也可以叫做全局事务。**

# 2 常见分布式事务解决方案

## 2.1 分布式事务模型

- 事务参与者：例如每个数据库就是一个事务参与者（例如OrderService，RepositoryService）

- 事务协调者：访问多个数据源的服务程序，（例如ShopingService）

- 资源管理器（Resource Manager, RM）：通常与事务参与者同义。

- 事务管理器（Transaction Manager, TM）：通常与事务协调者同义。

在分布式事务模型中，一个 TM 管理多个 RM，即一个服务程序访问多个数据源；TM 是一个全局事务管理器，协调多方本地事务的进度，使其共同提交或回滚，最终达成一种全局的 ACID 特性。

## 2.2 二将军问题和幂等性

二将军问题是网络领域的一个经典问题，用于表达计算机网络中互联协议设计的微妙性和复杂性。这里给出一个二将军问题的简化版本：

一支白军被围困在一个山谷中，山谷的左右两侧是蓝军。困在山谷中的白军人数多于山谷两侧的任意一支蓝军，而少于两支蓝军的之和。若一支蓝军对白军单独发起进攻，则必败无疑；但若两支蓝军同时发起进攻，则可取胜。两只蓝军的总指挥位于山谷左侧，他希望两支蓝军同时发起进攻，这样就要把命令传到山谷右侧的蓝军，以告知发起进攻的具体时间。假设他们只能派遣士兵穿越白军所在的山谷（唯一的通信信道）来传递消息，那么在穿越山谷时，士兵有可能被俘虏。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230312222238.png)

只有当送信士兵成功往返后，总指挥才能确认这场战争的胜利（上方图）。现在问题来了，派遣出去送信的士兵没有回来，则左侧蓝军中的总指挥能不能决定按命令中约定的时间发起进攻？

1. 命令还没送达就被俘虏了（中间图），这时候右侧蓝军根本不知道要何时进攻；
2. 命令送达，但返回途中被俘虏了（下方图），这时候右侧蓝军知道要何时进攻，但左侧蓝军不知道右侧蓝军是否知晓进攻时间。

类似的问题在计算机网络中普遍存在，例如发送者给接受者发送一个 HTTP 请求，或者 MySQL 客户端向 MySQL 服务器发送一条插入语句，然后超时了没有得到响应。请问服务器是写入成功了还是失败了？答案是不确定，有以下几种情况：

1. 可能请求由于网络故障根本没有送到服务器，因此写入失败；
2. 可能服务器收到了，也写入成功了，但是向客户端发送响应前服务器宕机了；
3. 可能服务器收到了，也写入成功了，也向客户端发送了响应，但是由于网络故障未送到客户端。

无论哪种场景，在客户端看来都是一样的结果：它发出的请求没有得到响应。为了确保服务端成功写入数据，客户端只能重发请求，直至接收到服务端的响应。

类似的问题问题被称为网络二将军问题。

网络二将军问题的存在使得消息的发送者往往要重复发送消息，直到收到接收者的确认才认为发送成功，但这往往又会导致消息的重复发送。例如电商系统中订单模块调用支付模块扣款的时候，如果网络故障导致二将军问题出现，扣款请求重复发送，产生的重复扣款结果显然是不能被接受的。因此要保证一次事务中的扣款请求无论被发送多少次，接收方有且只执行一次扣款动作，这种保证机制叫做接收方的幂等性。

## 2.3 两阶段提交（2PC）&& 三阶段提交（3PC）

### 2.3.1 两阶段提交（2PC）

2PC 是一种实现分布式事务的简单模型，这两个阶段是：

**准备阶段**：

事务协调者向各个事务参与者发起询问请求，各个参与者协调者进行回复：

- YES：表示已准备好，允许提交全局事务

- NO：表示本参与者无法拿到全局事务所需的本地资源，因为它被其他本地事务锁住了或超时。

**提交阶段：**

根据各个参与者的恢复，协调者进行不同的操作：

- 各个参与者回复的都是 YES ，则协调者向所有参与者发起事务提交操作，然后所有参与者收到后各自执行本地事务提交操作并向协调者发送 ACK；

- 如果任何一个参与者回复 NO 或者超时，则协调者向所有参与者发起事务回滚操作，然后所有参与者收到后各自执行本地事务回滚操作并向协调者发送 ACK。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313111703.png)

**2PC存在的问题**

1. 性能问题：执行过程中，所有参与节点都是事务阻塞性的，当参与者占有公共资源时，其他第三方节点访问公共资源就不得不处于阻塞状态，为了数据的一致性而牺牲了可用性，对性能影响较大，不适合高并发高性能场景

2. 可靠性问题：2PC非常依赖协调者，当协调者发生故障时，尤其是第二阶段，那么所有的参与者就会都处于锁定事务资源的状态中，而无法继续完成事务操作（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）

3. 数据一致性问题：在阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。==于是整个分布式系统便出现了数据不一致性的现象。==

### 2.3.2 三阶段提交（3PC）

3PC，三阶段提交协议，是二阶段提交协议的改进版本，三阶段提交有两个改动点：

- 在协调者和参与者中都引入超时机制。
- 在第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。

3PC会分为3个阶段，CanCommit 准备阶段、PreCommit 预提交阶段、DoCommit 提交阶段，处理流程如下：

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313112755.png?token=ARKCCAC26UDTYURZB7BFFRTEB2MHY)

**阶段一：**

协调者向参与者发送 canCommit 请求，参与者如果可以提交就返回Yes响应，否则返回No响应，具体流程如下：

- 事务询问：协调者向所有参与者发出包含事务内容的 canCommit 请求，询问是否可以提交事务，并等待所有参与者答复。
- 响应反馈：参与者收到 canCommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。

**阶段二：**

协调者根据参与者的反应情况来决定是否可以进行事务的 PreCommit 操作。根据响应情况，有以下两种可能：
- 执行事务，假如所有参与者均反馈 yes，协调者预执行事务，具体如下：
	- 发送预提交请求：协调者向参与者发送 PreCommit 请求，并进入准备阶段
	- 事务预提交 ：参与者接收到 PreCommit 请求后，会执行本地事务操作，并将 undo 和 redo 信息记录到事务日志中（但不提交事务）
	- 响应反馈 ：如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230313114614.png)

