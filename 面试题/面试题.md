## Redis的key和value可以存储的最大值分别是多少？

- 虽然Key的大小上限为`512M`,但是一般建议key的大小不要超过`1KB`，这样既可以节约存储空间，又有利于Redis进行检索。
- value的最大值也是`512M`。对于String类型的value值上限为`512M`，而集合、链表、哈希等key类型，单个元素的value上限也为`512M`。

## 怎么利用Redis实现数据的去重？

- `Set`：它可以去除重复元素，也可以快速判断某一个元素是否存在于集合中，**如果元素很多（比如上亿的计数），占用内存很大**。
- `bit`：它可以用来实现比set内存高度压缩的计数，它通过一个bit设置为1或者0，表示存储某个元素是否存在信息。例如网站唯一访客计数，可以把`user_id`作为 bit 的偏移量 offset，如设置为1表示有访问，使用1 MB的空间就可以存放800多万用户的一天访问计数情况。
-   `HyperLogLog`：实现超大数据量精确的唯一计数都是比较困难的，`HyperLogLog`可以仅仅使用 12 k左右的内存，实现上亿的唯一计数，而且误差控制在0.81%左右。
-   `Bloomfilter`：布隆过滤器是一种占用空间很小的数据结构，它由一个很长的二进制向量和一组Hash映射函数组成，它用于检索一个元素是否在一个集合中。[[Redis#^9edeb7|布隆过滤器笔记]]

## Redis什么时候需要序列化？Redis序列化的方式有哪些？

>序列化：将 Java 对象转换成字节流的过程。
>反序列化：将字节流转换成 Java 对象的过程。

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230312165613.png)

**使用序列化的场景：**

- 把内存中的对象状态保存到一个文件中或者数据库中的时候（最常用，如保存到redis)
- 再比喻想用套接字在网络上传送对象的时候，都需要序列化。

**序列化的方式：**

RedisSerializer接口是 Redis 序列化接口，用于 Redis KEY 和 VALUE 的序列化

-   JDK 序列化方式 （默认）
-   String 序列化方式
-   JSON 序列化方式
-   XML 序列化方式

## MySQL的B+树的高度怎么计算？

InnoDB存储引擎最小储存单元是页，一页大小就是**16k**。

B+树叶子存的是数据，内部节点存的是键值+指针。索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而再去数据页中找到需要的数据；

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230312172728.png)

假设B+树的高度为2的话，即有一个根结点和若干个叶子结点。这棵B+树的存放总记录数为=根结点指针数 * 单个叶子节点记录行数。

-   如果一行记录的数据大小为1k，那么单个叶子节点可以存的记录数=16k / 1k = 16。

-   非叶子节点内存放多少指针呢？我们假设主键ID为**bigint类型，长度为8字节**(**面试官问你int类型，一个int就是32位，4字节**)，而指针大小在InnoDB源码中设置为6字节，所以就是8+6=14字节，16k / 14B =16 * 1024B / 14B = 1170

因此，一棵高度为2的B+树，能存放1170 * 16 = 18720 条这样的数据记录。同理一棵高度为3的B+树，能存放1170 * 1170 * 16 = 21902400，也就是说，可以存放两千万左右的记录。B+树高度一般为1-3层，已经满足千万级别的数据存储。

## 线程池的状态有哪些？获取多线程并发执行结果的方式有哪些？

>线程池和线程的状态是不一样的哈

线程池有这几个状态：`RUNNING，SHUTDOWN，STOP，TIDYING，TERMINATED`。

**RUNNING**

-   该状态的线程池会接收新任务，并处理阻塞队列中的任务;
-   调用线程池的`shutdown()`方法，可以切换到SHUTDOWN状态;
-   调用线程池的`shutdownNow()`方法，可以切换到STOP状态;

**SHUTDOWN**

-   该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；
-   队列为空，并且线程池中执行的任务也为空时，进入TIDYING状态;

**STOP**

-   该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；
-   线程池中执行的任务为空，进入TIDYING状态;

**TIDYING**

-   该状态表明所有的任务已经运行终止，记录的任务数量为0。
-   `terminated()`执行完毕，进入TERMINATED状态

**TERMINATED**

-   该状态表示线程池彻底终止

**线程池各个状态切换状态图如下：**

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230312172943.png)
  
## 线程池原理？各个参数的作用？

ThreadPoolExecutor的构造函数：

```java
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime,TimeUnit unit,
   BlockingQueue<Runnable> workQueue,
   ThreadFactory threadFactory,
   RejectedExecutionHandler handler) 
```

**几个核心参数的作用：**

-   corePoolSize：线程池核心线程数最大值
-   maximumPoolSize：线程池最大线程数大小
-   keepAliveTime：线程池中非核心线程空闲的存活时间大小，非核心线程等待新任务的最长时间，超过这个时间多余的线程将被终止。
-   unit：线程空闲存活时间单位
-   workQueue：存放任务的阻塞队列
-   threadFactory：用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。
-   handler： 线程池的饱和策略事件，主要有四种类型
	- AbortPolicy（默认）：抛出一个异常
	- DiscardPolicy：直接丢弃任务
	- DiscardOldestPolicy：丢弃队列里最老的任务，将当前这个任务继续提交给线程池
	- CallerRunsPolicy：交给调用线程池的线程（比如说主线程）进行处理

**线程池原理：**

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230312174343.png)

- 提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。
- 如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。
- 当线程池里面存活的线程数已经等于corePoolSize了，并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。
- 如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。

## ThreadLocal的使用场景有哪些？原理？内存泄漏？

**ThreadLocal**，即线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。

**ThreadLocal的应用场景**

- 数据库连接池
- 会话管理中使用

**ThreadLocal内存结构图：**

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230312175107.png)

**ThreadLocal原理**

- Thread对象中持有一个ThreadLocal.ThreadLocalMap的成员变量。
- ThreadLocalMap内部维护了Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal本身，value是ThreadLocal的泛型值。
- 每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。

ThreadLocal：
```java
public void set(T value) {  
    Thread t = Thread.currentThread();  
    ThreadLocalMap map = getMap(t);  
    if (map != null) {  
        map.set(this, value);  
    } else {  
        createMap(t, value);  
    }  
}

// getMap()
ThreadLocalMap getMap(Thread t) {  
    return t.threadLocals;  
}
```

Thread：
```java
public class Thread implements Runnable {
	/* ThreadLocal values pertaining to this thread. This map is maintained  
	 * by the ThreadLocal class. */
	 ThreadLocal.ThreadLocalMap threadLocals = null;
}
```

ThreadLocalMap：
```java
static class ThreadLocalMap {  
	static class Entry extends WeakReference<ThreadLocal<?>> {  
		/** The value associated with this ThreadLocal. */  
		Entry(ThreadLocal<?> k, Object v) {  
			super(k);  
			value = v;  
		}  
	}
}
```

## 说一下Raft算法？

Raft 算法是分布式系统开发首选的共识算法，它通过“一切以领导者为准”的方式，实现一系列值的共识和各节点日志的一致。

**Raft选举过程涉及三种角色和任期（Term）：**

- Follower（追随者）：默默地接收和处理来自Leader的消息，当等待Leader心跳信息超时的时候，就主动站出来，推荐自己当Candidate。
- Candidate（候选人）：向其他节点发送投票请求，通知其他节点来投票，如果赢得了大多数（N/2+1）选票，就晋升Leader。
- Leader（领导者）：负责处理客户端请求，进行日志复制等操作，每一轮选举的目标就是选出一个领导者；领导者会不断地发送心跳信息，通知其他节点“我是领导者，我还活着，你们不要发起新的选举，不用找个新领导者来替代我。”
- Term（任期）：这跟民主社会的选举很像，每一届新的履职期称之为一届任期。

**领导选举过程：**

1.  在初始时，集群中所有的节点都是Follower状态，都被设定一个随机选举超时时间（一般150ms-300ms）：

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230312181744.png)

2. 如果Follower在规定的超时时间，都没有收到来自Leader的心跳，它就发起选举：将自己的状态切为 Candidate，增加自己的任期编号，然后向集群中的其它Follower节点发送请求，询问其是否选举自己成为Leader：

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230312181842.png)

3. 其他节点收到候选人A的请求投票消息后，如果在编号为1的这届任期内还没有进行过投票，那么它将把选票投给节点A，并增加自己的任期编号：

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230312182036.png)

4. 当收到来自集群中过半节点的接受投票后，A节点即成为本届任期内 Leader，他将周期性地发送心跳消息，通知其他节点我是Leader，阻止Follower发起新的选举：

![image.png](https://raw.githubusercontent.com/michik0/notes-image/master/20230312194101.png)